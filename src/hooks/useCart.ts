// hooks/useCart.ts - Con sincronizaci√≥n de localStorage
'use client'
import { PromotionVariants } from '@/types/domain'
import { usePathname, useRouter } from 'next/navigation'
import { useCallback, useEffect, useRef, useState } from 'react'

export interface CartItem {
  id: number
  name: string
  price: number
  image: string
  quantity: number
  stock: number
  promotionVariants?: (PromotionVariants | null)[] | null
}

// Tipos para delete confirmation
interface DeleteConfirmation {
  isOpen: boolean
  productId: number | null
  message?: string
  onConfirm: (() => void) | null
}

// üëà CONFIGURACI√ìN DE RUTAS SIMPLIFICADA
const ALLOWED_MINICART_ROUTES = [
  '/products', // P√°gina de productos
  '/categories', // P√°gina de categor√≠as
  '/search', // P√°gina de b√∫squeda
  '/product', // P√°gina de producto individual
  '/category', // P√°gina de categor√≠a espec√≠fica
  '/productos', // Base de productos
  '/productos/variante' // PDP con variantes
]

// üëà RUTAS DONDE NO SE DEBE MOSTRAR EL MINICART (incluyendo home y cart)
const NO_MINICART_ROUTES = [
  // '/', // Homepage - NO abrir minicart
  '/cart', // P√°gina del carrito - NO abrir minicart
  '/checkout', // P√°gina de checkout
  '/login', // P√°gina de login
  '/register', // P√°gina de registro
  '/admin', // Panel admin
  '/profile', // Perfil de usuario
  '/orders' // √ìrdenes del usuario
]

// üëà FUNCI√ìN SIMPLIFICADA PARA VERIFICAR SI DEBE ABRIR MINICART
const shouldOpenMinicart = (currentPath: string): boolean => {
  // Verificar rutas donde NO se debe abrir minicart
  const shouldNotOpen = NO_MINICART_ROUTES.some((route) => {
    return currentPath === route || currentPath.startsWith(route + '/')
  })

  if (shouldNotOpen) {
    return false
  }

  // Verificar rutas permitidas para minicart
  const isAllowed = ALLOWED_MINICART_ROUTES.some((allowedRoute) => {
    return (
      currentPath === allowedRoute || currentPath.startsWith(allowedRoute + '/')
    )
  })

  return isAllowed
}

export function useCart() {
  const router = useRouter()
  const pathname = usePathname()
  const [items, setItems] = useState<CartItem[]>([])
  const [totalItems, setTotalItems] = useState(0)
  const [totalPrice, setTotalPrice] = useState(0)
  const [isCartOpen, setIsCartOpen] = useState(false)
  const [toastMessage, setToastMessage] = useState<string | null>(null)

  // FLAGS PARA CONTROLAR EL FLUJO
  const [isInitialized, setIsInitialized] = useState(false)
  const hasLoadedRef = useRef(false)
  const isMountedRef = useRef(true)

  // üÜï ESTADO PARA DELETE CONFIRMATION
  const [deleteConfirmation, setDeleteConfirmation] =
    useState<DeleteConfirmation>({
      isOpen: false,
      productId: null,
      message: '',
      onConfirm: null
    })

  // üëà FUNCI√ìN PARA VERIFICAR SI LA RUTA PERMITE MINICART (para otros componentes)
  const isMinicartAllowedOnRoute = (currentPath: string): boolean => {
    return shouldOpenMinicart(currentPath)
  }

  // üÜï FUNCI√ìN PARA SINCRONIZAR CON LOCALSTORAGE
  const syncWithLocalStorage = useCallback(() => {
    try {
      const savedCart = localStorage.getItem('cart')
      if (savedCart) {
        const parsedCart = JSON.parse(savedCart)
        console.log('üîÑ Syncing cart with localStorage:', parsedCart)
        setItems(parsedCart)
      }
    } catch (error) {
      console.error('‚ùå Error syncing with localStorage:', error)
    }
  }, [])

  // üÜï LISTENER PARA EVENTOS DE ACTUALIZACI√ìN DEL CARRITO
  useEffect(() => {
    const handleCartUpdate = () => {
      console.log('üì° Received cart update event')
      syncWithLocalStorage()
    }

    // Escuchar evento personalizado
    window.addEventListener('cartUpdated', handleCartUpdate)

    // Tambi√©n escuchar cambios en localStorage (para tabs m√∫ltiples)
    window.addEventListener('storage', (e) => {
      if (e.key === 'cart') {
        console.log('üì° localStorage cart changed in another tab')
        syncWithLocalStorage()
      }
    })

    return () => {
      window.removeEventListener('cartUpdated', handleCartUpdate)
      window.removeEventListener('storage', handleCartUpdate)
    }
  }, [syncWithLocalStorage])

  // üëà CERRAR MINICART AL CAMBIAR A RUTA BLOQUEADA
  useEffect(() => {
    console.log('üîÑ Route changed to:', pathname)

    if (!isMinicartAllowedOnRoute(pathname)) {
      console.log('üîí Closing minicart due to route restriction')
      setIsCartOpen(false)
    }
  }, [pathname])

  // EFECTO 1: CARGAR desde localStorage
  useEffect(() => {
    console.log('üîÑ Initializing cart from localStorage...')

    if (hasLoadedRef.current) {
      console.log('‚è≠Ô∏è Already loaded, skipping...')
      return
    }

    const loadCart = async () => {
      try {
        const savedCart = localStorage.getItem('cart')
        console.log('üì¶ Raw localStorage data:', savedCart)

        if (savedCart && savedCart !== '[]' && savedCart !== 'null') {
          const parsedCart = JSON.parse(savedCart)
          console.log('‚úÖ Parsed cart data:', parsedCart)

          if (isMountedRef.current) {
            setItems(parsedCart)
          }
        } else {
          console.log('üì≠ No cart data found, keeping empty array')
        }
      } catch (error) {
        console.error('‚ùå Error parsing cart from localStorage:', error)
      } finally {
        if (isMountedRef.current) {
          hasLoadedRef.current = true
          setIsInitialized(true)
          console.log('‚úÖ Cart initialization complete')
        }
      }
    }

    loadCart()

    return () => {
      isMountedRef.current = false
    }
  }, [])

  // EFECTO 2: GUARDAR en localStorage
  useEffect(() => {
    if (!isInitialized) {
      console.log('‚è≠Ô∏è Skipping save - not initialized yet')
      return
    }

    console.log('üíæ Saving to localStorage:', items)

    try {
      localStorage.setItem('cart', JSON.stringify(items))

      const itemCount = items.reduce((total, item) => total + item.quantity, 0)
      const priceTotal = items.reduce(
        (total, item) => total + item.price * item.quantity,
        0
      )

      setTotalItems(itemCount)
      setTotalPrice(priceTotal)

      console.log(
        '‚úÖ Cart saved successfully. Items:',
        itemCount,
        'Total:',
        priceTotal
      )
    } catch (error) {
      console.error('‚ùå Error saving to localStorage:', error)
    }
  }, [items, isInitialized])

  // EFECTO 3: Toast timer
  useEffect(() => {
    if (toastMessage) {
      const timer = setTimeout(() => {
        setToastMessage(null)
      }, 3000)
      return () => clearTimeout(timer)
    }
  }, [toastMessage])

  const addItem = (
    item: Omit<CartItem, 'quantity'>,
    initialQuantity: number = 1
  ) => {
    console.log('‚ûï Adding item:', item.name, 'Qty:', initialQuantity)

    // Agregar el item al estado SIEMPRE
    setItems((prevItems) => {
      const existingItemIndex = prevItems.findIndex((i) => i.id === item.id)
      if (existingItemIndex >= 0) {
        const updatedItems = [...prevItems]
        updatedItems[existingItemIndex].quantity += initialQuantity
        console.log(
          'üìù Updated existing item quantity:',
          updatedItems[existingItemIndex].quantity
        )
        return updatedItems
      } else {
        const newItems = [...prevItems, { ...item, quantity: initialQuantity }]
        console.log('üÜï Added new item. Total items:', newItems.length)
        return newItems
      }
    })

    // Mostrar toast SIEMPRE
    setToastMessage(`A√±adido a la cesta!`)

    // Abrir minicart solo si la ruta lo permite
    if (shouldOpenMinicart(pathname)) {
      console.log('‚ú® Opening minicart after adding item on route:', pathname)
      setIsCartOpen(true)
    } else {
      console.log('üö´ Not opening minicart on route:', pathname)
    }
  }

  const removeItem = (id: number) => {
    console.log('üóëÔ∏è Removing item ID:', id)
    const itemToRemove = items.find((item) => item.id === id)

    setItems((prevItems) => {
      const newItems = prevItems.filter((item) => item.id !== id)
      console.log('üìù Items after removal:', newItems.length)
      return newItems
    })

    if (itemToRemove) {
      setToastMessage(`Correctamente`)
    }
  }

  const updateQuantity = (id: number, quantity: number) => {
    console.log('üîÑ Updating quantity - ID:', id, 'New qty:', quantity)

    if (quantity <= 0) {
      removeItem(id)
      return
    }

    // ‚úÖ NUEVA L√ìGICA: Leer desde localStorage para preservar stock actualizado
    setItems((prevItems) => {
      // üîç Obtener datos actuales de localStorage
      const currentCartData = localStorage.getItem('cart')
      let localStorageItems: CartItem[] = []

      if (currentCartData) {
        try {
          localStorageItems = JSON.parse(currentCartData)
          console.log('üì¶ Current localStorage cart:', localStorageItems)
        } catch (error) {
          console.error('‚ùå Error parsing localStorage cart:', error)
          // Fallback al estado actual si falla el parsing
          localStorageItems = prevItems
        }
      } else {
        // Fallback al estado actual si no hay localStorage
        localStorageItems = prevItems
      }

      // üîÑ Actualizar solo la cantidad, preservando otros datos de localStorage
      const updatedItems = localStorageItems.map((item) => {
        if (item.id === id) {
          const itemFromLocalStorage = localStorageItems.find(
            (lsItem) => lsItem.id === id
          )
          console.log('üìù Updating item:', {
            name: item.name,
            oldQuantity: item.quantity,
            newQuantity: quantity,
            stockFromLS: itemFromLocalStorage?.stock || item.stock,
            stockFromState: item.stock
          })

          // ‚úÖ Preservar todos los datos de localStorage, solo cambiar quantity
          return {
            ...item, // Usar datos de localStorage (incluye stock actualizado)
            quantity // Solo actualizar la cantidad
          }
        }
        return item
      })

      console.log(
        '‚úÖ Updated items with preserved localStorage data:',
        updatedItems
      )
      return updatedItems
    })

    // Mostrar toast SIEMPRE
    setToastMessage(`Cantidad actualizada`)

    // Abrir minicart solo si la ruta lo permite
    if (shouldOpenMinicart(pathname)) {
      console.log(
        '‚ú® Opening minicart after updating quantity on route:',
        pathname
      )
      setIsCartOpen(true)
    } else {
      console.log('üö´ Not opening minicart on route:', pathname)
    }
  }

  const incrementQuantity = (id: number) => {
    console.log('‚¨ÜÔ∏è Incrementing quantity for ID:', id)
    setItems((prevItems) =>
      prevItems.map((item) =>
        item.id === id ? { ...item, quantity: item.quantity + 1 } : item
      )
    )
  }

  const decrementQuantity = (id: number) => {
    console.log('‚¨áÔ∏è Decrementing quantity for ID:', id)
    setItems((prevItems) => {
      return prevItems
        .map((item) => {
          if (item.id === id) {
            const newQuantity = item.quantity - 1
            if (newQuantity <= 0) {
              console.log('üóëÔ∏è Quantity reached 0, will remove item')
              return null
            }
            return { ...item, quantity: newQuantity }
          }
          return item
        })
        .filter(Boolean) as CartItem[]
    })
  }

  const clearCart = () => {
    console.log('üßπ Clearing entire cart')
    setItems([])
    setToastMessage('Carrito vaciado')
  }

  // üëà FUNCI√ìN PRINCIPAL: ABRIR CARRITO CON VALIDACI√ìN DE RUTA
  const openCart = () => {
    const currentPath = pathname
    console.log('üëÜ Attempting to open cart on route:', currentPath)

    if (!isMinicartAllowedOnRoute(currentPath)) {
      console.log('üö´ Minicart not allowed on this route, redirecting to /cart')
      // router.push('/cart')
      return
    }

    console.log('‚úÖ Opening minicart')
    setIsCartOpen(true)
  }

  const closeCart = () => {
    console.log('üëá Closing cart')
    setIsCartOpen(false)
  }

  const toggleCart = () => {
    if (isCartOpen) {
      closeCart()
    } else {
      openCart()
    }
  }

  // üëà FUNCI√ìN HELPER PARA COMPONENTES
  const canShowMinicart = (): boolean => {
    return isMinicartAllowedOnRoute(pathname)
  }

  // üëà FUNCI√ìN PARA IR AL CARRITO COMPLETO
  const goToCartPage = () => {
    console.log('üõí Navigating to full cart page')
    setIsCartOpen(false)
    router.push('/cart')
  }

  // üÜï FUNCIONES DE DELETE CONFIRMATION
  const openDeleteConfirmation = useCallback(
    (id: number, message?: string, onConfirm?: () => void) => {
      console.log('üóëÔ∏è Opening delete confirmation:', { id })
      setDeleteConfirmation({
        isOpen: true,
        message,
        productId: id,
        onConfirm: onConfirm || (() => removeItem(id))
      })
    },
    []
  )

  const closeDeleteConfirmation = useCallback(() => {
    console.log('‚ùå Closing delete confirmation')
    setDeleteConfirmation({
      isOpen: false,
      productId: null,
      message: '',
      onConfirm: null
    })
  }, [])

  const confirmDelete = useCallback(() => {
    console.log('‚úÖ Confirming delete')
    if (deleteConfirmation.onConfirm) {
      deleteConfirmation.onConfirm()
    }
    closeDeleteConfirmation()
  }, [deleteConfirmation.onConfirm, closeDeleteConfirmation])

  // DEBUG INFO
  useEffect(() => {
    console.log('üìä Cart State Summary:', {
      itemsCount: items.length,
      totalItems,
      totalPrice: totalPrice.toFixed(2),
      isInitialized,
      hasLoaded: hasLoadedRef.current,
      currentRoute: pathname,
      canShowMinicart: canShowMinicart()
    })
  }, [items, totalItems, totalPrice, isInitialized, pathname])

  return {
    // Funcionalidad principal del carrito
    items,
    addItem,
    removeItem,
    updateQuantity,
    incrementQuantity,
    decrementQuantity,
    clearCart,
    totalItems,
    totalPrice,
    isCartOpen,
    openCart,
    closeCart,
    toggleCart,
    goToCartPage,
    canShowMinicart,
    toastMessage,
    setToastMessage,
    isInitialized,

    // Funcionalidad de delete confirmation
    deleteConfirmation,
    openDeleteConfirmation,
    closeDeleteConfirmation,
    confirmDelete
  }
}

// üëà CONFIGURACI√ìN EXPORTADA
export const CART_ROUTE_CONFIG = {
  ALLOWED_ROUTES: ALLOWED_MINICART_ROUTES,
  BLOCKED_ROUTES: NO_MINICART_ROUTES
}

export default useCart
