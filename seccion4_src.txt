===================================================================================
üì¶ C√ìDIGO FUENTE (src/)
===================================================================================

üå≥ ESTRUCTURA DE SRC:
src/middleware.ts
src/types/database/database.d.ts
src/types/database/index.ts
src/types/shipping.ts
src/types/next-auth.d.ts
src/types/checkout.ts
src/types/domain/domain.d.ts
src/types/domain/index.ts
src/.DS_Store
src/app/order/[orderNumber]/confirmation/BackButton.tsx
src/app/order/[orderNumber]/confirmation/ActionButtons.tsx
src/app/order/[orderNumber]/confirmation/page.tsx
src/app/favicon.ico
src/app/.DS_Store
src/app/payment/[transactionId]/page.tsx
src/app/checkout/page.tsx
src/app/search/page.tsx
src/app/layout.tsx
src/app/cart/page.tsx
src/app/api/auth/[...nextauth]/route.ts
src/app/api/payment/[transactionId]/fail/route.ts
src/app/api/payment/[transactionId]/complete/route.ts
src/app/api/payment/[transactionId]/route.ts
src/app/api/ratings/product/[id]/route.ts
src/app/api/ratings/route.ts
src/app/api/ratings/variant/[id]/route.ts
src/app/api/shipping/calculate-user/route.ts
src/app/api/checkout/validate-coupon/route.ts
src/app/api/checkout/route.ts
src/app/api/checkout/validate-stock/route.ts


üìÅ ARCHIVO: src/middleware.ts
------------------------------------------------------------------------------------
import { getToken } from 'next-auth/jwt'
import { NextResponse, type NextRequest } from 'next/server'

// Rutas que requieren autenticaci√≥n
const protectedRoutes = ['/account', '/orders', '/favorites', '/addresses']

// Nota: Podr√≠amos definir rutas p√∫blicas expl√≠citamente, pero por ahora
// simplemente permitimos el acceso a cualquier ruta que no est√© en protectedRoutes

export async function middleware(request: NextRequest): Promise<NextResponse> {
  const { pathname } = request.nextUrl

  // Verificar si la ruta actual es una ruta protegida
  const isProtectedRoute = protectedRoutes.some(
    (route) => pathname === route || pathname.startsWith(`${route}/`)
  )

  // Si no es una ruta protegida, permitir el acceso
  if (!isProtectedRoute) {
    return NextResponse.next()
  }

  // Obtener el token de autenticaci√≥n
  const token = await getToken({
    req: request,
    secret: process.env.NEXTAUTH_SECRET
  })

  // Si el usuario no est√° autenticado y la ruta es protegida, redirigir al inicio
  if (token === null && isProtectedRoute) {
    const url = new URL('/', request.url)
    return NextResponse.redirect(url)
  }

  // Si el usuario est√° autenticado, permitir el acceso a la ruta protegida
  return NextResponse.next()
}

// Configurar el middleware para que se ejecute solo en las rutas especificadas
export const config = {
  matcher: [
    /*
     * Coincide con todas las rutas de p√°ginas excepto:
     * - API routes
     * - Archivos est√°ticos (e.g. im√°genes, fuentes, etc.)
     * - Favicon
     */
    '/((?!api|_next/static|_next/image|favicon.ico).*)'
  ]
}



üìÅ ARCHIVO: src/types/database/database.d.ts
------------------------------------------------------------------------------------
// ============================================================================
// TIPOS DE BASE DE DATOS - SIN RELACIONES
// ============================================================================
// Nombres tal como est√°n en la base de datos
// Para uso directo con consultas SQL
// ============================================================================

export type Maybe<T> = T | null;
export type InputMaybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };

/** All built-in and custom scalars, mapped to their actual values */
export interface Scalars {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** The `BigInt` scalar type represents non-fractional signed whole numeric values. */
  BigInt: { input: number; output: number; }
  /** A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar. */
  DateTime: { input: Date; output: Date; }
  /** The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch. */
  Timestamp: { input: Date; output: Date; }
}

export type AttributeOptionImagesImageType =
  | 'back'
  | 'bottom'
  | 'detail'
  | 'front'
  | 'left'
  | 'lifestyle'
  | 'packaging'
  | 'right'
  | 'top';

export type AttributesDisplayType =
  | 'color'
  | 'custom'
  | 'pills'
  | 'radio'
  | 'select';

export type CouponsApplicableTo =
  | 'all'
  | 'categories'
  | 'products';

export type CouponsDiscountType =
  | 'fixed_amount'
  | 'percentage';

export type OrderSummaryPaymentStatus =
  | 'failed'
  | 'paid'
  | 'pending'
  | 'refunded';

export type OrderSummaryStatus =
  | 'cancelled'
  | 'delivered'
  | 'pending'
  | 'processing'
  | 'refunded'
  | 'shipped';

export type OrderTrackingStatus =
  | 'delivered'
  | 'failed_delivery'
  | 'in_transit'
  | 'out_for_delivery'
  | 'preparing'
  | 'shipped';

export type OrdersPaymentStatus =
  | 'failed'
  | 'paid'
  | 'pending'
  | 'refunded';

export type OrdersStatus =
  | 'cancelled'
  | 'delivered'
  | 'pending'
  | 'processing'
  | 'refunded'
  | 'shipped';

export type PaymentMethodsProcessingFeeType =
  | 'fixed'
  | 'percentage';

export type PaymentTransactionsStatus =
  | 'cancelled'
  | 'completed'
  | 'failed'
  | 'pending'
  | 'processing'
  | 'refunded';

export type PromotionsDiscountType =
  | 'fixed_amount'
  | 'percentage';

export type VariantImagesImageType =
  | 'back'
  | 'bottom'
  | 'detail'
  | 'front'
  | 'left'
  | 'lifestyle'
  | 'packaging'
  | 'right'
  | 'top';

export interface AttributeOptionImages {
  /** Texto alternativo */
  alt_text?: Maybe<Scalars['String']['output']>;
  attribute_option_id: Scalars['Int']['output'];
  created_at: Scalars['Timestamp']['output'];
  display_order?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  image_type: AttributeOptionImagesImageType;
  /** Imagen normal 600x800 (opcional) */
  image_url_normal: Scalars['String']['output'];
  /** Imagen thumbnail 140x140 para selector de atributo */
  image_url_thumb: Scalars['String']['output'];
  /** Imagen zoom 1200x1200 (opcional) */
  image_url_zoom: Scalars['String']['output'];
  is_primary?: Maybe<Scalars['Int']['output']>;
  updated_at: Scalars['Timestamp']['output'];
}

export interface AttributeOptions {
  additional_cost?: Maybe<Scalars['Float']['output']>;
  attribute_id: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  value: Scalars['String']['output'];
}

export interface Attributes {
  display_type: AttributesDisplayType;
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
}

export interface Banner {
  created_at: Scalars['Timestamp']['output'];
  description?: Maybe<Scalars['String']['output']>;
  display_order?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  image_url?: Maybe<Scalars['String']['output']>;
  link?: Maybe<Scalars['String']['output']>;
  subtitle?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  updated_at: Scalars['Timestamp']['output'];
}

export interface Brands {
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
}

export interface Categories {
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  image_url?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  parent_id?: Maybe<Scalars['Int']['output']>;
}

export interface CouponUsage {
  coupon_id: Scalars['Int']['output'];
  customer_id: Scalars['Int']['output'];
  discount_amount: Scalars['Float']['output'];
  id: Scalars['Int']['output'];
  order_id: Scalars['Int']['output'];
  used_at: Scalars['Timestamp']['output'];
}

export interface Coupons {
  applicable_ids?: Maybe<Scalars['JSON']['output']>;
  applicable_to?: Maybe<CouponsApplicableTo>;
  code: Scalars['String']['output'];
  created_at: Scalars['Timestamp']['output'];
  description?: Maybe<Scalars['String']['output']>;
  discount_type: CouponsDiscountType;
  discount_value: Scalars['Float']['output'];
  end_date: Scalars['DateTime']['output'];
  id: Scalars['Int']['output'];
  is_active?: Maybe<Scalars['Int']['output']>;
  max_discount_amount?: Maybe<Scalars['Float']['output']>;
  min_purchase_amount?: Maybe<Scalars['Float']['output']>;
  name: Scalars['String']['output'];
  start_date: Scalars['DateTime']['output'];
  updated_at: Scalars['Timestamp']['output'];
  usage_limit?: Maybe<Scalars['Int']['output']>;
  usage_limit_per_customer?: Maybe<Scalars['Int']['output']>;
  used_count?: Maybe<Scalars['Int']['output']>;
}

export interface Customers {
  address_id?: Maybe<Scalars['Int']['output']>;
  created_at: Scalars['Timestamp']['output'];
  /** Documento de identidad  */
  dni?: Maybe<Scalars['String']['output']>;
  email: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  is_active?: Maybe<Scalars['Int']['output']>;
  lastname: Scalars['String']['output'];
  name: Scalars['String']['output'];
  password: Scalars['String']['output'];
  /** numero de celular */
  phone?: Maybe<Scalars['String']['output']>;
  photo?: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['Timestamp']['output'];
}

export interface CustomersAddresses {
  /** Nombre de la direcci√≥n (Casa, Oficina, etc.) */
  alias: Scalars['String']['output'];
  /** Dpto/Interior/Piso/Lote/Bloque (opcional) */
  apartment?: Maybe<Scalars['String']['output']>;
  created_at: Scalars['Timestamp']['output'];
  department: Scalars['String']['output'];
  district: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  id_customer: Scalars['Int']['output'];
  /** 1 = direcci√≥n por defecto */
  is_default?: Maybe<Scalars['Int']['output']>;
  /** Latitud GPS */
  latitude?: Maybe<Scalars['Float']['output']>;
  /** Longitud GPS */
  longitude?: Maybe<Scalars['Float']['output']>;
  province: Scalars['String']['output'];
  /** Nombre de la avenida/calle/jir√≥n */
  street_name: Scalars['String']['output'];
  /** N√∫mero de la direcci√≥n */
  street_number: Scalars['String']['output'];
  updated_at: Scalars['Timestamp']['output'];
}

export interface OrderItems {
  /** Descuento aplicado a este item */
  discount_amount?: Maybe<Scalars['Float']['output']>;
  id: Scalars['Int']['output'];
  order_id: Scalars['Int']['output'];
  /** Nombre del producto al momento de compra */
  product_name: Scalars['String']['output'];
  quantity: Scalars['Int']['output'];
  /** Precio total (quantity * unit_price) */
  total_price: Scalars['Float']['output'];
  /** Precio unitario al momento de compra */
  unit_price: Scalars['Float']['output'];
  /** Atributos de la variante (color, talla, etc.) */
  variant_attributes?: Maybe<Scalars['JSON']['output']>;
  /** Variante del producto comprada */
  variant_id: Scalars['Int']['output'];
  /** SKU de la variante */
  variant_sku: Scalars['String']['output'];
}

export interface OrderSummary {
  /** Empresa de courier (Olva, Shalom, etc.) */
  courier_company?: Maybe<Scalars['String']['output']>;
  created_at: Scalars['Timestamp']['output'];
  customer_email?: Maybe<Scalars['String']['output']>;
  customer_id: Scalars['Int']['output'];
  customer_name?: Maybe<Scalars['String']['output']>;
  /** Fecha estimada de entrega */
  estimated_delivery?: Maybe<Scalars['Date']['output']>;
  id: Scalars['Int']['output'];
  /** N√∫mero √∫nico de orden (ORD-2025-001234) */
  order_number: Scalars['String']['output'];
  payment_status: OrderSummaryPaymentStatus;
  status: OrderSummaryStatus;
  /** Total final a pagar */
  total_amount: Scalars['Float']['output'];
  total_items: Scalars['BigInt']['output'];
  total_quantity?: Maybe<Scalars['Float']['output']>;
  /** N√∫mero de seguimiento del courier */
  tracking_number?: Maybe<Scalars['String']['output']>;
}

export interface OrderTracking {
  /** Empresa de courier (Olva, Shalom, etc.) */
  courier_company?: Maybe<Scalars['String']['output']>;
  created_at: Scalars['Timestamp']['output'];
  /** Ubicaci√≥n actual del paquete */
  current_location?: Maybe<Scalars['String']['output']>;
  delivered_at?: Maybe<Scalars['Timestamp']['output']>;
  /** Nombre de quien recibi√≥ */
  delivered_to?: Maybe<Scalars['String']['output']>;
  /** Notas de entrega */
  delivery_notes?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  order_id: Scalars['Int']['output'];
  shipped_at?: Maybe<Scalars['Timestamp']['output']>;
  status: OrderTrackingStatus;
  /** N√∫mero de seguimiento del courier */
  tracking_number?: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['Timestamp']['output'];
}

export interface Orders {
  /** Notas internas del admin */
  admin_notes?: Maybe<Scalars['String']['output']>;
  created_at: Scalars['Timestamp']['output'];
  customer_id: Scalars['Int']['output'];
  /** Notas del cliente */
  customer_notes?: Maybe<Scalars['String']['output']>;
  /** Descuento aplicado */
  discount_amount?: Maybe<Scalars['Float']['output']>;
  /** Fecha estimada de entrega */
  estimated_delivery?: Maybe<Scalars['Date']['output']>;
  id: Scalars['Int']['output'];
  /** N√∫mero √∫nico de orden (ORD-2025-001234) */
  order_number: Scalars['String']['output'];
  /** Fecha de pago confirmado */
  paid_at?: Maybe<Scalars['Timestamp']['output']>;
  /** M√©todo de pago usado */
  payment_method?: Maybe<Scalars['String']['output']>;
  payment_status: OrdersPaymentStatus;
  /** Direcci√≥n de env√≠o */
  shipping_address_id: Scalars['Int']['output'];
  /** Costo de env√≠o */
  shipping_cost?: Maybe<Scalars['Float']['output']>;
  /** M√©todo de env√≠o */
  shipping_method?: Maybe<Scalars['String']['output']>;
  status: OrdersStatus;
  /** Subtotal antes de descuentos */
  subtotal: Scalars['Float']['output'];
  /** Impuestos (IGV) */
  tax_amount?: Maybe<Scalars['Float']['output']>;
  /** Total final a pagar */
  total_amount: Scalars['Float']['output'];
  updated_at: Scalars['Timestamp']['output'];
}

export interface PaymentMethods {
  code: Scalars['String']['output'];
  created_at: Scalars['Timestamp']['output'];
  description?: Maybe<Scalars['String']['output']>;
  display_order?: Maybe<Scalars['Int']['output']>;
  icon_url?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  is_active?: Maybe<Scalars['Int']['output']>;
  max_amount?: Maybe<Scalars['Float']['output']>;
  min_amount?: Maybe<Scalars['Float']['output']>;
  name: Scalars['String']['output'];
  processing_fee_type?: Maybe<PaymentMethodsProcessingFeeType>;
  processing_fee_value?: Maybe<Scalars['Float']['output']>;
  requires_verification?: Maybe<Scalars['Int']['output']>;
  settings?: Maybe<Scalars['JSON']['output']>;
  updated_at: Scalars['Timestamp']['output'];
}

export interface PaymentTransactions {
  amount: Scalars['Float']['output'];
  created_at: Scalars['Timestamp']['output'];
  currency?: Maybe<Scalars['String']['output']>;
  expires_at?: Maybe<Scalars['Timestamp']['output']>;
  gateway_response?: Maybe<Scalars['JSON']['output']>;
  id: Scalars['Int']['output'];
  net_amount: Scalars['Float']['output'];
  order_id: Scalars['Int']['output'];
  payment_data?: Maybe<Scalars['JSON']['output']>;
  payment_method_id: Scalars['Int']['output'];
  processed_at?: Maybe<Scalars['Timestamp']['output']>;
  processing_fee?: Maybe<Scalars['Float']['output']>;
  reference_number?: Maybe<Scalars['String']['output']>;
  status?: Maybe<PaymentTransactionsStatus>;
  transaction_id?: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['Timestamp']['output'];
}

export interface Permissions {
  created_at: Scalars['Timestamp']['output'];
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['Timestamp']['output'];
}

export interface ProductCategories {
  category_id: Scalars['Int']['output'];
  product_id: Scalars['Int']['output'];
}

export interface ProductRatingSummary {
  average_rating?: Maybe<Scalars['Float']['output']>;
  five_star?: Maybe<Scalars['Float']['output']>;
  four_star?: Maybe<Scalars['Float']['output']>;
  one_star?: Maybe<Scalars['Float']['output']>;
  product_id: Scalars['Int']['output'];
  three_star?: Maybe<Scalars['Float']['output']>;
  total_ratings: Scalars['BigInt']['output'];
  two_star?: Maybe<Scalars['Float']['output']>;
  verified_purchases?: Maybe<Scalars['Float']['output']>;
}

export interface ProductVariants {
  created_at: Scalars['Timestamp']['output'];
  id: Scalars['Int']['output'];
  price: Scalars['Float']['output'];
  product_id: Scalars['Int']['output'];
  sku: Scalars['String']['output'];
  stock: Scalars['Int']['output'];
  updated_at: Scalars['Timestamp']['output'];
}

export interface Products {
  base_price?: Maybe<Scalars['Float']['output']>;
  brand_id?: Maybe<Scalars['Int']['output']>;
  created_at: Scalars['Timestamp']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['Timestamp']['output'];
}

export interface PromotionVariants {
  created_at: Scalars['Timestamp']['output'];
  promotion_id: Scalars['Int']['output'];
  promotion_price?: Maybe<Scalars['Float']['output']>;
  stock_limit: Scalars['Int']['output'];
  variant_id: Scalars['Int']['output'];
}

export interface Promotions {
  created_at: Scalars['Timestamp']['output'];
  description?: Maybe<Scalars['String']['output']>;
  discount_type: PromotionsDiscountType;
  discount_value: Scalars['Float']['output'];
  end_date: Scalars['DateTime']['output'];
  id: Scalars['Int']['output'];
  is_active?: Maybe<Scalars['Int']['output']>;
  min_purchase_amount?: Maybe<Scalars['Float']['output']>;
  name: Scalars['String']['output'];
  start_date: Scalars['DateTime']['output'];
  updated_at: Scalars['Timestamp']['output'];
}

export interface RatingImages {
  created_at: Scalars['Timestamp']['output'];
  id: Scalars['Int']['output'];
  image_url: Scalars['String']['output'];
  rating_id: Scalars['Int']['output'];
}

export interface Roles {
  created_at: Scalars['Timestamp']['output'];
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['Timestamp']['output'];
}

export interface RolesSections {
  id: Scalars['Int']['output'];
  id_rol?: Maybe<Scalars['Int']['output']>;
  id_section?: Maybe<Scalars['Int']['output']>;
}

export interface Sections {
  display_order?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  image?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
}

export interface Services {
  created_at: Scalars['Timestamp']['output'];
  description?: Maybe<Scalars['String']['output']>;
  display_order?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  image_url?: Maybe<Scalars['String']['output']>;
  slug?: Maybe<Scalars['String']['output']>;
  subtitle?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  updated_at: Scalars['Timestamp']['output'];
}

export interface ServicesImages {
  created_at: Scalars['Timestamp']['output'];
  description?: Maybe<Scalars['String']['output']>;
  display_order?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  id_service?: Maybe<Scalars['Int']['output']>;
  image_url?: Maybe<Scalars['String']['output']>;
  subtitle?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['Timestamp']['output'];
}

export interface ShippingMethods {
  base_cost: Scalars['Float']['output'];
  created_at: Scalars['Timestamp']['output'];
  description?: Maybe<Scalars['String']['output']>;
  display_order?: Maybe<Scalars['Int']['output']>;
  estimated_days_max?: Maybe<Scalars['Int']['output']>;
  estimated_days_min?: Maybe<Scalars['Int']['output']>;
  free_shipping_threshold?: Maybe<Scalars['Float']['output']>;
  id: Scalars['Int']['output'];
  is_active?: Maybe<Scalars['Int']['output']>;
  name: Scalars['String']['output'];
  updated_at: Scalars['Timestamp']['output'];
}

export interface ShippingZoneMethods {
  cost: Scalars['Float']['output'];
  created_at: Scalars['Timestamp']['output'];
  estimated_days_max?: Maybe<Scalars['Int']['output']>;
  estimated_days_min?: Maybe<Scalars['Int']['output']>;
  free_shipping_threshold?: Maybe<Scalars['Float']['output']>;
  id: Scalars['Int']['output'];
  is_active?: Maybe<Scalars['Int']['output']>;
  shipping_method_id: Scalars['Int']['output'];
  shipping_zone_id: Scalars['Int']['output'];
  updated_at: Scalars['Timestamp']['output'];
}

export interface ShippingZones {
  created_at: Scalars['Timestamp']['output'];
  districts: Scalars['JSON']['output'];
  id: Scalars['Int']['output'];
  is_active?: Maybe<Scalars['Int']['output']>;
  name: Scalars['String']['output'];
  updated_at: Scalars['Timestamp']['output'];
}

export interface Users {
  created_at: Scalars['Timestamp']['output'];
  email: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  is_active?: Maybe<Scalars['Int']['output']>;
  lastname: Scalars['String']['output'];
  password: Scalars['String']['output'];
  photo?: Maybe<Scalars['String']['output']>;
  role_id: Scalars['Int']['output'];
  updated_at: Scalars['Timestamp']['output'];
  username: Scalars['String']['output'];
}

export interface VariantAttributeOptions {
  attribute_option_id: Scalars['Int']['output'];
  variant_id: Scalars['Int']['output'];
}

export interface VariantImages {
  /** Texto alternativo para SEO */
  alt_text?: Maybe<Scalars['String']['output']>;
  created_at: Scalars['Timestamp']['output'];
  /** Orden de visualizaci√≥n */
  display_order?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  image_type: VariantImagesImageType;
  /** Imagen normal 600x800 */
  image_url_normal: Scalars['String']['output'];
  /** Imagen thumbnail 140x140 */
  image_url_thumb: Scalars['String']['output'];
  /** Imagen zoom 1200x1200 */
  image_url_zoom: Scalars['String']['output'];
  /** Imagen principal de la variante */
  is_primary?: Maybe<Scalars['Int']['output']>;
  updated_at: Scalars['Timestamp']['output'];
  variant_id: Scalars['Int']['output'];
}

export interface VariantRatingSummary {
  average_rating?: Maybe<Scalars['Float']['output']>;
  five_star?: Maybe<Scalars['Float']['output']>;
  four_star?: Maybe<Scalars['Float']['output']>;
  one_star?: Maybe<Scalars['Float']['output']>;
  three_star?: Maybe<Scalars['Float']['output']>;
  total_ratings: Scalars['BigInt']['output'];
  two_star?: Maybe<Scalars['Float']['output']>;
  variant_id: Scalars['Int']['output'];
  verified_purchases?: Maybe<Scalars['Float']['output']>;
}

export interface VariantRatings {
  created_at: Scalars['Timestamp']['output'];
  customer_id: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  rating: Scalars['Int']['output'];
  review?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['Timestamp']['output'];
  variant_id: Scalars['Int']['output'];
  verified_purchase: Scalars['Int']['output'];
}



üìÅ ARCHIVO: src/types/database/index.ts
------------------------------------------------------------------------------------
export * from './database'



üìÅ ARCHIVO: src/types/shipping.ts
------------------------------------------------------------------------------------
// üìÑ types/shipping.ts
import { type ShippingCalculation } from '@/backend/shipping-zone-method/ShippingZoneMethod.interfaces'

// Tipo para direcci√≥n con opciones de env√≠o
export interface ShippingOptionForAddress {
  addressId: number
  address: {
    id: number
    alias: string
    streetName: string
    streetNumber: string
    district: string
    province: string
    department: string
    apartment?: string
  }
  shippingOptions: ShippingCalculation[]
  defaultShippingOption?: ShippingCalculation
}

// Respuesta del API para c√°lculo de env√≠o
export interface ShippingCalculationResponse {
  defaultAddress: ShippingOptionForAddress | null
  allAddresses: ShippingOptionForAddress[]
  userId: string
  message?: string
}

// Request para c√°lculo de env√≠o
export interface ShippingCalculationRequest {
  productVariantId: number
  quantity: number
  orderValue: number
}



üìÅ ARCHIVO: src/types/next-auth.d.ts
------------------------------------------------------------------------------------
import { type DefaultSession, type DefaultUser } from 'next-auth'

declare module 'next-auth' {
  interface Session {
    user: {
      id: string
    } & DefaultSession['user']
  }

  interface User extends DefaultUser {
    id: string
  }
}



üìÅ ARCHIVO: src/types/checkout.ts
------------------------------------------------------------------------------------
// üìÑ Checkout.interfaces.ts
import { type CartItem } from '@/hooks/useCart'
import { type Coupons, type CustomersAddresses } from '@/types/domain'

// Datos necesarios para el checkout
export interface CheckoutData {
  items: CartItem[]
  shippingAddressId: number
  paymentMethodId: number
  paymentMethodCode: string
  shippingMethodId: number
  shippingMethodName: string
  couponCode?: string
  customerNotes?: string
  paymentData?: Partial<CheckoutData>
}

// C√°lculos de la orden
export interface OrderCalculation {
  subtotal: number
  discountAmount: number
  shippingCost: number
  taxAmount: number
  totalAmount: number
  estimatedDelivery: Date | null
  appliedCoupon?: Coupons
}

// Opciones de env√≠o calculadas
export interface ShippingOption {
  methodId: number
  methodName: string
  cost: number
  isFree: boolean
  estimatedDays: {
    min: number
    max: number
  }
  description?: string
}

// Opciones de pago calculadas con comisiones
export interface PaymentOption {
  methodId: number
  methodName: string
  methodCode: string
  baseAmount: number
  processingFee: number
  finalAmount: number
  iconUrl?: string
  description?: string
  requiresVerification: boolean
}

// Resumen completo del checkout
export interface CheckoutSummary {
  items: CartItem[]
  itemCount: number
  totalQuantity: number
  calculation: OrderCalculation
  shippingOptions: ShippingOption[]
  paymentOptions: PaymentOption[]
  selectedShipping?: ShippingOption
  selectedPayment?: PaymentOption
  customerAddresses: CustomersAddresses[]
  selectedAddress?: CustomersAddresses
}

// Datos para crear la orden
export interface CreateOrderData {
  customerId: number
  items: CartItem[]
  shippingAddressId: number
  paymentMethodId: number
  shippingMethodId: number
  couponCode?: string
  customerNotes?: string
  paymentData?: Partial<CheckoutData>
}

// Respuesta del checkout
export interface CheckoutResponse {
  success: boolean
  orderId?: number
  orderNumber?: string
  paymentUrl?: string
  error?: string
  validationErrors?: ValidationError[]
}

export interface ValidationError {
  field: string
  message: string
}

// Estados del checkout
export type CheckoutStep =
  | 'shipping'
  | 'payment'
  | 'review'
  | 'processing'
  | 'complete'

export interface CheckoutState {
  step: CheckoutStep
  loading: boolean
  error?: string
  data: Partial<CheckoutData>
  summary?: CheckoutSummary
}

// Validaci√≥n de stock
export interface StockValidation {
  isValid: boolean
  errors: Array<{
    variantId: number
    requestedQuantity: number
    availableStock: number
    message: string
  }>
}

// Validaci√≥n de cup√≥n
export interface CouponValidation {
  isValid: boolean
  coupon?: Coupons
  discountAmount: number
  error?: string
}

// Datos del usuario para el checkout
export interface CheckoutUser {
  id: number
  name: string
  lastname: string
  email: string
  phone: string
  addresses: CustomersAddresses[]
  defaultAddressId?: number
}



üìÅ ARCHIVO: src/types/domain/domain.d.ts
------------------------------------------------------------------------------------
// ============================================================================
// TIPOS DE DOMINIO B√ÅSICOS - SOLO INTERFACES Y ENUMS
// ============================================================================
// Para uso con consultas SQL directas
// ============================================================================

export type Maybe<T> = T | null;

export type InputMaybe<T> = T | null;

export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };

export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };

export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };

export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };

export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };

export interface Scalars {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }

  BigInt: { input: number; output: number; }

  Date: { input: any; output: any; }

  DateTime: { input: Date; output: Date; }

  JSON: { input: any; output: any; }

  Timestamp: { input: Date; output: Date; }
}

export interface AttributeOptionImages {

  altText?: Maybe<Scalars['String']['output']>;
  attributeOption?: Maybe<AttributeOptions>;
  attributeOptionId: Scalars['Int']['output'];

  displayOrder?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  imageType: AttributeOptionImagesImageType;

  imageUrlNormal: Scalars['String']['output'];

  imageUrlThumb: Scalars['String']['output'];

  imageUrlZoom: Scalars['String']['output'];
  isPrimary?: Maybe<Scalars['Int']['output']>;

}

export type AttributeOptionImagesImageType =
  | 'back'
  | 'bottom'
  | 'detail'
  | 'front'
  | 'left'
  | 'lifestyle'
  | 'packaging'
  | 'right'
  | 'top';

export interface AttributeOptions {
  additionalCost?: Maybe<Scalars['Float']['output']>;
  attribute?: Maybe<Attributes>;
  attributeId: Scalars['Int']['output'];
  attributeOptionImages?: Maybe<Array<Maybe<AttributeOptionImages>>>;
  id: Scalars['Int']['output'];
  value: Scalars['String']['output'];
  variantAttributeOptions?: Maybe<Array<Maybe<VariantAttributeOptions>>>;
}

export interface Attributes {
  attributeOption?: Maybe<AttributeOptions>;
  displayType: AttributesDisplayType;
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
}

export type AttributesDisplayType =
  | 'color'
  | 'custom'
  | 'pills'
  | 'radio'
  | 'select';

export interface Banner {

  description?: Maybe<Scalars['String']['output']>;
  displayOrder?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  imageUrl?: Maybe<Scalars['String']['output']>;
  link?: Maybe<Scalars['String']['output']>;
  subtitle?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];

}

export interface Brands {
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  product?: Maybe<Products>;
}

export interface Categories {
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  imageUrl?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  parentId?: Maybe<Scalars['Int']['output']>;
  productCategories?: Maybe<Array<Maybe<ProductCategories>>>;
}

export interface CouponUsage {
  coupon?: Maybe<Coupons>;
  couponId: Scalars['Int']['output'];
  customer?: Maybe<Customers>;
  customerId: Scalars['Int']['output'];
  discountAmount: Scalars['Float']['output'];
  id: Scalars['Int']['output'];
  order?: Maybe<Orders>;
  orderId: Scalars['Int']['output'];
  usedAt: Scalars['Timestamp']['output'];
}

export interface Coupons {
  applicableIds?: Maybe<Scalars['JSON']['output']>;
  applicableTo?: Maybe<CouponsApplicableTo>;
  code: Scalars['String']['output'];
  couponUsage?: Maybe<Array<Maybe<CouponUsage>>>;

  description?: Maybe<Scalars['String']['output']>;
  discountType: CouponsDiscountType;
  discountValue: Scalars['Float']['output'];
  endDate: Scalars['DateTime']['output'];
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Int']['output']>;
  maxDiscountAmount?: Maybe<Scalars['Float']['output']>;
  minPurchaseAmount?: Maybe<Scalars['Float']['output']>;
  name: Scalars['String']['output'];
  startDate: Scalars['DateTime']['output'];

  usageLimit?: Maybe<Scalars['Int']['output']>;
  usageLimitPerCustomer?: Maybe<Scalars['Int']['output']>;
  usedCount?: Maybe<Scalars['Int']['output']>;
}

export type CouponsApplicableTo =
  | 'all'
  | 'categories'
  | 'products';

export type CouponsDiscountType =
  | 'fixed_amount'
  | 'percentage';

export interface Customers {
  addressId?: Maybe<Scalars['Int']['output']>;
  couponUsage?: Maybe<Array<Maybe<CouponUsage>>>;

  customersAddresses?: Maybe<Array<Maybe<CustomersAddresses>>>;

  dni?: Maybe<Scalars['String']['output']>;
  email: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Int']['output']>;
  lastname: Scalars['String']['output'];
  name: Scalars['String']['output'];
  order?: Maybe<Orders>;
  password: Scalars['String']['output'];

  phone?: Maybe<Scalars['String']['output']>;
  photo?: Maybe<Scalars['String']['output']>;

  variantRatings?: Maybe<Array<Maybe<VariantRatings>>>;
}

export interface CustomersAddresses {

  alias: Scalars['String']['output'];

  apartment?: Maybe<Scalars['String']['output']>;

  customer?: Maybe<Customers>;
  department: Scalars['String']['output'];
  district: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  idCustomer: Scalars['Int']['output'];

  isDefault?: Maybe<Scalars['Int']['output']>;

  latitude?: Maybe<Scalars['Float']['output']>;

  longitude?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Orders>;
  province: Scalars['String']['output'];

  streetName: Scalars['String']['output'];

  streetNumber: Scalars['String']['output'];

}

export type OrderBy =
  | 'asc'
  | 'desc';

export interface OrderItems {

  discountAmount?: Maybe<Scalars['Float']['output']>;
  id: Scalars['Int']['output'];
  order?: Maybe<Orders>;
  orderId: Scalars['Int']['output'];

  productName: Scalars['String']['output'];
  productVariants?: Maybe<Array<Maybe<ProductVariants>>>;
  quantity: Scalars['Int']['output'];

  totalPrice: Scalars['Float']['output'];

  unitPrice: Scalars['Float']['output'];

  variantAttributes?: Maybe<Scalars['JSON']['output']>;

  variantId: Scalars['Int']['output'];

  variantSku: Scalars['String']['output'];
}

export interface OrderSummary {

  courierCompany?: Maybe<Scalars['String']['output']>;

  customerEmail?: Maybe<Scalars['String']['output']>;
  customerId: Scalars['Int']['output'];
  customerName?: Maybe<Scalars['String']['output']>;

  estimatedDelivery?: Maybe<Scalars['Date']['output']>;
  id: Scalars['Int']['output'];

  orderNumber: Scalars['String']['output'];
  paymentStatus: OrderSummaryPaymentStatus;
  status: OrderSummaryStatus;

  totalAmount: Scalars['Float']['output'];
  totalItems: Scalars['BigInt']['output'];
  totalQuantity?: Maybe<Scalars['Float']['output']>;

  trackingNumber?: Maybe<Scalars['String']['output']>;
}

export type OrderSummaryPaymentStatus =
  | 'failed'
  | 'paid'
  | 'pending'
  | 'refunded';

export type OrderSummaryStatus =
  | 'cancelled'
  | 'delivered'
  | 'pending'
  | 'processing'
  | 'refunded'
  | 'shipped';

export interface OrderTracking {

  courierCompany?: Maybe<Scalars['String']['output']>;

  currentLocation?: Maybe<Scalars['String']['output']>;
  deliveredAt?: Maybe<Scalars['Timestamp']['output']>;

  deliveredTo?: Maybe<Scalars['String']['output']>;

  deliveryNotes?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  order?: Maybe<Orders>;
  orderId: Scalars['Int']['output'];
  shippedAt?: Maybe<Scalars['Timestamp']['output']>;
  status: OrderTrackingStatus;

  trackingNumber?: Maybe<Scalars['String']['output']>;

}

export type OrderTrackingStatus =
  | 'delivered'
  | 'failed_delivery'
  | 'in_transit'
  | 'out_for_delivery'
  | 'preparing'
  | 'shipped';

export interface Orders {

  adminNotes?: Maybe<Scalars['String']['output']>;
  couponUsage?: Maybe<Array<Maybe<CouponUsage>>>;

  customer?: Maybe<Customers>;
  customerId: Scalars['Int']['output'];

  customerNotes?: Maybe<Scalars['String']['output']>;
  customersAddresses?: Maybe<Array<Maybe<CustomersAddresses>>>;

  discountAmount?: Maybe<Scalars['Float']['output']>;

  estimatedDelivery?: Maybe<Scalars['Date']['output']>;
  id: Scalars['Int']['output'];
  orderItems?: Maybe<Array<Maybe<OrderItems>>>;

  orderNumber: Scalars['String']['output'];
  orderTracking?: Maybe<Array<Maybe<OrderTracking>>>;

  paidAt?: Maybe<Scalars['Timestamp']['output']>;

  paymentMethod?: Maybe<Scalars['String']['output']>;
  paymentStatus: OrdersPaymentStatus;
  paymentTransactions?: Maybe<Array<Maybe<PaymentTransactions>>>;

  shippingAddressId: Scalars['Int']['output'];

  shippingCost?: Maybe<Scalars['Float']['output']>;

  shippingMethod?: Maybe<Scalars['String']['output']>;
  status: OrdersStatus;

  subtotal: Scalars['Float']['output'];

  taxAmount?: Maybe<Scalars['Float']['output']>;

  totalAmount: Scalars['Float']['output'];

}

export type OrdersPaymentStatus =
  | 'failed'
  | 'paid'
  | 'pending'
  | 'refunded';

export type OrdersStatus =
  | 'cancelled'
  | 'delivered'
  | 'pending'
  | 'processing'
  | 'refunded'
  | 'shipped';

export interface PaymentMethods {
  code: Scalars['String']['output'];

  description?: Maybe<Scalars['String']['output']>;
  displayOrder?: Maybe<Scalars['Int']['output']>;
  iconUrl?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Int']['output']>;
  maxAmount?: Maybe<Scalars['Float']['output']>;
  minAmount?: Maybe<Scalars['Float']['output']>;
  name: Scalars['String']['output'];
  paymentTransactions?: Maybe<Array<Maybe<PaymentTransactions>>>;
  processingFeeType?: Maybe<PaymentMethodsProcessingFeeType>;
  processingFeeValue?: Maybe<Scalars['Float']['output']>;
  requiresVerification?: Maybe<Scalars['Int']['output']>;
  settings?: Maybe<Scalars['JSON']['output']>;

}

export type PaymentMethodsProcessingFeeType =
  | 'fixed'
  | 'percentage';

export interface PaymentTransactions {
  amount: Scalars['Float']['output'];

  currency?: Maybe<Scalars['String']['output']>;
  expiresAt?: Maybe<Scalars['Timestamp']['output']>;
  gatewayResponse?: Maybe<Scalars['JSON']['output']>;
  id: Scalars['Int']['output'];
  netAmount: Scalars['Float']['output'];
  order?: Maybe<Orders>;
  orderId: Scalars['Int']['output'];
  paymentData?: Maybe<Scalars['JSON']['output']>;
  paymentMethod?: Maybe<PaymentMethods>;
  paymentMethodId: Scalars['Int']['output'];
  processedAt?: Maybe<Scalars['Timestamp']['output']>;
  processingFee?: Maybe<Scalars['Float']['output']>;
  referenceNumber?: Maybe<Scalars['String']['output']>;
  status?: Maybe<PaymentTransactionsStatus>;
  transactionId?: Maybe<Scalars['String']['output']>;

}

export type PaymentTransactionsStatus =
  | 'cancelled'
  | 'completed'
  | 'failed'
  | 'pending'
  | 'processing'
  | 'refunded';

export interface Permissions {

  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];

}

export interface ProductCategories {
  categories?: Maybe<Array<Maybe<Categories>>>;
  categoryId: Scalars['Int']['output'];
  product?: Maybe<Products>;
  productId: Scalars['Int']['output'];
}

export interface ProductRatingSummary {
  averageRating?: Maybe<Scalars['Float']['output']>;
  fiveStar?: Maybe<Scalars['Float']['output']>;
  fourStar?: Maybe<Scalars['Float']['output']>;
  oneStar?: Maybe<Scalars['Float']['output']>;
  productId: Scalars['Int']['output'];
  threeStar?: Maybe<Scalars['Float']['output']>;
  totalRatings: Scalars['BigInt']['output'];
  twoStar?: Maybe<Scalars['Float']['output']>;
  verifiedPurchases?: Maybe<Scalars['Float']['output']>;
}

export interface ProductVariants {

  id: Scalars['Int']['output'];
  orderItems?: Maybe<Array<Maybe<OrderItems>>>;
  price: Scalars['Float']['output'];
  product?: Maybe<Products>;
  productId: Scalars['Int']['output'];
  promotionVariants?: Maybe<Array<Maybe<PromotionVariants>>>;
  sku: Scalars['String']['output'];
  stock: Scalars['Int']['output'];

  variantAttributeOptions?: Maybe<Array<Maybe<VariantAttributeOptions>>>;
  variantImages?: Maybe<Array<Maybe<VariantImages>>>;
  variantRatings?: Maybe<Array<Maybe<VariantRatings>>>;
}

export interface Products {
  basePrice?: Maybe<Scalars['Float']['output']>;
  brand?: Maybe<Brands>;
  brandId?: Maybe<Scalars['Int']['output']>;

  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  productCategories?: Maybe<Array<Maybe<ProductCategories>>>;
  productVariants?: Maybe<Array<Maybe<ProductVariants>>>;

}

export interface PromotionVariants {

  productVariants?: Maybe<Array<Maybe<ProductVariants>>>;
  promotion?: Maybe<Promotions>;
  promotionId: Scalars['Int']['output'];
  promotionPrice?: Maybe<Scalars['Float']['output']>;
  stockLimit: Scalars['Int']['output'];
  variantId: Scalars['Int']['output'];
}

export interface Promotions {

  description?: Maybe<Scalars['String']['output']>;
  discountType: PromotionsDiscountType;
  discountValue: Scalars['Float']['output'];
  endDate: Scalars['DateTime']['output'];
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Int']['output']>;
  minPurchaseAmount?: Maybe<Scalars['Float']['output']>;
  name: Scalars['String']['output'];
  promotionVariants?: Maybe<Array<Maybe<PromotionVariants>>>;
  startDate: Scalars['DateTime']['output'];

}

export type PromotionsDiscountType =
  | 'fixed_amount'
  | 'percentage';

export interface RatingImages {

  id: Scalars['Int']['output'];
  imageUrl: Scalars['String']['output'];
  ratingId: Scalars['Int']['output'];
  variantRatings?: Maybe<Array<Maybe<VariantRatings>>>;
}

export interface Roles {

  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  rolesSections?: Maybe<Array<Maybe<RolesSections>>>;

  users?: Maybe<Array<Maybe<Users>>>;
}

export interface RolesSections {
  id: Scalars['Int']['output'];
  idRol?: Maybe<Scalars['Int']['output']>;
  idSection?: Maybe<Scalars['Int']['output']>;
  role?: Maybe<Roles>;
  sections?: Maybe<Array<Maybe<Sections>>>;
}

export interface Sections {
  displayOrder?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  image?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  rolesSections?: Maybe<Array<Maybe<RolesSections>>>;
  url?: Maybe<Scalars['String']['output']>;
}

export interface Services {

  description?: Maybe<Scalars['String']['output']>;
  displayOrder?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  imageUrl?: Maybe<Scalars['String']['output']>;
  servicesImages?: Maybe<Array<Maybe<ServicesImages>>>;
  slug?: Maybe<Scalars['String']['output']>;
  subtitle?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];

}

export interface ServicesImages {

  description?: Maybe<Scalars['String']['output']>;
  displayOrder?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  idService?: Maybe<Scalars['Int']['output']>;
  imageUrl?: Maybe<Scalars['String']['output']>;
  services?: Maybe<Array<Maybe<Services>>>;
  subtitle?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;

}

export interface ShippingMethods {
  baseCost: Scalars['Float']['output'];

  description?: Maybe<Scalars['String']['output']>;
  displayOrder?: Maybe<Scalars['Int']['output']>;
  estimatedDaysMax?: Maybe<Scalars['Int']['output']>;
  estimatedDaysMin?: Maybe<Scalars['Int']['output']>;
  freeShippingThreshold?: Maybe<Scalars['Float']['output']>;
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Int']['output']>;
  name: Scalars['String']['output'];
  shippingZoneMethods?: Maybe<Array<Maybe<ShippingZoneMethods>>>;

}

export interface ShippingZoneMethods {
  cost: Scalars['Float']['output'];

  estimatedDaysMax?: Maybe<Scalars['Int']['output']>;
  estimatedDaysMin?: Maybe<Scalars['Int']['output']>;
  freeShippingThreshold?: Maybe<Scalars['Float']['output']>;
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Int']['output']>;
  shippingMethod?: Maybe<ShippingMethods>;
  shippingMethodId: Scalars['Int']['output'];
  shippingZone?: Maybe<ShippingZones>;
  shippingZoneId: Scalars['Int']['output'];

}

export interface ShippingZones {

  districts: Scalars['JSON']['output'];
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Int']['output']>;
  name: Scalars['String']['output'];
  shippingZoneMethods?: Maybe<Array<Maybe<ShippingZoneMethods>>>;

}

export interface Users {

  email: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Int']['output']>;
  lastname: Scalars['String']['output'];
  password: Scalars['String']['output'];
  photo?: Maybe<Scalars['String']['output']>;
  role?: Maybe<Roles>;
  roleId: Scalars['Int']['output'];

  username: Scalars['String']['output'];
}

export interface VariantAttributeOptions {
  attributeOption?: Maybe<AttributeOptions>;
  attributeOptionId: Scalars['Int']['output'];
  productVariants?: Maybe<Array<Maybe<ProductVariants>>>;
  variantId: Scalars['Int']['output'];
}

export interface VariantImages {

  altText?: Maybe<Scalars['String']['output']>;

  displayOrder?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  imageType: VariantImagesImageType;

  imageUrlNormal: Scalars['String']['output'];

  imageUrlThumb: Scalars['String']['output'];

  imageUrlZoom: Scalars['String']['output'];

  isPrimary?: Maybe<Scalars['Int']['output']>;
  productVariants?: Maybe<Array<Maybe<ProductVariants>>>;

  variantId: Scalars['Int']['output'];
}

export type VariantImagesImageType =
  | 'back'
  | 'bottom'
  | 'detail'
  | 'front'
  | 'left'
  | 'lifestyle'
  | 'packaging'
  | 'right'
  | 'top';

export interface VariantRatingSummary {
  averageRating?: Maybe<Scalars['Float']['output']>;
  fiveStar?: Maybe<Scalars['Float']['output']>;
  fourStar?: Maybe<Scalars['Float']['output']>;
  oneStar?: Maybe<Scalars['Float']['output']>;
  threeStar?: Maybe<Scalars['Float']['output']>;
  totalRatings: Scalars['BigInt']['output'];
  twoStar?: Maybe<Scalars['Float']['output']>;
  variantId: Scalars['Int']['output'];
  verifiedPurchases?: Maybe<Scalars['Float']['output']>;
}

export interface VariantRatings {

  customer?: Maybe<Customers>;
  customerId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  productVariants?: Maybe<Array<Maybe<ProductVariants>>>;
  rating: Scalars['Int']['output'];
  ratingImages?: Maybe<Array<Maybe<RatingImages>>>;
  review?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;

  variantId: Scalars['Int']['output'];
  verifiedPurchase: Scalars['Int']['output'];
}



üìÅ ARCHIVO: src/types/domain/index.ts
------------------------------------------------------------------------------------
export * from './domain'



üìÅ ARCHIVO: src/app/order/[orderNumber]/confirmation/BackButton.tsx
------------------------------------------------------------------------------------
// üìÑ app/order/[orderNumber]/confirmation/BackButton.tsx
'use client'

import { ArrowLeft } from 'lucide-react'
import { useRouter } from 'next/navigation'

export default function BackButton() {
  const router = useRouter()

  return (
    <button
      onClick={() => { router.back() }}
      className="mb-4 flex items-center text-blue-600 hover:text-blue-700"
    >
      <ArrowLeft className="mr-2 h-4 w-4" />
      Volver
    </button>
  )
}



üìÅ ARCHIVO: src/app/order/[orderNumber]/confirmation/ActionButtons.tsx
------------------------------------------------------------------------------------
'use client'

import { ArrowLeft, Download, Package, Share2 } from 'lucide-react'
import { useRouter } from 'next/navigation'

interface ActionButtonsProps {
  orderNumber: string
}

export default function ActionButtons({ orderNumber }: ActionButtonsProps) {
  const router = useRouter()

  const handleShare = async () => {
    if (navigator.share) {
      try {
        await navigator.share({
          title: `Pedido ${orderNumber}`,
          text: `¬°Mi pedido ha sido confirmado! N√∫mero: ${orderNumber}`,
          url: window.location.href
        })
      } catch (err) {
        console.log('Error sharing:', err)
      }
    } else {
      // Fallback: copiar al portapapeles
      navigator.clipboard.writeText(window.location.href)
      alert('Enlace copiado al portapapeles')
    }
  }

  return (
    <div className="mt-8 flex flex-col justify-center gap-4 sm:flex-row">
      <button
        onClick={() => { router.push('/') }}
        className="flex items-center justify-center rounded-lg border border-gray-300 px-6 py-3 text-gray-700 hover:bg-gray-50"
      >
        <ArrowLeft className="mr-2 h-4 w-4" />
        Seguir Comprando
      </button>

      <button
        onClick={() => { router.push(`/order/${orderNumber}/track`) }}
        className="flex items-center justify-center rounded-lg bg-blue-600 px-6 py-3 text-white hover:bg-blue-700"
      >
        <Package className="mr-2 h-4 w-4" />
        Rastrear Pedido
      </button>

      <button
        onClick={handleShare}
        className="flex items-center justify-center rounded-lg border border-gray-300 px-6 py-3 text-gray-700 hover:bg-gray-50"
      >
        <Share2 className="mr-2 h-4 w-4" />
        Compartir
      </button>

      <button
        onClick={() => { window.print() }}
        className="flex items-center justify-center rounded-lg border border-gray-300 px-6 py-3 text-gray-700 hover:bg-gray-50"
      >
        <Download className="mr-2 h-4 w-4" />
        Imprimir
      </button>
    </div>
  )
}



üìÅ ARCHIVO: src/app/order/[orderNumber]/confirmation/page.tsx
------------------------------------------------------------------------------------
// üìÑ app/order/[orderNumber]/confirmation/page.tsx
import { Calendar, CheckCircle, Package, Truck } from 'lucide-react'
import { notFound } from 'next/navigation'

// Models - importar directamente los modelos
import customerModel from '@/backend/customer'
import customerAddressModel from '@/backend/customer-address'
import orderModel from '@/backend/order'
import orderItemsModel from '@/backend/order-item'

// Usar tipos del dominio
import {
  type Customers,
  type CustomersAddresses,
  type OrderItems,
  type Orders
} from '@/types/domain'

// Components
import ActionButtons from './ActionButtons'

interface OrderConfirmationData {
  order: Orders
  customer: Customers
  shippingAddress: CustomersAddresses
  orderItems: OrderItems[]
}

async function getOrderConfirmationData(
  orderNumber: string
): Promise<OrderConfirmationData> {
  try {
    // 1. Obtener la orden por n√∫mero
    const order = await orderModel.getOrderByNumber(orderNumber)
    if (!order) {
      notFound()
    }

    // 2. Obtener items de la orden
    const orderItems = await orderItemsModel.getOrderItemsByOrderId(order.id)
    if (!orderItems) {
      throw new Error('Items de orden no encontrados')
    }

    // 3. Obtener cliente
    const customer = await customerModel.getCustomer(order.customerId)
    if (!customer) {
      throw new Error('Cliente no encontrado')
    }

    // 4. Obtener direcci√≥n de env√≠o
    const shippingAddress = await customerAddressModel.getAddress(
      order.shippingAddressId
    )
    if (!shippingAddress) {
      throw new Error('Direcci√≥n de env√≠o no encontrada')
    }

    return {
      order,
      customer,
      shippingAddress,
      orderItems
    }
  } catch (error) {
    console.error('Error fetching order confirmation data:', error)
    notFound()
  }
}

export default async function OrderConfirmationPage({
  params
}: {
  params: { orderNumber: string }
}) {
  const { orderNumber } = params

  const data = await getOrderConfirmationData(orderNumber)

  const { order, customer, shippingAddress, orderItems } = data
  const estimatedDate = order.estimatedDelivery
    ? new Date(order.estimatedDelivery)
    : null

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="mx-auto max-w-4xl px-4 py-8">
        {/* Header Success */}
        <div className="mb-8 text-center">
          <div className="mb-4 inline-flex h-16 w-16 items-center justify-center rounded-full bg-green-100">
            <CheckCircle className="h-8 w-8 text-green-600" />
          </div>
          <h1 className="mb-2 text-3xl font-bold text-gray-900">
            ¬°Pedido Confirmado!
          </h1>
          <p className="text-gray-600">
            Tu pedido #{order.orderNumber} ha sido confirmado y ser√° procesado
            pronto.
          </p>
        </div>

        {/* Order Status Card */}
        <div className="mb-6 rounded-lg border bg-white p-6 shadow-sm">
          <div className="grid grid-cols-1 gap-6 md:grid-cols-3">
            <div className="text-center">
              <div className="mb-3 inline-flex h-12 w-12 items-center justify-center rounded-full bg-green-100">
                <CheckCircle className="h-6 w-6 text-green-600" />
              </div>
              <h3 className="font-semibold text-gray-900">Pago Confirmado</h3>
              <p className="text-sm text-gray-600">
                S/ {order.totalAmount.toFixed(2)}
              </p>
            </div>

            <div className="text-center">
              <div className="mb-3 inline-flex h-12 w-12 items-center justify-center rounded-full bg-blue-100">
                <Package className="h-6 w-6 text-blue-600" />
              </div>
              <h3 className="font-semibold text-gray-900">Procesando</h3>
              <p className="text-sm capitalize text-gray-600">{order.status}</p>
            </div>

            <div className="text-center">
              <div className="mb-3 inline-flex h-12 w-12 items-center justify-center rounded-full bg-orange-100">
                <Calendar className="h-6 w-6 text-orange-600" />
              </div>
              <h3 className="font-semibold text-gray-900">Entrega Estimada</h3>
              <p className="text-sm text-gray-600">
                {estimatedDate
                  ? estimatedDate.toLocaleDateString('es-PE', {
                      weekday: 'long',
                      year: 'numeric',
                      month: 'long',
                      day: 'numeric'
                    })
                  : 'Por determinar'}
              </p>
            </div>
          </div>
        </div>

        <div className="grid grid-cols-1 gap-6 lg:grid-cols-2">
          {/* Order Details */}
          <div className="space-y-6">
            {/* Order Info */}
            <div className="rounded-lg border bg-white p-6 shadow-sm">
              <h3 className="mb-4 text-lg font-semibold text-gray-900">
                Detalles del Pedido
              </h3>

              <div className="space-y-3">
                <div className="flex justify-between">
                  <span className="text-gray-600">N√∫mero de pedido:</span>
                  <span className="font-medium">{order.orderNumber}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-600">Fecha del pedido:</span>
                  <span className="font-medium">
                    {new Date(order.createdAt).toLocaleDateString('es-PE')}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-600">Estado:</span>
                  <span className="font-medium capitalize">{order.status}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-600">Estado de pago:</span>
                  <span className="font-medium capitalize text-green-600">
                    {order.paymentStatus}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-600">Total:</span>
                  <span className="text-lg font-bold">
                    S/ {order.totalAmount.toFixed(2)}
                  </span>
                </div>
              </div>
            </div>

            {/* Customer Info */}
            <div className="rounded-lg border bg-white p-6 shadow-sm">
              <h3 className="mb-4 text-lg font-semibold text-gray-900">
                Informaci√≥n del Cliente
              </h3>

              <div className="space-y-2">
                <p className="font-medium">
                  {customer.name || ''} {customer.lastname}
                </p>
                <p className="text-gray-600">{customer.email}</p>
              </div>
            </div>

            {/* Shipping Address */}
            <div className="rounded-lg border bg-white p-6 shadow-sm">
              <h3 className="mb-4 flex items-center text-lg font-semibold text-gray-900">
                <Truck className="mr-2 h-5 w-5" />
                Direcci√≥n de Env√≠o
              </h3>

              <div className="space-y-1">
                <p className="font-medium">{shippingAddress.alias}</p>
                <p className="text-gray-700">
                  {shippingAddress.streetName} {shippingAddress.streetNumber}
                  {shippingAddress.apartment &&
                    `, ${shippingAddress.apartment}`}
                </p>
                <p className="text-gray-700">
                  {shippingAddress.district}, {shippingAddress.province}
                </p>
                <p className="text-gray-700">{shippingAddress.department}</p>
              </div>
            </div>
          </div>

          {/* Order Items */}
          <div className="rounded-lg border bg-white p-6 shadow-sm">
            <h3 className="mb-4 text-lg font-semibold text-gray-900">
              Productos Pedidos
            </h3>

            <div className="space-y-4">
              {orderItems.map((item) => (
                <div
                  key={item.id}
                  className="flex items-start justify-between border-b pb-4 last:border-b-0"
                >
                  <div className="flex-1">
                    <p className="font-medium text-gray-900">
                      {item.productName}
                    </p>
                    <p className="text-sm text-gray-600">
                      Cantidad: {item.quantity}
                    </p>
                    <p className="text-sm text-gray-600">
                      Precio unitario: S/ {item.unitPrice.toFixed(2)}
                    </p>
                  </div>
                  <div className="text-right">
                    <p className="font-medium">
                      S/ {item.totalPrice.toFixed(2)}
                    </p>
                    {item.discountAmount && item.discountAmount > 0 && (
                      <p className="text-xs text-green-600">
                        -S/ {item.discountAmount.toFixed(2)}
                      </p>
                    )}
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>

        {/* Action Buttons - Client Component */}
        <ActionButtons orderNumber={order.orderNumber} />

        {/* Help Section */}
        <div className="mt-8 text-center">
          <div className="rounded-lg border border-blue-200 bg-blue-50 p-4">
            <h4 className="mb-2 font-medium text-blue-800">
              ¬øNecesitas ayuda?
            </h4>
            <p className="mb-3 text-sm text-blue-700">
              Si tienes alguna pregunta sobre tu pedido, no dudes en
              contactarnos.
            </p>
            <div className="flex flex-col justify-center gap-2 sm:flex-row">
              <a
                href="mailto:soporte@tutienda.com"
                className="text-sm font-medium text-blue-600 hover:text-blue-700"
              >
                soporte@tutienda.com
              </a>
              <span className="hidden text-blue-600 sm:inline">‚Ä¢</span>
              <a
                href="tel:+51999999999"
                className="text-sm font-medium text-blue-600 hover:text-blue-700"
              >
                +51 999 999 999
              </a>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/app/payment/[transactionId]/page.tsx
------------------------------------------------------------------------------------
// üìÑ app/payment/[transactionId]/page.tsx (SERVER COMPONENT)
import { PaymentPage as PaymentPageClient } from '@/components/payment/PaymentPage'
import { type Metadata } from 'next'
export const metadata: Metadata = {
  title: 'Pago Seguro',
  description: 'Completa tu pago'
}

export default function PaymentPage({
  params
}: {
  params: { transactionId: string }
}) {
  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header del servidor */}
      <header className="bg-white shadow-sm">
        <div className="mx-auto max-w-6xl px-4 py-4">
          <h1 className="text-2xl font-bold text-gray-900">Pago Seguro üîí</h1>
        </div>
      </header>

      {/* Client Component con toda la l√≥gica */}
      <PaymentPageClient transactionId={params.transactionId} />
    </div>
  )
}



üìÅ ARCHIVO: src/app/checkout/page.tsx
------------------------------------------------------------------------------------
// üìÑ app/checkout/page.tsx
import { getServerSession } from 'next-auth'
import { redirect } from 'next/navigation'

// Models
import customerModel from '@/backend/customer'
import customerAddressModel from '@/backend/customer-address'
import paymentMethodModel from '@/backend/payment-method'

// Components
import CheckoutClient from '@/components/checkout/CheckoutClient'

// Types
import { authOptions } from '@/lib/auth'
import { type CheckoutUser } from '@/types/checkout'

export default async function CheckoutPage() {
  // 1. Verificar autenticaci√≥n
  const session = await getServerSession(authOptions)

  if (!session?.user?.email) {
    redirect('/auth/login?redirect=/checkout')
  }

  // 2. Obtener datos del usuario
  const customer = await customerModel.getCustomerByEmail(session.user.email)

  if (!customer) {
    redirect('/auth/login?redirect=/checkout')
  }

  // 3. Obtener direcciones del cliente
  const addresses = await customerAddressModel.getAddressByCustomer(customer.id)

  // Si no tiene direcciones, redirigir a crear una
  if (!addresses || addresses.length === 0) {
    redirect('/profile/addresses/new?redirect=/checkout')
  }

  // 4. Obtener m√©todos de pago activos
  const paymentMethods = await paymentMethodModel.getPaymentMethods()

  // 5. Preparar datos del usuario para el cliente
  const checkoutUser: CheckoutUser = {
    id: customer.id,
    name: customer.name || '',
    lastname: customer.lastname,
    email: customer.email,
    phone: customer.phone,
    addresses,
    defaultAddressId: addresses.find((addr) => addr.isDefault === 1)?.id
  }

  return (
    <main className="min-h-screen bg-gray-50">
      <div className="mx-auto max-w-7xl px-4 py-8 sm:px-6 lg:px-8">
        <div className="mb-8">
          <h1 className="text-3xl font-bold text-gray-900">Checkout</h1>
          <p className="mt-2 text-gray-600">
            Completa tu compra de forma segura
          </p>
        </div>

        <CheckoutClient
          user={checkoutUser}
          paymentMethods={paymentMethods || []}
        />
      </div>
    </main>
  )
}



üìÅ ARCHIVO: src/app/search/page.tsx
------------------------------------------------------------------------------------
import categoryModel from '@/backend/category'
import Header from '@/components/layout/Header'
import Layout from '@/components/layout/Layout'
import { LayoutContent } from '@/components/layout/LayoutContent'
import SearchFilters from '@/components/search/SearchFilters'
import SearchResults from '@/components/search/SearchResults'
import StickyFilters from '@/components/search/StickyFilters'
import Navigation from '@/components/ui/Navigation'
import { getFilters } from '@/helpers/search.helpers'
import SearchService from '@/services/search'
import { type SearchParams } from '@/shared'
import { type Metadata } from 'next'

export const metadata: Metadata = {
  title: 'B√∫squeda de Productos | AJK E-commerce',
  description: 'Busca y filtra productos en nuestra tienda online'
}

interface SearchPageProps {
  searchParams: SearchParams
}

export default async function SearchPage({ searchParams }: SearchPageProps) {
  // Esperar a searchParams antes de usar sus propiedades
  const params = await searchParams

  const filters = getFilters(params)

  // Obtener resultados de b√∫squeda directamente del modelo
  const {
    page,
    products,
    totalPages,
    filters: availableFilters
  } = await SearchService.getSearchParams(filters)

  const categories = await categoryModel.getCategories()

  return (
    <Layout>
      <Header navigationType="mini">
        <Navigation type="mini" categories={categories || []} />
      </Header>
      <LayoutContent>
        <div className="flex flex-col gap-8 lg:flex-row">
          {/* Filtros laterales */}
          <div className="lg:min-w-56 lg:max-w-56">
            <StickyFilters>
              <SearchFilters
                availableFilters={availableFilters}
                currentFilters={filters}
              />
            </StickyFilters>
          </div>

          {/* Resultados */}
          <div className="lg:100% w-full">
            <SearchResults
              products={products}
              totalPages={totalPages}
              currentPage={page}
              currentFilters={filters}
              defaultView="grid"
            />
          </div>
        </div>
      </LayoutContent>
    </Layout>
  )
}



üìÅ ARCHIVO: src/app/layout.tsx
------------------------------------------------------------------------------------
import { Providers } from '@/providers/Providers'
import type { Metadata } from 'next'
import { Open_Sans, Roboto } from 'next/font/google'
import { type JSX } from 'react'
import './globals.css'

const openSans = Open_Sans({
  variable: '--font-open-sans',
  subsets: ['latin']
})

const roboto = Roboto({
  variable: '--font-roboto',
  subsets: ['latin']
})

export const metadata: Metadata = {
  title: 'TechStore - Tu tienda de tecnolog√≠a y zapatillas',
  description:
    'Encuentra los mejores productos de tecnolog√≠a y zapatillas en TechStore'
}

export default function RootLayout({
  children
}: Readonly<{
  children: React.ReactNode
}>): JSX.Element {
  return (
    <html lang="es">
      <body className={`${openSans.variable} ${roboto.variable} antialiased`}>
        <Providers>{children}</Providers>
      </body>
    </html>
  )
}



üìÅ ARCHIVO: src/app/cart/page.tsx
------------------------------------------------------------------------------------
import categoryModel from '@/backend/category'
import { CartPageInteractive } from '@/components/cart/CartPageInteractive'
import Header from '@/components/layout/Header'
import Layout from '@/components/layout/Layout'
import { LayoutContent } from '@/components/layout/LayoutContent'
import Navigation from '@/components/ui/Navigation'
import { type Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Carrito de Compras | TechStore',
  description: 'Revisa y gestiona los productos en tu carrito de compras'
}

const categories = await categoryModel.getCategories()

export default function CartPage() {
  return (
    <Layout>
      <Header navigationType="mini">
        <Navigation type="mini" categories={categories || []} />
      </Header>
      <LayoutContent>
        <CartPageInteractive />
      </LayoutContent>
    </Layout>
  )
}



üìÅ ARCHIVO: src/app/api/payment/[transactionId]/fail/route.ts
------------------------------------------------------------------------------------
// üìÑ app/api/payment/[transactionId]/fail/route.ts
import orderModel from '@/backend/order'
import paymentTransactionModel from '@/backend/payment-transaction'
import { type NextRequest, NextResponse } from 'next/server'

export async function POST(
  request: NextRequest,
  { params }: { params: { transactionId: string } }
) {
  try {
    const transactionId = parseInt(params.transactionId)
    const { gatewayResponse } = await request.json()

    if (isNaN(transactionId)) {
      return NextResponse.json(
        { error: 'ID de transacci√≥n inv√°lido' },
        { status: 400 }
      )
    }

    // 1. Obtener la transacci√≥n
    const transaction =
      await paymentTransactionModel.getTransactionById(transactionId)
    if (!transaction) {
      return NextResponse.json(
        { error: 'Transacci√≥n no encontrada' },
        { status: 404 }
      )
    }

    // 2. Verificar que la transacci√≥n est√© pendiente
    if (
      transaction.status !== 'pending' &&
      transaction.status !== 'processing'
    ) {
      return NextResponse.json(
        { error: 'La transacci√≥n ya ha sido procesada' },
        { status: 400 }
      )
    }

    // 3. Marcar transacci√≥n como fallida
    const updatedTransaction = await paymentTransactionModel.markAsFailed(
      transactionId,
      gatewayResponse
    )

    if (!updatedTransaction) {
      throw new Error('Error al actualizar la transacci√≥n')
    }

    // 4. Actualizar estado de pago de la orden
    const updatedOrder = await orderModel.updatePaymentStatus(
      transaction.orderId,
      'failed'
    )

    if (!updatedOrder) {
      throw new Error('Error al actualizar el estado de la orden')
    }

    return NextResponse.json({
      success: true,
      transaction: updatedTransaction,
      order: updatedOrder,
      message: 'Pago rechazado'
    })
  } catch (error) {
    console.error('Error failing payment:', error)
    return NextResponse.json(
      { error: 'Error al procesar el rechazo del pago' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/payment/[transactionId]/complete/route.ts
------------------------------------------------------------------------------------
// üìÑ app/api/payment/[transactionId]/complete/route.ts
import orderModel from '@/backend/order'
import paymentTransactionModel from '@/backend/payment-transaction'
import { type NextRequest, NextResponse } from 'next/server'

export async function POST(
  request: NextRequest,
  { params }: { params: { transactionId: string } }
) {
  try {
    const transactionId = parseInt(params.transactionId)
    const { gatewayResponse } = await request.json()

    if (isNaN(transactionId)) {
      return NextResponse.json(
        { error: 'ID de transacci√≥n inv√°lido' },
        { status: 400 }
      )
    }

    // 1. Obtener la transacci√≥n
    const transaction =
      await paymentTransactionModel.getTransactionById(transactionId)
    if (!transaction) {
      return NextResponse.json(
        { error: 'Transacci√≥n no encontrada' },
        { status: 404 }
      )
    }

    // 2. Verificar que la transacci√≥n est√© pendiente
    if (transaction.status !== 'pending') {
      return NextResponse.json(
        { error: 'La transacci√≥n ya ha sido procesada' },
        { status: 400 }
      )
    }

    // 3. Generar ID de transacci√≥n √∫nico
    const externalTransactionId = `TXN_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    // 4. Marcar transacci√≥n como completada
    const updatedTransaction = await paymentTransactionModel.markAsCompleted(
      transactionId,
      externalTransactionId,
      gatewayResponse
    )

    if (!updatedTransaction) {
      throw new Error('Error al actualizar la transacci√≥n')
    }

    // 5. Actualizar estado de la orden
    const updatedOrder = await orderModel.updatePaymentStatus(
      transaction.orderId,
      'paid',
      new Date()
    )

    if (!updatedOrder) {
      throw new Error('Error al actualizar el estado de la orden')
    }

    // 6. Actualizar estado general de la orden a 'processing'
    await orderModel.updateOrderStatus(
      transaction.orderId,
      'processing',
      'Pago confirmado - Procesando pedido'
    )

    return NextResponse.json({
      success: true,
      transaction: updatedTransaction,
      order: updatedOrder,
      message: 'Pago completado exitosamente'
    })
  } catch (error) {
    console.error('Error completing payment:', error)
    return NextResponse.json(
      { error: 'Error al procesar el pago' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/payment/[transactionId]/route.ts
------------------------------------------------------------------------------------
import { type NextRequest, NextResponse } from 'next/server'

// Models
import customerModel from '@/backend/customer'
import customerAddressModel from '@/backend/customer-address'
import orderModel from '@/backend/order'
import orderItemsModel from '@/backend/order-item'
import paymentMethodModel from '@/backend/payment-method'
import paymentTransactionModel from '@/backend/payment-transaction'

// Usar tipos del dominio
import {
  type Customers,
  type CustomersAddresses,
  type OrderItems,
  type Orders,
  type PaymentMethods,
  type PaymentTransactions
} from '@/types/domain'

interface PaymentPageData {
  transaction: PaymentTransactions
  order: Orders
  orderItems: OrderItems[]
  customer: Customers
  shippingAddress: CustomersAddresses
  paymentMethod: PaymentMethods
}

export async function GET(
  request: NextRequest,
  { params }: { params: { transactionId: string } }
) {
  try {
    const transactionId = parseInt(params.transactionId)

    if (isNaN(transactionId)) {
      return NextResponse.json(
        { error: 'ID de transacci√≥n inv√°lido' },
        { status: 400 }
      )
    }

    // 1. Obtener la transacci√≥n
    const transaction =
      await paymentTransactionModel.getTransactionById(transactionId)
    if (!transaction) {
      return NextResponse.json(
        { error: 'Transacci√≥n no encontrada' },
        { status: 404 }
      )
    }

    // 2. Obtener la orden
    const order = await orderModel.getOrderById(transaction.orderId)
    if (!order) {
      return NextResponse.json(
        { error: 'Orden no encontrada' },
        { status: 404 }
      )
    }

    // 3. Obtener items de la orden
    const orderItems = await orderItemsModel.getOrderItemsByOrderId(order.id)
    if (!orderItems) {
      return NextResponse.json(
        { error: 'Items de orden no encontrados' },
        { status: 404 }
      )
    }

    // 4. Obtener cliente
    const customer = await customerModel.getCustomer(order.customerId)
    if (!customer) {
      return NextResponse.json(
        { error: 'Cliente no encontrado' },
        { status: 404 }
      )
    }

    // 5. Obtener direcci√≥n de env√≠o
    const shippingAddress = await customerAddressModel.getAddress(
      order.shippingAddressId
    )
    if (!shippingAddress) {
      return NextResponse.json(
        { error: 'Direcci√≥n de env√≠o no encontrada' },
        { status: 404 }
      )
    }

    // 6. Obtener m√©todo de pago
    const paymentMethod = await paymentMethodModel.getPaymentMethodById(
      transaction.paymentMethodId
    )
    if (!paymentMethod) {
      return NextResponse.json(
        { error: 'M√©todo de pago no encontrado' },
        { status: 404 }
      )
    }

    // 7. Construir respuesta usando directamente los objetos del dominio
    const paymentData: PaymentPageData = {
      transaction,
      order,
      orderItems,
      customer,
      shippingAddress,
      paymentMethod
    }

    return NextResponse.json(paymentData)
  } catch (error) {
    console.error('Error fetching payment data:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/ratings/product/[id]/route.ts
------------------------------------------------------------------------------------
import { type NextRequest, NextResponse } from 'next/server'

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const resolvedParams = await params

  try {
    const productId = parseInt(resolvedParams.id)

    if (isNaN(productId)) {
      return NextResponse.json(
        { error: 'ID de producto inv√°lido' },
        { status: 400 }
      )
    }

    // Obtener par√°metros de consulta
    const url = new URL(request.url)
    const page = parseInt(url.searchParams.get('page') || '1')

    // Para fines de demostraci√≥n, generamos datos simulados
    const mockRatings = {
      ratings: [
        {
          id: 1,
          variantId: 1,
          customerId: 1,
          customerName: 'Juan P√©rez',
          customerPhoto: null,
          rating: 5,
          review:
            'Excelente producto, muy satisfecho con la compra. La calidad es incre√≠ble y el precio es muy bueno.',
          title: 'Compra perfecta',
          verifiedPurchase: true,
          createdAt: new Date(Date.now() - 86400000 * 2), // 2 d√≠as atr√°s
          images: [
            {
              id: 1,
              ratingId: 1,
              imageUrl: '/no-image.webp'
            },
            {
              id: 2,
              ratingId: 1,
              imageUrl: '/no-image.webp'
            }
          ]
        },
        {
          id: 2,
          variantId: 2,
          customerId: 2,
          customerName: 'Mar√≠a Garc√≠a',
          customerPhoto: null,
          rating: 4,
          review:
            'Buen producto, pero tard√≥ un poco en llegar. La calidad es buena.',
          title: 'Buena compra',
          verifiedPurchase: true,
          createdAt: new Date(Date.now() - 86400000 * 5), // 5 d√≠as atr√°s
          images: []
        },
        {
          id: 3,
          variantId: 3,
          customerId: 3,
          customerName: 'Carlos Rodr√≠guez',
          customerPhoto: null,
          rating: 5,
          review:
            'Incre√≠ble producto, super√≥ mis expectativas. Lo recomiendo totalmente.',
          title: 'Excelente calidad',
          verifiedPurchase: false,
          createdAt: new Date(Date.now() - 86400000 * 10), // 10 d√≠as atr√°s
          images: [
            {
              id: 3,
              ratingId: 3,
              imageUrl: '/no-image.webp'
            }
          ]
        },
        {
          id: 4,
          variantId: 4,
          customerId: 4,
          customerName: 'Ana Mart√≠nez',
          customerPhoto: null,
          rating: 3,
          review: 'Producto aceptable, pero esperaba m√°s por el precio pagado.',
          title: 'Cumple su funci√≥n',
          verifiedPurchase: true,
          createdAt: new Date(Date.now() - 86400000 * 15), // 15 d√≠as atr√°s
          images: []
        },
        {
          id: 5,
          variantId: 5,
          customerId: 5,
          customerName: 'Pedro L√≥pez',
          customerPhoto: null,
          rating: 4,
          review: 'Buen producto, relaci√≥n calidad-precio adecuada.',
          title: 'Recomendable',
          verifiedPurchase: true,
          createdAt: new Date(Date.now() - 86400000 * 20), // 20 d√≠as atr√°s
          images: []
        }
      ],
      summary: {
        productId,
        totalRatings: 15,
        averageRating: 4.2,
        fiveStar: 8,
        fourStar: 4,
        threeStar: 2,
        twoStar: 1,
        oneStar: 0,
        verifiedPurchases: 12
      },
      totalCount: 15,
      page,
      totalPages: 3
    }

    return NextResponse.json(mockRatings)
  } catch (error) {
    console.error('Error al obtener valoraciones de producto:', error)
    return NextResponse.json(
      { error: 'Error al obtener valoraciones' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/ratings/route.ts
------------------------------------------------------------------------------------
import variantRatingModel from '@/backend/variant-rating'
import { type NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session || !session.user) {
      return NextResponse.json(
        { error: 'Debes iniciar sesi√≥n para valorar productos' },
        { status: 401 }
      )
    }

    const body = await request.json()
    const {
      variantId,
      rating,
      review,
      title,
      verifiedPurchase = false
      // images = [] // Para futuras implementaciones con im√°genes
    } = body

    // Usar el ID del usuario autenticado
    const customerId = parseInt(session.user.id || '0')
    // Validaciones
    if (!variantId || !customerId || !rating) {
      return NextResponse.json(
        { error: 'variantId y rating son requeridos' },
        { status: 400 }
      )
    }

    if (rating < 1 || rating > 5) {
      return NextResponse.json(
        { error: 'El rating debe estar entre 1 y 5' },
        { status: 400 }
      )
    }

    // Verificar si el cliente ya ha valorado esta variante
    const hasRated = await variantRatingModel.hasCustomerRatedVariant(
      customerId,
      variantId
    )

    if (hasRated) {
      return NextResponse.json(
        { error: 'Ya has valorado esta variante' },
        { status: 409 }
      )
    }

    // Crear la nueva valoraci√≥n
    const newRating = await variantRatingModel.createRating(
      variantId,
      customerId,
      rating,
      review || undefined,
      title || undefined,
      verifiedPurchase
    )

    if (!newRating) {
      return NextResponse.json(
        { error: 'Error al crear la valoraci√≥n' },
        { status: 500 }
      )
    }

    // TODO: Si hay im√°genes, procesarlas y guardarlas
    // if (images && images.length > 0) {
    //   await processRatingImages(newRating.id, images)
    // }

    return NextResponse.json(newRating, { status: 201 })
  } catch (error) {
    console.error('Error al crear valoraci√≥n:', error)

    // Manejar errores espec√≠ficos del modelo
    if (
      error instanceof Error &&
      error.message === 'Rating must be between 1 and 5'
    ) {
      return NextResponse.json({ error: error.message }, { status: 400 })
    }

    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}

export async function GET(request: NextRequest) {
  try {
    const url = new URL(request.url)
    const variantId = url.searchParams.get('variantId')
    const customerId = url.searchParams.get('customerId')

    if (variantId) {
      // Obtener valoraciones por variante
      const ratings = await variantRatingModel.getVariantRatingsByVariantId(
        parseInt(variantId)
      )
      return NextResponse.json(ratings || [])
    }

    if (customerId) {
      // Obtener valoraciones por cliente
      const ratings = await variantRatingModel.getVariantRatingsByCustomerId(
        parseInt(customerId)
      )
      return NextResponse.json(ratings || [])
    }

    // Obtener todas las valoraciones (con paginaci√≥n)
    const page = parseInt(url.searchParams.get('page') || '1')
    const limit = parseInt(url.searchParams.get('limit') || '10')

    const allRatings = await variantRatingModel.getVariantRatings()

    // Implementar paginaci√≥n manual si el modelo no la tiene
    const startIndex = (page - 1) * limit
    const endIndex = startIndex + limit
    const paginatedRatings = allRatings?.slice(startIndex, endIndex) || []

    const totalCount = allRatings?.length || 0
    const totalPages = Math.ceil(totalCount / limit)

    return NextResponse.json({
      ratings: paginatedRatings,
      totalCount,
      page,
      totalPages
    })
  } catch (error) {
    console.error('Error al obtener valoraciones:', error)
    return NextResponse.json(
      { error: 'Error al obtener valoraciones' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/ratings/variant/[id]/route.ts
------------------------------------------------------------------------------------
import customerModel from '@/backend/customer'
import variantRatingModel from '@/backend/variant-rating'
import { type NextRequest, NextResponse } from 'next/server'

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const resolvedParams = await params
    const variantId = parseInt(resolvedParams.id)

    if (isNaN(variantId)) {
      return NextResponse.json(
        { error: 'ID de variante inv√°lido' },
        { status: 400 }
      )
    }

    // Obtener par√°metros de consulta
    const url = new URL(request.url)
    const page = parseInt(url.searchParams.get('page') || '1')
    const limit = parseInt(url.searchParams.get('limit') || '10')

    // Usar el modelo para obtener las valoraciones con paginaci√≥n
    const ratingsResult = await variantRatingModel.getRatingsByVariantId(
      variantId,
      page,
      limit
    )

    // Transformar el resultado para que coincida con la estructura esperada por el frontend
    const response = {
      ratings: await Promise.all(
        ratingsResult.ratings.map(async (rating) => ({
          id: rating.id,
          variantId: rating.variantId,
          customerId: rating.customerId,
          rating: rating.rating,
          review: rating.review,
          title: rating.title,
          verifiedPurchase: rating.verifiedPurchase === 1,
          createdAt: rating.createdAt,
          updatedAt: rating.updatedAt,
          customerName: rating.customerName,
          customerPhoto: rating.customerPhoto || null,
          // Agregar im√°genes de rating si las hay
          ratingImages: rating.ratingImages || [],
          // Informaci√≥n del customer si est√° disponible
          customer: await customerModel.getCustomer(rating.customerId)
        }))
      ),
      summary: {
        totalRatings: ratingsResult.summary.totalRatings,
        averageRating: ratingsResult.summary.averageRating,
        fiveStar: ratingsResult.summary.fiveStar,
        fourStar: ratingsResult.summary.fourStar,
        threeStar: ratingsResult.summary.threeStar,
        twoStar: ratingsResult.summary.twoStar,
        oneStar: ratingsResult.summary.oneStar,
        verifiedPurchases: ratingsResult.summary.verifiedPurchases
      },
      totalCount: ratingsResult.totalCount,
      totalPages: ratingsResult.totalPages,
      currentPage: ratingsResult.page
    }

    return NextResponse.json(response)
  } catch (error) {
    console.error('Error al obtener valoraciones de variante:', error)
    return NextResponse.json(
      { error: 'Error al obtener valoraciones' },
      { status: 500 }
    )
  }
}

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const resolvedParams = await params
    const variantId = parseInt(resolvedParams.id)

    if (isNaN(variantId)) {
      return NextResponse.json(
        { error: 'ID de variante inv√°lido' },
        { status: 400 }
      )
    }

    const body = await request.json()
    const { customerId, rating, review, title, verifiedPurchase = false } = body

    // Validaciones
    if (!customerId || !rating) {
      return NextResponse.json(
        { error: 'customerId y rating son requeridos' },
        { status: 400 }
      )
    }

    if (rating < 1 || rating > 5) {
      return NextResponse.json(
        { error: 'El rating debe estar entre 1 y 5' },
        { status: 400 }
      )
    }

    // Verificar si el cliente ya ha valorado esta variante
    const hasRated = await variantRatingModel.hasCustomerRatedVariant(
      customerId,
      variantId
    )

    if (hasRated) {
      return NextResponse.json(
        { error: 'Ya has valorado esta variante' },
        { status: 409 }
      )
    }

    // Crear la nueva valoraci√≥n
    const newRating = await variantRatingModel.createRating(
      variantId,
      customerId,
      rating,
      review,
      title,
      verifiedPurchase
    )

    if (!newRating) {
      return NextResponse.json(
        { error: 'Error al crear la valoraci√≥n' },
        { status: 500 }
      )
    }

    return NextResponse.json(newRating, { status: 201 })
  } catch (error) {
    console.error('Error al crear valoraci√≥n:', error)
    return NextResponse.json(
      { error: 'Error al crear valoraci√≥n' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/shipping/calculate-user/route.ts
------------------------------------------------------------------------------------
// üìÑ app/api/shipping/calculate-user/route.ts
import { authOptions } from '@/lib/auth'
import { getServerSession } from 'next-auth'
import { type NextRequest, NextResponse } from 'next/server'

// Usar tus modelos existentes
import customerAddressModel from '@/backend/customer-address'
import shippingZoneMethodModel from '@/backend/shipping-zone-method'

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      )
    }

    const body = await request.json()
    const { productVariantId, quantity = 1, orderValue } = body

    if (!productVariantId || !orderValue) {
      return NextResponse.json(
        {
          error: 'Missing required fields: productVariantId, orderValue'
        },
        { status: 400 }
      )
    }

    const customerId = parseInt(session.user.id)

    // 1. Obtener todas las direcciones del usuario usando tu modelo
    const userAddresses =
      await customerAddressModel.getAddressByCustomer(customerId)

    if (!userAddresses || userAddresses.length === 0) {
      return NextResponse.json({
        defaultAddress: null,
        allAddresses: [],
        message: 'No addresses found'
      })
    }

    // 2. Calcular opciones de env√≠o para cada direcci√≥n
    const addressesWithShipping = []

    for (const address of userAddresses) {
      // Usar tu modelo existente para calcular opciones
      const shippingOptions =
        await shippingZoneMethodModel.calculateShippingOptions(
          address.district,
          address.province,
          address.department,
          orderValue
        )

      if (shippingOptions && shippingOptions.length > 0) {
        // Encontrar la opci√≥n m√°s barata como default
        const defaultOption = shippingOptions.reduce((prev, current) =>
          prev.finalCost <= current.finalCost ? prev : current
        )

        addressesWithShipping.push({
          addressId: address.id,
          address: {
            id: address.id,
            alias: address.alias,
            streetName: address.streetName,
            streetNumber: address.streetNumber,
            district: address.district,
            province: address.province,
            department: address.department,
            apartment: address.apartment || undefined
          },
          shippingOptions,
          defaultShippingOption: defaultOption
        })
      }
    }

    // 3. Determinar direcci√≥n por defecto
    let defaultAddress = null

    // Buscar direcci√≥n marcada como default (verificar si este m√©todo existe)
    // Si no tienes este m√©todo, usaremos la primera direcci√≥n con isDefault = 1
    const defaultUserAddress = userAddresses.find(
      (addr) => addr.isDefault === 1
    )

    if (defaultUserAddress) {
      defaultAddress = addressesWithShipping.find(
        (addr) => addr.addressId === defaultUserAddress.id
      )
    }

    // Si no hay default o no tiene env√≠o, usar la primera disponible
    if (!defaultAddress && addressesWithShipping.length > 0) {
      defaultAddress = addressesWithShipping[0]
    }

    return NextResponse.json({
      defaultAddress,
      allAddresses: addressesWithShipping,
      userId: session.user.id
    })
  } catch (error) {
    console.error('Error calculating shipping for user:', error)
    return NextResponse.json(
      {
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/checkout/validate-coupon/route.ts
------------------------------------------------------------------------------------
// üìÑ app/api/checkout/validate-coupon/route.ts
import couponModel from '@/backend/coupon'
import customerModel from '@/backend/customer'
import { authOptions } from '@/lib/auth'
import { getServerSession } from 'next-auth'
import { type NextRequest, NextResponse } from 'next/server'

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.email) {
      return NextResponse.json(
        { error: 'Usuario no autenticado' },
        { status: 401 }
      )
    }

    const customer = await customerModel.getCustomerByEmail(session.user.email)
    if (!customer) {
      return NextResponse.json(
        { error: 'Cliente no encontrado' },
        { status: 404 }
      )
    }

    const { couponCode, totalAmount } = await request.json()

    if (!couponCode || !totalAmount) {
      return NextResponse.json(
        { error: 'C√≥digo de cup√≥n y monto total requeridos' },
        { status: 400 }
      )
    }

    const coupon = await couponModel.getCouponByCode(couponCode)

    if (!coupon) {
      return NextResponse.json({
        isValid: false,
        error: 'Cup√≥n no v√°lido',
        discountAmount: 0
      })
    }

    if (!coupon.isActive) {
      return NextResponse.json({
        isValid: false,
        error: 'Cup√≥n no activo',
        discountAmount: 0
      })
    }

    const now = new Date()
    if (now < new Date(coupon.startDate) || now > new Date(coupon.endDate)) {
      return NextResponse.json({
        isValid: false,
        error: 'Cup√≥n expirado',
        discountAmount: 0
      })
    }

    if (coupon.minPurchaseAmount && totalAmount < coupon.minPurchaseAmount) {
      return NextResponse.json({
        isValid: false,
        error: `Monto m√≠nimo requerido: S/ ${coupon.minPurchaseAmount}`,
        discountAmount: 0
      })
    }

    // Calcular descuento
    let discountAmount = 0
    if (coupon.discountType === 'percentage') {
      discountAmount = (totalAmount * coupon.discountValue) / 100
      if (
        coupon.maxDiscountAmount &&
        discountAmount > coupon.maxDiscountAmount
      ) {
        discountAmount = coupon.maxDiscountAmount
      }
    } else {
      discountAmount = coupon.discountValue
    }

    return NextResponse.json({
      isValid: true,
      coupon,
      discountAmount,
      message: `Descuento aplicado: S/ ${discountAmount.toFixed(2)}`
    })
  } catch (error) {
    console.error('Error validating coupon:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/checkout/route.ts
------------------------------------------------------------------------------------
// üìÑ app/api/checkout/route.ts
import { getServerSession } from 'next-auth'
import { type NextRequest, NextResponse } from 'next/server'

// Models
import couponModel from '@/backend/coupon'
import customerModel from '@/backend/customer'
import customerAddressModel from '@/backend/customer-address'
import orderModel from '@/backend/order'
import orderItemsModel from '@/backend/order-item'
import paymentMethodModel from '@/backend/payment-method'
import paymentTransactionModel from '@/backend/payment-transaction'
import productVariantModel from '@/backend/product-variant'
import shippingZoneMethodModel from '@/backend/shipping-zone-method'

// Types
import { authOptions } from '@/lib/auth'
import {
  type CheckoutResponse,
  type CouponValidation,
  type CreateOrderData,
  type OrderCalculation,
  type StockValidation
} from '@/types/checkout'

// Funci√≥n para obtener el usuario autenticado
async function getAuthenticatedUser() {
  const session = await getServerSession(authOptions)

  if (!session?.user?.email) {
    return null
  }

  // Buscar el customer por email (ajusta seg√∫n tu l√≥gica de autenticaci√≥n)
  const customer = await customerModel.getCustomerByEmail(session.user.email)
  return customer
}

// Validar stock de los items
async function validateStock(items: any[]): Promise<StockValidation> {
  const errors: any[] = []

  for (const item of items) {
    const variant = await productVariantModel.getProductVariantById(item.id)

    if (!variant) {
      errors.push({
        variantId: item.id,
        requestedQuantity: item.quantity,
        availableStock: 0,
        message: 'Producto no encontrado'
      })
      continue
    }

    if (variant.stock < item.quantity) {
      errors.push({
        variantId: item.id,
        requestedQuantity: item.quantity,
        availableStock: variant.stock,
        message: `Stock insuficiente. Disponible: ${variant.stock}`
      })
    }
  }

  return {
    isValid: errors.length === 0,
    errors
  }
}

// Validar cup√≥n
async function validateCoupon(
  couponCode: string,
  customerId: number,
  totalAmount: number
): Promise<CouponValidation> {
  try {
    const coupon = await couponModel.getCouponByCode(couponCode)

    if (!coupon) {
      return { isValid: false, discountAmount: 0, error: 'Cup√≥n no v√°lido' }
    }

    if (!coupon.isActive) {
      return { isValid: false, discountAmount: 0, error: 'Cup√≥n no activo' }
    }

    const now = new Date()
    if (now < new Date(coupon.startDate) || now > new Date(coupon.endDate)) {
      return { isValid: false, discountAmount: 0, error: 'Cup√≥n expirado' }
    }

    if (coupon.minPurchaseAmount && totalAmount < coupon.minPurchaseAmount) {
      return {
        isValid: false,
        discountAmount: 0,
        error: `Monto m√≠nimo requerido: S/ ${coupon.minPurchaseAmount}`
      }
    }

    // Calcular descuento
    let discountAmount = 0
    if (coupon.discountType === 'percentage') {
      discountAmount = (totalAmount * coupon.discountValue) / 100
      if (
        coupon.maxDiscountAmount &&
        discountAmount > coupon.maxDiscountAmount
      ) {
        discountAmount = coupon.maxDiscountAmount
      }
    } else {
      discountAmount = coupon.discountValue
    }

    return {
      isValid: true,
      coupon,
      discountAmount
    }
  } catch (error) {
    return { isValid: false, discountAmount: 0, error: 'Error validando cup√≥n' }
  }
}

// Calcular totales de la orden
async function calculateOrderTotals(
  items: any[],
  shippingCost: number,
  couponCode?: string,
  customerId?: number
): Promise<OrderCalculation> {
  // Calcular subtotal considerando promociones
  let subtotal = 0

  for (const item of items) {
    let itemPrice = item.price

    // Aplicar precio promocional si existe
    if (item.promotionVariants && item.promotionVariants.length > 0) {
      const activePromotion = item.promotionVariants.find(
        (pv: any) =>
          pv.promotion.isActive === 1 &&
          new Date() >= new Date(pv.promotion.startDate) &&
          new Date() <= new Date(pv.promotion.endDate)
      )

      if (activePromotion) {
        itemPrice = parseFloat(activePromotion.promotionPrice)
      }
    }

    subtotal += itemPrice * item.quantity
  }

  let discountAmount = 0
  let appliedCoupon

  // Aplicar cup√≥n si existe
  if (couponCode && customerId) {
    const couponValidation = await validateCoupon(
      couponCode,
      customerId,
      subtotal
    )
    if (couponValidation.isValid) {
      discountAmount = couponValidation.discountAmount
      appliedCoupon = couponValidation.coupon
    }
  }

  // Calcular IGV (18% en Per√∫)
  const taxAmount = (subtotal - discountAmount + shippingCost) * 0.18

  const totalAmount = subtotal - discountAmount + shippingCost + taxAmount

  // Estimar entrega (ejemplo: 3-7 d√≠as)
  const estimatedDelivery = new Date()
  estimatedDelivery.setDate(estimatedDelivery.getDate() + 5)

  return {
    subtotal,
    discountAmount,
    shippingCost,
    taxAmount,
    totalAmount,
    estimatedDelivery,
    appliedCoupon
  }
}

// Generar n√∫mero de orden √∫nico
function generateOrderNumber(): string {
  const timestamp = Date.now().toString()
  const random = Math.random().toString(36).substring(2, 6).toUpperCase()
  return `ORD-${new Date().getFullYear()}-${timestamp}-${random}`
}

export async function POST(request: NextRequest) {
  try {
    const user = await getAuthenticatedUser()
    if (!user) {
      return NextResponse.json(
        { success: false, error: 'Usuario no autenticado' },
        { status: 401 }
      )
    }

    const orderData: CreateOrderData = await request.json()

    // 1. Validar stock
    const stockValidation = await validateStock(orderData.items)
    if (!stockValidation.isValid) {
      return NextResponse.json(
        {
          success: false,
          error: 'Stock insuficiente',
          validationErrors: stockValidation.errors.map((error) => ({
            field: `item_${error.variantId}`,
            message: error.message
          }))
        },
        { status: 400 }
      )
    }

    // 2. Calcular costo de env√≠o
    const address = await customerAddressModel.getAddress(
      orderData.shippingAddressId
    )
    if (!address) {
      return NextResponse.json(
        {
          success: false,
          error: 'Direcci√≥n de env√≠o no v√°lida'
        },
        { status: 400 }
      )
    }

    const shippingCost = await shippingZoneMethodModel.getShippingCost(
      orderData.shippingMethodId,
      address.district,
      address.province,
      address.department,
      orderData.items.reduce(
        (total, item) => total + item.price * item.quantity,
        0
      )
    )

    if (!shippingCost) {
      return NextResponse.json(
        {
          success: false,
          error: 'M√©todo de env√≠o no disponible para esta direcci√≥n'
        },
        { status: 400 }
      )
    }

    // 3. Calcular totales
    const calculation = await calculateOrderTotals(
      orderData.items,
      shippingCost.finalCost,
      orderData.couponCode,
      user.id
    )

    // 4. Crear la orden
    const orderNumber = generateOrderNumber()

    const newOrder = await orderModel.createOrder({
      customerId: user.id,
      orderNumber,
      shippingAddressId: orderData.shippingAddressId,
      paymentMethod:
        (
          await paymentMethodModel.getPaymentMethodById(
            orderData.paymentMethodId
          )
        )?.code || '',
      shippingMethod: shippingCost.methodName,
      shippingCost: calculation.shippingCost,
      subtotal: calculation.subtotal,
      discountAmount: calculation.discountAmount,
      taxAmount: calculation.taxAmount,
      totalAmount: calculation.totalAmount,
      status: 'pending',
      paymentStatus: 'pending',
      customerNotes: orderData.customerNotes || null,
      adminNotes: null,
      estimatedDelivery: calculation.estimatedDelivery,
      paidAt: null
    })

    if (!newOrder) {
      return NextResponse.json(
        {
          success: false,
          error: 'Error creando la orden'
        },
        { status: 500 }
      )
    }

    // 5. Crear items de la orden
    const orderItems = orderData.items.map((item) => {
      let unitPrice = item.price

      // Aplicar precio promocional si existe
      if (item.promotionVariants && item.promotionVariants.length > 0) {
        const activePromotion = item.promotionVariants
          .filter((pv) => !!pv)
          .find(
            (pv) =>
              pv?.promotion?.isActive === 1 &&
              new Date() >= new Date(pv.promotion.startDate) &&
              new Date() <= new Date(pv.promotion.endDate)
          )

        if (activePromotion) {
          unitPrice = parseFloat(activePromotion?.promotionPrice)
        }
      }

      return {
        orderId: newOrder.id,
        variantId: item.id,
        productName: item.name,
        variantSku: `SKU-${item.id}`, // Esto deber√≠a venir de la variant real
        variantAttributes: {}, // Esto tambi√©n deber√≠a venir de la variant
        quantity: item.quantity,
        unitPrice,
        totalPrice: unitPrice * item.quantity,
        discountAmount: 0
      }
    })

    await orderItemsModel.createOrderItems(orderItems)

    // 6. Crear transacci√≥n de pago
    const transaction = await paymentTransactionModel.createTransaction({
      orderId: newOrder.id,
      paymentMethodId: orderData.paymentMethodId,
      amount: calculation.totalAmount,
      currency: 'PEN',
      paymentData: orderData.paymentData
    })

    // 7. Aplicar cup√≥n si existe
    if (orderData.couponCode && calculation.appliedCoupon) {
      await couponModel.applyCoupon({
        couponCode: orderData.couponCode,
        customerId: user.id,
        orderId: newOrder.id,
        orderTotal: calculation.discountAmount
      })
    }

    // 8. Reducir stock
    for (const item of orderData.items) {
      await productVariantModel.updateStock(item.id, -item.quantity)
    }

    const response: CheckoutResponse = {
      success: true,
      orderId: newOrder.id,
      orderNumber: newOrder.orderNumber,
      paymentUrl: transaction ? `/payment/${transaction.id}` : undefined
    }

    return NextResponse.json(response)
  } catch (error) {
    console.error('Error en checkout:', error)
    return NextResponse.json(
      {
        success: false,
        error: 'Error interno del servidor'
      },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/checkout/validate-stock/route.ts
------------------------------------------------------------------------------------
import productVariantModel from '@/backend/product-variant'
import { type NextRequest, NextResponse } from 'next/server'

export async function POST(request: NextRequest) {
  try {
    const { items } = await request.json()

    if (!items || !Array.isArray(items)) {
      return NextResponse.json({ error: 'Items requeridos' }, { status: 400 })
    }

    const validationErrors = []

    for (const item of items) {
      const variant = await productVariantModel.getProductVariantById(item.id)

      if (!variant) {
        validationErrors.push({
          variantId: item.id,
          message: 'Producto no encontrado',
          availableStock: 0
        })
        continue
      }

      if (variant.stock < item.quantity) {
        validationErrors.push({
          variantId: item.id,
          message: `Stock insuficiente. Disponible: ${variant.stock}`,
          availableStock: variant.stock,
          requestedQuantity: item.quantity
        })
      }
    }

    return NextResponse.json({
      isValid: validationErrors.length === 0,
      errors: validationErrors
    })
  } catch (error) {
    console.error('Error validating stock:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/checkout/data/route.ts
------------------------------------------------------------------------------------
// üìÑ app/api/checkout/data/route.ts
import { getServerSession } from 'next-auth'
import { type NextRequest, NextResponse } from 'next/server'

// Models
import customerModel from '@/backend/customer'
import customerAddressModel from '@/backend/customer-address'
import paymentMethodModel from '@/backend/payment-method'
import shippingZoneMethodModel from '@/backend/shipping-zone-method'

// Types
import { authOptions } from '@/lib/auth'
import {
  type CheckoutSummary,
  type CheckoutUser,
  type PaymentOption,
  type ShippingOption
} from '@/types/checkout'

// Funci√≥n para obtener el usuario autenticado
async function getAuthenticatedUser() {
  const session = await getServerSession(authOptions)

  if (!session?.user?.email) {
    return null
  }

  // Buscar el customer por email (ajusta seg√∫n tu l√≥gica de autenticaci√≥n)
  const customer = await customerModel.getCustomerByEmail(session.user.email)
  return customer
}

export async function POST(request: NextRequest) {
  try {
    const user = await getAuthenticatedUser()
    if (!user) {
      return NextResponse.json(
        { error: 'Usuario no autenticado' },
        { status: 401 }
      )
    }

    const { items, shippingAddressId } = await request.json()

    if (!items || !Array.isArray(items) || items.length === 0) {
      return NextResponse.json(
        { error: 'Items del carrito requeridos' },
        { status: 400 }
      )
    }

    // 1. Obtener direcciones del cliente
    const addresses = await customerAddressModel.getAddressByCustomer(user.id)
    if (!addresses || addresses.length === 0) {
      return NextResponse.json(
        { error: 'No hay direcciones registradas' },
        { status: 400 }
      )
    }

    // 2. Determinar direcci√≥n de env√≠o
    let selectedAddress = addresses.find(
      (addr) => addr.id === shippingAddressId
    )
    if (!selectedAddress) {
      selectedAddress =
        addresses.find((addr) => addr.isDefault === 1) || addresses[0]
    }

    // 3. Calcular subtotal
    let subtotal = 0
    let itemCount = 0
    let totalQuantity = 0

    for (const item of items) {
      let itemPrice = item.price

      // Aplicar precio promocional si existe
      if (item.promotionVariants && item.promotionVariants.length > 0) {
        const activePromotion = item.promotionVariants.find(
          (pv: any) =>
            pv.promotion.isActive === 1 &&
            new Date() >= new Date(pv.promotion.startDate) &&
            new Date() <= new Date(pv.promotion.endDate)
        )

        if (activePromotion) {
          itemPrice = parseFloat(activePromotion.promotionPrice)
        }
      }

      subtotal += itemPrice * item.quantity
      itemCount++
      totalQuantity += item.quantity
    }

    // 4. Obtener opciones de env√≠o
    const shippingCalculations =
      await shippingZoneMethodModel.calculateShippingOptions(
        selectedAddress.district,
        selectedAddress.province,
        selectedAddress.department,
        subtotal
      )

    const shippingOptions: ShippingOption[] =
      shippingCalculations?.map((calc) => ({
        methodId: calc.methodId,
        methodName: calc.methodName,
        cost: calc.finalCost,
        isFree: calc.isFree,
        estimatedDays: calc.estimatedDays,
        description: calc.isFree ? 'Env√≠o gratis' : undefined
      })) || []

    // 5. Obtener m√©todos de pago v√°lidos
    const paymentCalculations =
      await paymentMethodModel.getValidPaymentMethodsForAmount(subtotal)

    // Obtener los m√©todos de pago completos para tener toda la informaci√≥n
    const allPaymentMethods = await paymentMethodModel.getPaymentMethods()

    const paymentOptions: PaymentOption[] =
      paymentCalculations?.map((calc) => {
        // Buscar el m√©todo completo por ID
        const fullMethod = allPaymentMethods?.find(
          (m) => m.id === calc.methodId
        )

        return {
          methodId: calc.methodId,
          methodName: fullMethod?.name || '',
          methodCode: fullMethod?.code || '',
          baseAmount: calc.baseAmount,
          processingFee: calc.processingFee,
          finalAmount: calc.finalAmount,
          iconUrl: fullMethod?.iconUrl || undefined,
          description: fullMethod?.description || calc.reason,
          requiresVerification: fullMethod?.requiresVerification === 1
        }
      }) || []

    // 6. C√°lculo inicial (sin env√≠o ni descuentos)
    const calculation = {
      subtotal,
      discountAmount: 0,
      shippingCost: shippingOptions[0]?.cost || 0,
      taxAmount: (subtotal + (shippingOptions[0]?.cost || 0)) * 0.18,
      totalAmount:
        subtotal +
        (shippingOptions[0]?.cost || 0) +
        (subtotal + (shippingOptions[0]?.cost || 0)) * 0.18,
      estimatedDelivery: null
    }

    // 7. Preparar usuario para checkout
    const checkoutUser: CheckoutUser = {
      id: user.id,
      name: user.name || '',
      lastname: user.lastname,
      email: user.email,
      phone: user.phone,
      addresses,
      defaultAddressId: addresses.find((addr) => addr.isDefault === 1)?.id
    }

    const summary: CheckoutSummary = {
      items,
      itemCount,
      totalQuantity,
      calculation,
      shippingOptions,
      paymentOptions,
      customerAddresses: addresses,
      selectedAddress
    }

    return NextResponse.json({
      user: checkoutUser,
      summary
    })
  } catch (error) {
    console.error('Error obteniendo datos de checkout:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}

// GET para obtener datos iniciales sin items del carrito
export async function GET() {
  try {
    const user = await getAuthenticatedUser()
    if (!user) {
      return NextResponse.json(
        { error: 'Usuario no autenticado' },
        { status: 401 }
      )
    }

    // Obtener direcciones del cliente
    const addresses = await customerAddressModel.getAddressByCustomer(user.id)

    // Obtener todos los m√©todos de pago activos
    const allPaymentMethods = await paymentMethodModel.getPaymentMethods()

    const checkoutUser: CheckoutUser = {
      id: user.id,
      name: user.name || '',
      lastname: user.lastname,
      email: user.email,
      phone: user.phone,
      addresses: addresses || [],
      defaultAddressId: addresses?.find((addr) => addr.isDefault === 1)?.id
    }

    return NextResponse.json({
      user: checkoutUser,
      paymentMethods: allPaymentMethods || []
    })
  } catch (error) {
    console.error('Error obteniendo datos iniciales:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/checkout/shipping-options/route.ts
------------------------------------------------------------------------------------
// üìÑ app/api/checkout/shipping-options/route.ts
import shippingZoneMethodModel from '@/backend/shipping-zone-method'
import { type NextRequest, NextResponse } from 'next/server'

export async function POST(request: NextRequest) {
  try {
    const { district, province, department, orderValue } = await request.json()

    if (!district || !province || !department || !orderValue) {
      return NextResponse.json(
        { error: 'Datos de direcci√≥n y valor de orden requeridos' },
        { status: 400 }
      )
    }

    const shippingOptions =
      await shippingZoneMethodModel.calculateShippingOptions(
        district,
        province,
        department,
        orderValue
      )

    if (!shippingOptions || shippingOptions.length === 0) {
      return NextResponse.json({
        options: [],
        message: 'No hay m√©todos de env√≠o disponibles para esta direcci√≥n'
      })
    }

    const formattedOptions = shippingOptions.map((option) => ({
      methodId: option.methodId,
      methodName: option.methodName,
      cost: option.finalCost,
      isFree: option.isFree,
      estimatedDays: option.estimatedDays,
      description: option.isFree ? 'Env√≠o gratis' : undefined
    }))

    return NextResponse.json({
      options: formattedOptions
    })
  } catch (error) {
    console.error('Error getting shipping options:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/search/suggestions/route.ts
------------------------------------------------------------------------------------
import searchModel from '@/backend/search'
import { type NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const query = searchParams.get('q')
    const limit = parseInt(searchParams.get('limit') || '10')

    if (!query || query.trim().length < 2) {
      return NextResponse.json([])
    }

    const suggestions = await searchModel.getSearchSuggestions(query, limit)

    return NextResponse.json(suggestions)
  } catch (error) {
    console.error('Error al obtener sugerencias:', error)
    return NextResponse.json(
      { error: 'Error al obtener sugerencias' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/register/route.ts
------------------------------------------------------------------------------------
import CustomerService from '@/services/customer'
import { type CustomerData } from '@/services/customer/types'
import { type NextRequest, NextResponse } from 'next/server'

export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    const body: CustomerData = await request.json()
    const { name, lastname, email, password } = body

    // Validaciones b√°sicas
    if (name === '' || lastname === '' || email === '' || password === '') {
      return NextResponse.json(
        { error: 'Todos los campos son requeridos' },
        { status: 400 }
      )
    }

    try {
      const newCustomer = await CustomerService.register({
        name,
        lastname,
        email,
        password
      })

      // Retornar el cliente creado (sin la contrase√±a)
      return NextResponse.json(newCustomer, { status: 201 })
    } catch (error) {
      if (error instanceof Error) {
        return NextResponse.json({ error: error.message }, { status: 409 })
      }
      throw error
    }
  } catch (error) {
    console.error('Error al registrar cliente:', error)
    return NextResponse.json(
      { error: 'Error al procesar la solicitud' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/cart/sync/route.ts
------------------------------------------------------------------------------------
import productVariantModel from '@/backend/product-variant'
import { type NextRequest, NextResponse } from 'next/server'

export async function POST(request: NextRequest) {
  try {
    const { items } = await request.json()

    if (!items || !Array.isArray(items)) {
      return NextResponse.json(
        { error: 'Items del carrito requeridos' },
        { status: 400 }
      )
    }

    const syncedItems = []
    const removedItems = []

    for (const item of items) {
      const variant = await productVariantModel.getProductVariantById(item.id)

      if (!variant) {
        removedItems.push({
          ...item,
          reason: 'Producto no disponible'
        })
        continue
      }

      if (variant.stock === 0) {
        removedItems.push({
          ...item,
          reason: 'Sin stock'
        })
        continue
      }

      // Ajustar cantidad si excede el stock disponible
      const adjustedQuantity = Math.min(item.quantity, variant.stock)

      syncedItems.push({
        ...item,
        quantity: adjustedQuantity,
        stock: variant.stock,
        priceUpdated: variant.price !== item.price,
        currentPrice: variant.price
      })
    }

    return NextResponse.json({
      syncedItems,
      removedItems,
      hasChanges:
        removedItems.length > 0 ||
        syncedItems.some(
          (item) =>
            item.quantity !==
              items.find((original) => original.id === item.id)?.quantity ||
            item.priceUpdated
        )
    })
  } catch (error) {
    console.error('Error syncing cart:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/productos/variante/[id]/route.ts
------------------------------------------------------------------------------------
import { getProductVariant } from '@/services/product/productVariant'
import { type NextRequest, NextResponse } from 'next/server'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const variantId = parseInt(id)

    if (isNaN(variantId)) {
      return NextResponse.json(
        { error: 'ID de variante inv√°lido' },
        { status: 400 }
      )
    }

    // Usar el servicio existente para obtener la variante completa
    const variantData = await getProductVariant(variantId)

    if (!variantData) {
      return NextResponse.json(
        { error: 'Variante no encontrada' },
        { status: 404 }
      )
    }

    return NextResponse.json(variantData)
  } catch (error) {
    console.error('Error fetching product variant:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/productos/[id]/variantes/route.ts
------------------------------------------------------------------------------------
import { type NextRequest, NextResponse } from 'next/server'
import productVariantModel from '@/backend/product-variant/ProductVariant.model'

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const productId = parseInt(params.id)

    if (isNaN(productId)) {
      return NextResponse.json(
        { error: 'ID de producto inv√°lido' },
        { status: 400 }
      )
    }

    // Usar el modelo existente para obtener todas las variantes del producto con atributos
    const variants =
      await productVariantModel.getProductVariantsByProductIdWithAttributeOptions(
        productId
      )

    if (!variants) {
      return NextResponse.json(
        { error: 'No se encontraron variantes para este producto' },
        { status: 404 }
      )
    }

    return NextResponse.json(variants)
  } catch (error) {
    console.error('Error fetching product variants:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/orders/[orderNumber]/route.ts
------------------------------------------------------------------------------------
import customerModel from '@/backend/customer'
import orderModel from '@/backend/order'
import orderItemsModel from '@/backend/order-item'
import orderTrackingModel from '@/backend/order-tracking'
import { authOptions } from '@/lib/auth'
import { getServerSession } from 'next-auth'
import { type NextRequest, NextResponse } from 'next/server'

interface Params {
  orderNumber: string
}

export async function GET(
  request: NextRequest,
  { params }: { params: Params }
) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.email) {
      return NextResponse.json(
        { error: 'Usuario no autenticado' },
        { status: 401 }
      )
    }

    const customer = await customerModel.getCustomerByEmail(session.user.email)
    if (!customer) {
      return NextResponse.json(
        { error: 'Cliente no encontrado' },
        { status: 404 }
      )
    }

    const order = await orderModel.getOrderByNumber(params.orderNumber)
    if (!order) {
      return NextResponse.json(
        { error: 'Orden no encontrada' },
        { status: 404 }
      )
    }

    // Verificar que la orden pertenece al cliente
    if (order.customerId !== customer.id) {
      return NextResponse.json({ error: 'No autorizado' }, { status: 403 })
    }

    // Obtener items de la orden
    const orderItems = await orderItemsModel.getOrderItemsByOrderId(order.id)

    // Obtener seguimiento de la orden
    const tracking = await orderTrackingModel.getOrderTrackingsByOrderId(
      order.id
    )

    return NextResponse.json({
      order,
      items: orderItems || [],
      tracking: tracking || []
    })
  } catch (error) {
    console.error('Error getting order:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/customer/profile/route.ts
------------------------------------------------------------------------------------
// app/api/customer/profile/route.ts
import customerModel from '@/backend/customer'
import { authOptions } from '@/lib/auth'
import { getServerSession } from 'next-auth'
import { type NextRequest, NextResponse } from 'next/server'

export async function PUT(request: NextRequest) {
  try {
    // Verificar sesi√≥n
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'No autorizado' }, { status: 401 })
    }

    // Obtener datos del cuerpo de la petici√≥n
    const body = await request.json()
    const { name, lastname, email } = body

    // Validaciones b√°sicas
    if (!name || !lastname || !email) {
      return NextResponse.json(
        { error: 'Todos los campos son requeridos' },
        { status: 400 }
      )
    }

    // Validar formato de email
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    if (!emailRegex.test(email)) {
      return NextResponse.json(
        { error: 'Formato de email inv√°lido' },
        { status: 400 }
      )
    }

    // Verificar si el email ya existe (si es diferente al actual)
    const currentCustomer = await customerModel.getCustomer(
      parseInt(session.user.id)
    )
    if (!currentCustomer) {
      return NextResponse.json(
        { error: 'Cliente no encontrado' },
        { status: 404 }
      )
    }

    if (email !== currentCustomer.email) {
      const existingCustomer = await customerModel.getCustomerByEmail(email)
      if (
        existingCustomer &&
        existingCustomer.id !== parseInt(session.user.id)
      ) {
        return NextResponse.json(
          { error: 'El email ya est√° en uso' },
          { status: 400 }
        )
      }
    }

    // Actualizar datos del cliente
    const updatedCustomer = await customerModel.updateCustomer(
      {
        name,
        lastname,
        email
      },
      parseInt(session.user.id)
    )

    if (!updatedCustomer) {
      return NextResponse.json(
        { error: 'Error al actualizar el perfil' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      message: 'Perfil actualizado correctamente',
      customer: {
        id: updatedCustomer.id,
        name: updatedCustomer.name,
        lastname: updatedCustomer.lastname,
        email: updatedCustomer.email
      }
    })
  } catch (error) {
    console.error('Error en PUT /api/customer/profile:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/customer/profile/change-password/route.ts
------------------------------------------------------------------------------------
// app/api/customer/change-password/route.ts
import customerModel from '@/backend/customer'
import { authOptions } from '@/lib/auth'
import bcrypt from 'bcryptjs'
import { getServerSession } from 'next-auth'
import { type NextRequest, NextResponse } from 'next/server'

export async function PUT(request: NextRequest) {
  try {
    // Verificar sesi√≥n
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'No autorizado' }, { status: 401 })
    }

    // Obtener datos del cuerpo de la petici√≥n
    const body = await request.json()
    const { currentPassword, newPassword } = body

    // Validaciones b√°sicas
    if (!currentPassword || !newPassword) {
      return NextResponse.json(
        { error: 'La contrase√±a actual y nueva son requeridas' },
        { status: 400 }
      )
    }

    if (newPassword.length < 8) {
      return NextResponse.json(
        { error: 'La nueva contrase√±a debe tener al menos 8 caracteres' },
        { status: 400 }
      )
    }

    if (currentPassword === newPassword) {
      return NextResponse.json(
        { error: 'La nueva contrase√±a debe ser diferente a la actual' },
        { status: 400 }
      )
    }

    // Obtener el cliente actual
    const customer = await customerModel.getCustomer(parseInt(session.user.id))
    if (!customer) {
      return NextResponse.json(
        { error: 'Cliente no encontrado' },
        { status: 404 }
      )
    }

    // Verificar la contrase√±a actual
    const isCurrentPasswordValid = await bcrypt.compare(
      currentPassword,
      customer.password
    )
    if (!isCurrentPasswordValid) {
      return NextResponse.json(
        { error: 'La contrase√±a actual es incorrecta' },
        { status: 400 }
      )
    }

    // Encriptar la nueva contrase√±a
    const hashedNewPassword = await bcrypt.hash(newPassword, 10)

    // Actualizar la contrase√±a
    const updatedCustomer = await customerModel.updateCustomer(
      {
        password: hashedNewPassword
      },
      parseInt(session.user.id)
    )

    if (!updatedCustomer) {
      return NextResponse.json(
        { error: 'Error al actualizar la contrase√±a' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      message: 'Contrase√±a actualizada correctamente'
    })
  } catch (error) {
    console.error('Error en PUT /api/customer/change-password:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/customer/addresses/default/route.ts
------------------------------------------------------------------------------------
// app/api/customer/addresses/default/route.ts
import { NextResponse } from 'next/server'

export async function GET() {
  try {
    // Aqu√≠ obtendr√≠as la direcci√≥n por defecto del cliente autenticado
    // const userId = await getUserFromSession();
    // const defaultAddress = await getDefaultAddress(userId);

    // Ejemplo de respuesta
    const defaultAddress = {
      id: 1,
      id_customer: 1,
      alias: 'Casa',
      street_name: 'Av. Javier Prado Este',
      street_number: '1234',
      apartment: 'Dpto 501',
      district: 'San Isidro',
      province: 'Lima',
      department: 'Lima',
      is_default: 1,
      latitude: -12.0464,
      longitude: -77.0428,
      created_at: new Date(),
      updated_at: new Date()
    }

    return NextResponse.json({ address: defaultAddress })
  } catch (error) {
    console.error('Error loading default address:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/customer/addresses/route.ts
------------------------------------------------------------------------------------
// app/api/customer/addresses/route.ts
import customerAddressModel from '@/backend/customer-address'
import { authOptions } from '@/lib/auth'
import { getServerSession } from 'next-auth'
import { type NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'

// Schema de validaci√≥n para crear direcci√≥n
const createAddressSchema = z.object({
  alias: z.string().min(1, 'El nombre de la direcci√≥n es requerido').max(50),
  department: z.string().min(1, 'El departamento es requerido'),
  province: z.string().min(1, 'La provincia es requerida'),
  district: z.string().min(1, 'El distrito es requerido'),
  streetName: z.string().min(1, 'El nombre de la calle es requerido').max(100),
  streetNumber: z.string().min(1, 'El n√∫mero de la calle es requerido').max(10),
  apartment: z.string().max(20).optional(),
  latitude: z.number().min(-90).max(90).optional(),
  longitude: z.number().min(-180).max(180).optional(),
  isDefault: z.boolean().optional()
})

// Schema de validaci√≥n para actualizar direcci√≥n
const updateAddressSchema = z.object({
  id: z.number().positive('ID de direcci√≥n inv√°lido'),
  alias: z.string().min(1).max(50).optional(),
  department: z.string().min(1).optional(),
  province: z.string().min(1).optional(),
  district: z.string().min(1).optional(),
  streetName: z.string().min(1).max(100).optional(),
  streetNumber: z.string().min(1).max(10).optional(),
  apartment: z.string().max(20).optional(),
  latitude: z.number().min(-90).max(90).optional(),
  longitude: z.number().min(-180).max(180).optional()
})

export async function GET() {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'No autorizado' }, { status: 401 })
    }

    const addresses = await customerAddressModel.getAddressByCustomer(
      parseInt(session.user.id)
    )

    return NextResponse.json({
      addresses: addresses || []
    })
  } catch (error) {
    console.error('Error en GET /api/customer/addresses:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'No autorizado' }, { status: 401 })
    }

    const body = await request.json()

    // Validar datos con Zod
    try {
      const validatedData = createAddressSchema.parse(body)

      const newAddress = await customerAddressModel.createAddress({
        idCustomer: parseInt(session.user.id),
        alias: validatedData.alias,
        department: validatedData.department,
        province: validatedData.province,
        district: validatedData.district,
        streetName: validatedData.streetName,
        streetNumber: validatedData.streetNumber,
        apartment: validatedData.apartment,
        latitude: validatedData.latitude,
        longitude: validatedData.longitude,
        isDefault: validatedData.isDefault || false
      })

      if (!newAddress) {
        return NextResponse.json(
          { error: 'Error al crear la direcci√≥n' },
          { status: 500 }
        )
      }

      return NextResponse.json(
        {
          message: 'Direcci√≥n creada correctamente',
          address: newAddress
        },
        { status: 201 }
      )
    } catch (validationError) {
      if (validationError instanceof z.ZodError) {
        const errors = validationError.errors.map((err) => ({
          field: err.path.join('.'),
          message: err.message
        }))

        return NextResponse.json(
          {
            error: 'Datos de entrada inv√°lidos',
            details: errors
          },
          { status: 400 }
        )
      }
      throw validationError
    }
  } catch (error) {
    console.error('Error en POST /api/customer/addresses:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}

export async function PUT(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'No autorizado' }, { status: 401 })
    }

    const body = await request.json()

    // Validar datos con Zod
    try {
      const validatedData = updateAddressSchema.parse(body)
      const { id, ...updateData } = validatedData

      // Verificar que la direcci√≥n pertenece al usuario
      const existingAddress = await customerAddressModel.getAddress(id)
      if (
        !existingAddress ||
        existingAddress.idCustomer !== parseInt(session.user.id)
      ) {
        return NextResponse.json(
          { error: 'Direcci√≥n no encontrada o no autorizada' },
          { status: 404 }
        )
      }

      const updatedAddress = await customerAddressModel.updateAddress(
        id,
        updateData
      )

      if (!updatedAddress) {
        return NextResponse.json(
          { error: 'Error al actualizar la direcci√≥n' },
          { status: 500 }
        )
      }

      return NextResponse.json({
        message: 'Direcci√≥n actualizada correctamente',
        address: updatedAddress
      })
    } catch (validationError) {
      if (validationError instanceof z.ZodError) {
        const errors = validationError.errors.map((err) => ({
          field: err.path.join('.'),
          message: err.message
        }))

        return NextResponse.json(
          {
            error: 'Datos de entrada inv√°lidos',
            details: errors
          },
          { status: 400 }
        )
      }
      throw validationError
    }
  } catch (error) {
    console.error('Error en PUT /api/customer/addresses:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'No autorizado' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const idParam = searchParams.get('id')

    if (!idParam) {
      return NextResponse.json(
        { error: 'ID de direcci√≥n requerido' },
        { status: 400 }
      )
    }

    const id = parseInt(idParam)
    if (isNaN(id) || id <= 0) {
      return NextResponse.json(
        { error: 'ID de direcci√≥n inv√°lido' },
        { status: 400 }
      )
    }

    // Verificar que la direcci√≥n pertenece al usuario
    const existingAddress = await customerAddressModel.getAddress(id)
    if (
      !existingAddress ||
      existingAddress.idCustomer !== parseInt(session.user.id)
    ) {
      return NextResponse.json(
        { error: 'Direcci√≥n no encontrada o no autorizada' },
        { status: 404 }
      )
    }

    // Verificar si es la √∫nica direcci√≥n del usuario
    const userAddresses = await customerAddressModel.getAddressByCustomer(
      parseInt(session.user.id)
    )

    if (userAddresses && userAddresses.length === 1) {
      return NextResponse.json(
        { error: 'No puedes eliminar tu √∫nica direcci√≥n' },
        { status: 400 }
      )
    }

    // Verificar si es la direcci√≥n por defecto
    if (existingAddress.isDefault) {
      return NextResponse.json(
        {
          error:
            'No puedes eliminar la direcci√≥n por defecto. Establece otra direcci√≥n como predeterminada primero.'
        },
        { status: 400 }
      )
    }

    // Eliminar direcci√≥n (hard delete)
    await customerAddressModel.deleteAddress(id)

    return NextResponse.json({
      message: 'Direcci√≥n eliminada correctamente'
    })
  } catch (error) {
    console.error('Error en DELETE /api/customer/addresses:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}

export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'No autorizado' }, { status: 401 })
    }

    const body = await request.json()
    const { addressId } = body

    if (!addressId || typeof addressId !== 'number' || addressId <= 0) {
      return NextResponse.json(
        { error: 'ID de direcci√≥n requerido y v√°lido' },
        { status: 400 }
      )
    }

    // Verificar que la direcci√≥n pertenece al usuario
    const existingAddress = await customerAddressModel.getAddress(addressId)
    if (
      !existingAddress ||
      existingAddress.idCustomer !== parseInt(session.user.id)
    ) {
      return NextResponse.json(
        { error: 'Direcci√≥n no encontrada o no autorizada' },
        { status: 404 }
      )
    }

    // Verificar si ya es la direcci√≥n por defecto
    if (existingAddress.isDefault) {
      return NextResponse.json(
        { message: 'Esta direcci√≥n ya es la predeterminada' },
        { status: 200 }
      )
    }

    // Establecer como direcci√≥n por defecto
    await customerAddressModel.setDefaultAddress(
      parseInt(session.user.id),
      addressId
    )

    return NextResponse.json({
      message: 'Direcci√≥n por defecto actualizada'
    })
  } catch (error) {
    console.error('Error en PATCH /api/customer/addresses:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/customer/orders/[orderId]/route.ts
------------------------------------------------------------------------------------
// app/api/customer/orders/[orderId]/route.ts
import customerAddressModel from '@/backend/customer-address'
import orderModel from '@/backend/order'
import orderItemsModel from '@/backend/order-item'
import orderTrackingModel from '@/backend/order-tracking'
import { authOptions } from '@/lib/auth'
import { getServerSession } from 'next-auth'
import { type NextRequest, NextResponse } from 'next/server'

interface RouteParams {
  params: {
    orderId: string
  }
}

export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    // Verificar sesi√≥n
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'No autorizado' }, { status: 401 })
    }

    const customerId = parseInt(session.user.id)
    const orderId = parseInt(params.orderId)

    if (isNaN(orderId)) {
      return NextResponse.json(
        { error: 'ID de orden inv√°lido' },
        { status: 400 }
      )
    }

    // Obtener la orden
    const order = await orderModel.getOrderById(orderId)
    if (!order) {
      return NextResponse.json(
        { error: 'Orden no encontrada' },
        { status: 404 }
      )
    }

    // Verificar que la orden pertenece al cliente autenticado
    if (order.customerId !== customerId) {
      return NextResponse.json(
        { error: 'No tienes acceso a esta orden' },
        { status: 403 }
      )
    }

    // Obtener items de la orden
    const orderItems = await orderItemsModel.getOrderItemsByOrderId(orderId)

    // Obtener historial de seguimiento
    const trackingHistory = await orderTrackingModel.getTrackingHistory(orderId)

    // Obtener √∫ltimo seguimiento
    const latestTracking =
      await orderTrackingModel.getLatestTrackingByOrderId(orderId)

    // Obtener direcci√≥n de env√≠o
    let shippingAddress = null
    if (order.shippingAddressId) {
      shippingAddress = await customerAddressModel.getAddress(
        order.shippingAddressId
      )
    }

    // Formatear items de la orden
    const formattedItems =
      orderItems?.map((item) => ({
        id: item.id,
        productName: item.productName,
        variantSku: item.variantSku,
        variantAttributes: item.variantAttributes,
        quantity: item.quantity,
        unitPrice: item.unitPrice,
        totalPrice: item.totalPrice,
        discountAmount: item.discountAmount || 0
      })) || []

    // Formatear historial de seguimiento
    const formattedTrackingHistory =
      trackingHistory?.map((tracking) => ({
        id: tracking.id,
        status: tracking.status,
        currentLocation: tracking.currentLocation,
        courierCompany: tracking.courierCompany,
        trackingNumber: tracking.trackingNumber,
        deliveryNotes: tracking.deliveryNotes,
        createdAt: tracking.createdAt,
        shippedAt: tracking.shippedAt,
        deliveredAt: tracking.deliveredAt,
        deliveredTo: tracking.deliveredTo
      })) || []

    // Formatear direcci√≥n de env√≠o
    const formattedShippingAddress = shippingAddress
      ? {
          alias: shippingAddress.alias,
          streetName: shippingAddress.streetName,
          streetNumber: shippingAddress.streetNumber,
          apartment: shippingAddress.apartment,
          district: shippingAddress.district,
          province: shippingAddress.province,
          department: shippingAddress.department
        }
      : null

    // Calcular totales
    const subtotalCalculated = formattedItems.reduce(
      (sum, item) => sum + item.totalPrice,
      0
    )
    const totalDiscounts = formattedItems.reduce(
      (sum, item) => sum + item.discountAmount,
      0
    )

    const orderDetail = {
      // Informaci√≥n b√°sica de la orden
      id: order.id,
      orderNumber: order.orderNumber,
      status: order.status,
      paymentStatus: order.paymentStatus,
      paymentMethod: order.paymentMethod,
      createdAt: order.createdAt,
      paidAt: order.paidAt,

      // Fechas importantes
      estimatedDelivery: order.estimatedDelivery,

      // Montos
      subtotal: order.subtotal,
      discountAmount: order.discountAmount || 0,
      shippingCost: order.shippingCost || 0,
      taxAmount: order.taxAmount || 0,
      totalAmount: order.totalAmount,

      // Calculados
      subtotalCalculated,
      totalDiscounts,

      // Env√≠o
      shippingMethod: order.shippingMethod,
      shippingAddress: formattedShippingAddress,

      // Notas
      customerNotes: order.customerNotes,
      adminNotes: order.adminNotes,

      // Items
      items: formattedItems,
      itemCount: formattedItems.length,

      // Seguimiento
      trackingHistory: formattedTrackingHistory,
      latestTracking: latestTracking
        ? {
            status: latestTracking.status,
            currentLocation: latestTracking.currentLocation,
            courierCompany: latestTracking.courierCompany,
            trackingNumber: latestTracking.trackingNumber,
            deliveryNotes: latestTracking.deliveryNotes,
            updatedAt: latestTracking.updatedAt
          }
        : null,

      // Estados √∫tiles para UI
      canCancel: order.status === 'pending' || order.status === 'processing',
      hasTracking: trackingHistory && trackingHistory.length > 0,
      isDelivered: order.status === 'delivered',
      needsPayment:
        order.paymentStatus === 'pending' || order.paymentStatus === 'failed'
    }

    return NextResponse.json({ order: orderDetail })
  } catch (error) {
    console.error('Error en GET /api/customer/orders/[orderId]:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}

export async function PUT(request: NextRequest, { params }: RouteParams) {
  try {
    // Verificar sesi√≥n
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'No autorizado' }, { status: 401 })
    }

    const customerId = parseInt(session.user.id)
    const orderId = parseInt(params.orderId)

    if (isNaN(orderId)) {
      return NextResponse.json(
        { error: 'ID de orden inv√°lido' },
        { status: 400 }
      )
    }

    // Obtener datos del cuerpo de la petici√≥n
    const body = await request.json()
    const { action, customerNotes } = body

    // Obtener la orden
    const order = await orderModel.getOrderById(orderId)
    if (!order) {
      return NextResponse.json(
        { error: 'Orden no encontrada' },
        { status: 404 }
      )
    }

    // Verificar que la orden pertenece al cliente autenticado
    if (order.customerId !== customerId) {
      return NextResponse.json(
        { error: 'No tienes acceso a esta orden' },
        { status: 403 }
      )
    }

    let updatedOrder = null

    switch (action) {
      case 'cancel':
        // Solo se puede cancelar si est√° en pending o processing
        if (order.status !== 'pending' && order.status !== 'processing') {
          return NextResponse.json(
            { error: 'No se puede cancelar esta orden en su estado actual' },
            { status: 400 }
          )
        }

        updatedOrder = await orderModel.updateOrderStatus(
          orderId,
          'cancelled',
          `Cancelada por el cliente: ${customerNotes || 'Sin motivo especificado'}`
        )
        break

      case 'update_notes':
        // Actualizar notas del cliente
        updatedOrder = await orderModel.updateOrder({ customerNotes }, orderId)
        break

      default:
        return NextResponse.json({ error: 'Acci√≥n no v√°lida' }, { status: 400 })
    }

    if (!updatedOrder) {
      return NextResponse.json(
        { error: 'Error al actualizar la orden' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      message: 'Orden actualizada correctamente',
      order: {
        id: updatedOrder.id,
        status: updatedOrder.status,
        customerNotes: updatedOrder.customerNotes
      }
    })
  } catch (error) {
    console.error('Error en PUT /api/customer/orders/[orderId]:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/customer/orders/route.ts
------------------------------------------------------------------------------------
// app/api/customer/orders/route.ts
import orderModel from '@/backend/order'
import { authOptions } from '@/lib/auth'
import { getServerSession } from 'next-auth'
import { type NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  try {
    // Verificar sesi√≥n
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'No autorizado' }, { status: 401 })
    }

    const customerId = parseInt(session.user.id)

    // Obtener par√°metros de consulta opcionales
    const { searchParams } = new URL(request.url)
    const status = searchParams.get('status') // filtrar por estado
    const page = parseInt(searchParams.get('page') || '1')
    const limit = parseInt(searchParams.get('limit') || '10')

    let orders

    if (status) {
      // Si hay filtro por estado, obtener √≥rdenes por estado del cliente
      const allOrdersByStatus = await orderModel.getOrdersByStatus(status)
      orders =
        allOrdersByStatus?.filter((order) => order.customerId === customerId) ||
        []
    } else {
      // Obtener todas las √≥rdenes del cliente
      orders = await orderModel.getOrdersByCustomerId(customerId)
    }

    if (!orders || orders.length === 0) {
      return NextResponse.json({
        orders: [],
        pagination: {
          total: 0,
          page: 1,
          limit,
          totalPages: 0
        }
      })
    }

    // Ordenar por fecha de creaci√≥n (m√°s recientes primero)
    orders.sort(
      (a, b) =>
        new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    )

    // Implementar paginaci√≥n
    const total = orders.length
    const totalPages = Math.ceil(total / limit)
    const startIndex = (page - 1) * limit
    const endIndex = startIndex + limit
    const paginatedOrders = orders.slice(startIndex, endIndex)

    // Formatear las √≥rdenes para la respuesta
    const formattedOrders = paginatedOrders.map((order) => ({
      id: order.id,
      orderNumber: order.orderNumber,
      status: order.status,
      paymentStatus: order.paymentStatus,
      totalAmount: order.totalAmount,
      createdAt: order.createdAt,
      estimatedDelivery: order.estimatedDelivery,
      // Campos adicionales √∫tiles para la vista
      itemCount: order.orderItems?.length || 0,
      shippingMethod: order.shippingMethod,
      trackingAvailable:
        order.status === 'shipped' || order.status === 'delivered'
    }))

    return NextResponse.json({
      orders: formattedOrders,
      pagination: {
        total,
        page,
        limit,
        totalPages
      }
    })
  } catch (error) {
    console.error('Error en GET /api/customer/orders:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}



üìÅ ARCHIVO: src/app/api/customer/change-password/route.ts
------------------------------------------------------------------------------------
// app/api/customer/change-password/route.ts
import customerModel from '@/backend/customer'
import { authOptions } from '@/lib/auth'
import bcrypt from 'bcryptjs'
import { getServerSession } from 'next-auth'
import { type NextRequest, NextResponse } from 'next/server'

export async function PUT(request: NextRequest) {
  try {
    // Verificar sesi√≥n
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'No autorizado' }, { status: 401 })
    }

    // Obtener datos del cuerpo de la petici√≥n
    const body = await request.json()
    const { currentPassword, newPassword } = body

    // Validaciones b√°sicas
    if (!currentPassword || !newPassword) {
      return NextResponse.json(
        { error: 'La contrase√±a actual y nueva son requeridas' },
        { status: 400 }
      )
    }

    if (newPassword.length < 8) {
      return NextResponse.json(
        { error: 'La nueva contrase√±a debe tener al menos 8 caracteres' },
        { status: 400 }
      )
    }

    if (currentPassword === newPassword) {
      return NextResponse.json(
        { error: 'La nueva contrase√±a debe ser diferente a la actual' },
        { status: 400 }
      )
    }

    // Obtener el cliente actual con su contrase√±a
    const customer = await customerModel.getCustomer(parseInt(session.user.id))
    if (!customer) {
      return NextResponse.json(
        { error: 'Cliente no encontrado' },
        { status: 404 }
      )
    }

    // Verificar la contrase√±a actual
    const isCurrentPasswordValid = await bcrypt.compare(
      currentPassword,
      customer.password
    )
    if (!isCurrentPasswordValid) {
      return NextResponse.json(
        { error: 'La contrase√±a actual es incorrecta' },
        { status: 400 }
      )
    }

    // Encriptar la nueva contrase√±a
    const hashedNewPassword = await bcrypt.hash(newPassword, 12)

    // Actualizar la contrase√±a en la base de datos
    const updatedCustomer = await customerModel.updateCustomer(
      {
        password: hashedNewPassword
      },
      parseInt(session.user.id)
    )

    if (!updatedCustomer) {
      return NextResponse.json(
        { error: 'Error al actualizar la contrase√±a' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      message: 'Contrase√±a actualizada correctamente'
    })
  } catch (error) {
    console.error('Error en PUT /api/customer/change-password:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}

// M√©todo para verificar que solo se permite PUT
export async function GET() {
  return NextResponse.json({ error: 'M√©todo no permitido' }, { status: 405 })
}

export async function POST() {
  return NextResponse.json(
    { error: 'M√©todo no permitido. Use PUT' },
    { status: 405 }
  )
}

export async function DELETE() {
  return NextResponse.json({ error: 'M√©todo no permitido' }, { status: 405 })
}



üìÅ ARCHIVO: src/app/productos/variante/[id]/page.tsx
------------------------------------------------------------------------------------
import Header from '@/components/layout/Header'
import Layout from '@/components/layout/Layout'
import { LayoutContent } from '@/components/layout/LayoutContent'
import { ProductVariantNotFound } from '@/components/product/ProductVariantNotFound'
import ProductVariantView from '@/components/product/ProductVariantView'
import Navigation from '@/components/ui/Navigation'
import {
  generateErrorMetadata,
  generateProductVariantMetadata
} from '@/helpers/productVariant.helpers'
import { getHeader } from '@/services/header'
import ProductService from '@/services/product'
import { type Metadata } from 'next'

interface ProductVariantPageProps {
  params: Promise<{
    id: string
  }>
}

export async function generateMetadata({
  params
}: ProductVariantPageProps): Promise<Metadata> {
  try {
    const { id } = await params
    const variantId = parseInt(id)

    if (isNaN(variantId)) {
      return generateErrorMetadata('ID de variante inv√°lido')
    }

    const data = await ProductService.getProductVariant(variantId)
    return generateProductVariantMetadata(data, variantId)
  } catch (error) {
    console.error('Error generating metadata:', error)
    return generateErrorMetadata('Error al cargar el producto')
  }
}

export default async function ProductVariantPage({
  params
}: ProductVariantPageProps) {
  const { id } = await params
  const variantId = parseInt(id)

  // Validar ID
  if (isNaN(variantId)) {
    return <ProductVariantNotFound />
  }

  const data = await ProductService.getProductVariant(variantId)

  if (!data) {
    return <ProductVariantNotFound />
  }

  const allVariants = (data.product.productVariants || []).filter(
    (v) => v !== null
  )
  const variant = allVariants.find((variant) => variant.id === variantId)

  if (!variant) {
    return <ProductVariantNotFound />
  }

  const categories = await getHeader()

  return (
    <Layout>
      <Header navigationType="mini">
        <Navigation type="mini" categories={categories || []} />
      </Header>
      <LayoutContent>
        <ProductVariantView
          data={data}
          allVariants={allVariants}
          variant={variant}
        />
      </LayoutContent>
    </Layout>
  )
}



üìÅ ARCHIVO: src/app/orders/page.tsx
------------------------------------------------------------------------------------
import categoryModel from '@/backend/category'
import Header from '@/components/layout/Header'
import Layout from '@/components/layout/Layout'
import Navigation from '@/components/ui/Navigation'
import { AlertCircle, CheckCircle, Clock, Package } from 'lucide-react'
import { getServerSession } from 'next-auth'
import { redirect } from 'next/navigation'

// Datos de ejemplo para pedidos
const mockOrders = [
  {
    id: 'ORD-12345',
    date: '15 Mayo, 2025',
    total: 1250.0,
    status: 'Entregado',
    items: 3
  },
  {
    id: 'ORD-12346',
    date: '10 Mayo, 2025',
    total: 850.5,
    status: 'En camino',
    items: 2
  },
  {
    id: 'ORD-12347',
    date: '5 Mayo, 2025',
    total: 1500.0,
    status: 'Procesando',
    items: 4
  },
  {
    id: 'ORD-12348',
    date: '1 Mayo, 2025',
    total: 350.0,
    status: 'Cancelado',
    items: 1
  }
]

// Funci√≥n para obtener el icono seg√∫n el estado del pedido
const getStatusIcon = (status: string) => {
  switch (status) {
    case 'Entregado':
      return <CheckCircle className="h-5 w-5 text-green-500" />
    case 'En camino':
      return <Package className="h-5 w-5 text-blue-500" />
    case 'Procesando':
      return <Clock className="h-5 w-5 text-yellow-500" />
    case 'Cancelado':
      return <AlertCircle className="h-5 w-5 text-red-500" />
    default:
      return <Package className="h-5 w-5 text-gray-500" />
  }
}

export default async function OrdersPage() {
  // Obtener la sesi√≥n del usuario
  const session = await getServerSession()

  // Si no hay sesi√≥n, redirigir al inicio
  // Esto es una doble verificaci√≥n, ya que el middleware deber√≠a manejar esto
  if (!session) {
    redirect('/')
  }

  // Obtener datos para el header y footer
  const categories = await categoryModel.getCategories()

  return (
    <Layout>
      <Header navigationType="mini">
        <Navigation type="mini" categories={categories || []} />
      </Header>

      <main className="mx-auto max-w-7xl px-4 py-8">
        <h1 className="mb-6 text-3xl font-bold">Mis Pedidos</h1>

        <div className="overflow-hidden rounded-lg bg-white shadow-md">
          {mockOrders.length > 0 ? (
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                      Pedido
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                      Fecha
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                      Productos
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                      Total
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                      Estado
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                      Acciones
                    </th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-gray-200 bg-white">
                  {mockOrders.map((order) => (
                    <tr key={order.id} className="hover:bg-gray-50">
                      <td className="whitespace-nowrap px-6 py-4 text-sm font-medium text-gray-900">
                        {order.id}
                      </td>
                      <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                        {order.date}
                      </td>
                      <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                        {order.items}{' '}
                        {order.items === 1 ? 'producto' : 'productos'}
                      </td>
                      <td className="whitespace-nowrap px-6 py-4 text-sm font-medium text-gray-900">
                        S/ {order.total.toFixed(2)}
                      </td>
                      <td className="whitespace-nowrap px-6 py-4">
                        <div className="flex items-center">
                          {getStatusIcon(order.status)}
                          <span className="ml-2 text-sm text-gray-700">
                            {order.status}
                          </span>
                        </div>
                      </td>
                      <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                        <button className="text-primary hover:text-primary/80">
                          Ver detalles
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          ) : (
            <div className="p-8 text-center">
              <Package className="mx-auto mb-4 h-12 w-12 text-gray-400" />
              <h3 className="mb-2 text-lg font-medium text-gray-900">
                No tienes pedidos
              </h3>
              <p className="mb-4 text-gray-500">
                Cuando realices compras, tus pedidos aparecer√°n aqu√≠.
              </p>
              <button className="inline-flex items-center rounded-md border border-transparent bg-primary px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2">
                Explorar productos
              </button>
            </div>
          )}
        </div>
      </main>
    </Layout>
  )
}



üìÅ ARCHIVO: src/app/account/edit-profile/page.tsx
------------------------------------------------------------------------------------
// app/account/edit-profile/page.tsx
import categoryModel from '@/backend/category'
import customerModel from '@/backend/customer'
import AccountLayout from '@/components/account/AccountLayout'
import EditProfile from '@/components/account/EditProfile/EditProfile'
import Header from '@/components/layout/Header'
import Layout from '@/components/layout/Layout'
import { LayoutContent } from '@/components/layout/LayoutContent'
import Navigation from '@/components/ui/Navigation'
import { authOptions } from '@/lib/auth' // IMPORTANTE: Importar authOptions
import { getServerSession } from 'next-auth'
import { redirect } from 'next/navigation'

export default async function EditProfilePage() {
  // Obtener la sesi√≥n del usuario
  const session = await getServerSession(authOptions)

  // Si no hay sesi√≥n, redirigir al inicio
  if (!session) {
    redirect('/')
  }

  // Obtener datos para el header y footer
  const categories = await categoryModel.getCategories()
  const customer = await customerModel.getCustomer(Number(session.user.id))

  if (!customer) {
    return
  }

  return (
    <Layout>
      <Header navigationType="mini">
        <Navigation type="mini" categories={categories || []} />
      </Header>
      <LayoutContent className="p-0">
        <AccountLayout userName={session.user?.name || ''}>
          <EditProfile customer={customer} />
        </AccountLayout>
      </LayoutContent>
    </Layout>
  )
}



üìÅ ARCHIVO: src/app/account/addresses/page.tsx
------------------------------------------------------------------------------------
// app/account/addresses/page.tsx
import categoryModel from '@/backend/category'
import customerAddressModel from '@/backend/customer-address'
import AccountLayout from '@/components/account/AccountLayout'
import Addresses from '@/components/account/Addresses/Addresses'
import Header from '@/components/layout/Header'
import Layout from '@/components/layout/Layout'
import { LayoutContent } from '@/components/layout/LayoutContent'
import Navigation from '@/components/ui/Navigation'
import { authOptions } from '@/lib/auth'
import { getServerSession } from 'next-auth'
import { redirect } from 'next/navigation'

export default async function AddressesPage() {
  // Obtener la sesi√≥n del usuario
  const session = await getServerSession(authOptions)

  // Si no hay sesi√≥n, redirigir al inicio
  if (!session) {
    redirect('/')
  }

  // Obtener datos para el header y footer
  const categories = await categoryModel.getCategories()
  let customerAddresses = await customerAddressModel.getAddressByCustomer(
    Number(session.user.id)
  )
  if (!customerAddresses) {
    customerAddresses = []
  }

  return (
    <Layout>
      <Header navigationType="mini">
        <Navigation type="mini" categories={categories || []} />
      </Header>
      <LayoutContent className="p-0">
        <AccountLayout userName={session.user?.name || ''}>
          <Addresses initialAddresses={customerAddresses} />
        </AccountLayout>
      </LayoutContent>
    </Layout>
  )
}



üìÅ ARCHIVO: src/app/account/orders/[id]/page.tsx
------------------------------------------------------------------------------------
// app/account/orders/[orderId]/page.tsx
import categoryModel from '@/backend/category'
import AccountLayout from '@/components/account/AccountLayout'
import OrderDetail from '@/components/account/OrderDetail'
import Header from '@/components/layout/Header'
import Layout from '@/components/layout/Layout'
import { LayoutContent } from '@/components/layout/LayoutContent'
import Navigation from '@/components/ui/Navigation'
import { authOptions } from '@/lib/auth'
import { getServerSession } from 'next-auth'
import { redirect } from 'next/navigation'

interface OrderDetailPageProps {
  params: {
    id: string
  }
}

export default async function OrderDetailPage({
  params
}: OrderDetailPageProps) {
  // Obtener la sesi√≥n del usuario
  const session = await getServerSession(authOptions)

  // Si no hay sesi√≥n, redirigir al inicio
  if (!session) {
    redirect('/')
  }

  // Validar que el orderId sea un n√∫mero
  const id = parseInt(params.id)
  if (isNaN(id)) {
    redirect('/account/orders')
  }

  // Obtener datos para el header y footer
  const categories = await categoryModel.getCategories()

  return (
    <Layout>
      <Header navigationType="mini">
        <Navigation type="mini" categories={categories || []} />
      </Header>
      <LayoutContent className="p-0">
        <AccountLayout userName={session.user?.name || ''}>
          <OrderDetail orderId={params.id} />
        </AccountLayout>
      </LayoutContent>
    </Layout>
  )
}



üìÅ ARCHIVO: src/app/account/orders/page.tsx
------------------------------------------------------------------------------------
// app/account/orders/page.tsx
import categoryModel from '@/backend/category'
import AccountLayout from '@/components/account/AccountLayout'
import OrdersList from '@/components/account/OrderList'
import Header from '@/components/layout/Header'
import Layout from '@/components/layout/Layout'
import { LayoutContent } from '@/components/layout/LayoutContent'
import Navigation from '@/components/ui/Navigation'
import { getServerSession } from 'next-auth'
import { redirect } from 'next/navigation'

export default async function OrdersPage() {
  // Obtener la sesi√≥n del usuario
  const session = await getServerSession()

  // Si no hay sesi√≥n, redirigir al inicio
  if (!session) {
    redirect('/')
  }

  // Obtener datos para el header y footer
  const categories = await categoryModel.getCategories()

  return (
    <Layout>
      <Header navigationType="mini">
        <Navigation type="mini" categories={categories || []} />
      </Header>
      <LayoutContent className="p-0">
        <AccountLayout userName={session.user?.name || ''}>
          <OrdersList />
        </AccountLayout>
      </LayoutContent>
    </Layout>
  )
}



üìÅ ARCHIVO: src/app/account/page.tsx
------------------------------------------------------------------------------------
import categoryModel from '@/backend/category'
import customerModel from '@/backend/customer'
import AccountHome from '@/components/account/AccountHome'
import AccountLayout from '@/components/account/AccountLayout'
import Header from '@/components/layout/Header'
import Layout from '@/components/layout/Layout'
import { LayoutContent } from '@/components/layout/LayoutContent'
import Navigation from '@/components/ui/Navigation'
import { authOptions } from '@/lib/auth'
import { getServerSession } from 'next-auth'
import { redirect } from 'next/navigation'

export default async function AccountPage() {
  // Obtener la sesi√≥n del usuario
  const session = await getServerSession(authOptions)

  // Si no hay sesi√≥n, redirigir al inicio
  // Esto es una doble verificaci√≥n, ya que el middleware deber√≠a manejar esto
  if (!session) {
    redirect('/')
  }

  // Obtener datos para el header y footer
  const categories = await categoryModel.getCategories()
  const customer = await customerModel.getCustomer(Number(session.user.id))

  if (!customer) {
    return
  }

  return (
    <Layout>
      <Header navigationType="mini">
        <Navigation type="mini" categories={categories || []} />
      </Header>
      <LayoutContent className="p-0">
        <AccountLayout userName={session.user?.name || ''}>
          <AccountHome />
        </AccountLayout>
      </LayoutContent>
    </Layout>
  )
}



üìÅ ARCHIVO: src/app/account/change-password/page.tsx
------------------------------------------------------------------------------------
// app/account/change-password/page.tsx
import categoryModel from '@/backend/category'
import AccountLayout from '@/components/account/AccountLayout'
import ChangePassword from '@/components/account/ChangePassword/ChangePassword'
import Header from '@/components/layout/Header'
import Layout from '@/components/layout/Layout'
import { LayoutContent } from '@/components/layout/LayoutContent'
import Navigation from '@/components/ui/Navigation'
import { getServerSession } from 'next-auth'
import { redirect } from 'next/navigation'

export default async function ChangePasswordPage() {
  // Obtener la sesi√≥n del usuario
  const session = await getServerSession()

  // Si no hay sesi√≥n, redirigir al inicio
  if (!session) {
    redirect('/')
  }

  // Obtener datos para el header y footer
  const categories = await categoryModel.getCategories()

  return (
    <Layout>
      <Header navigationType="mini">
        <Navigation type="mini" categories={categories || []} />
      </Header>
      <LayoutContent className="p-0">
        <AccountLayout userName={session.user?.name || ''}>
          <ChangePassword />
        </AccountLayout>
      </LayoutContent>
    </Layout>
  )
}



üìÅ ARCHIVO: src/app/page.tsx
------------------------------------------------------------------------------------
import categoryModel from '@/backend/category'
import Header from '@/components/layout/Header'
import Layout from '@/components/layout/Layout'
import { LayoutContent } from '@/components/layout/LayoutContent'
import Categories from '@/components/sections/Categories'
import DailyDeals from '@/components/sections/DailyDeals'
import FeaturedCategories from '@/components/sections/FeaturedCategories'
import Features from '@/components/sections/Features'
import HeroSlider from '@/components/sections/HeroSlider'
import Newsletter from '@/components/sections/Newsletter'
import PopularProducts from '@/components/sections/PopularProducts'
import Navigation from '@/components/ui/Navigation'

// services
import { getBanner } from '@/services/banner'
import { getDealsProducts } from '@/services/dealsProducts'
import { getFeaturedCategories } from '@/services/featuredCategories'
import { getFeatures } from '@/services/features/features'
import { getHero } from '@/services/hero'
import { getMainCategories } from '@/services/mainCategories'
import { getPopularProducts } from '@/services/popularProducts'
import { type Metadata } from 'next'

export const metadata: Metadata = {
  title: 'TechStore - Tu tienda de tecnolog√≠a y zapatillas',
  description:
    'Encuentra los mejores productos de tecnolog√≠a y zapatillas en TechStore'
}

export default async function HomePage() {
  const mainCategories = await getMainCategories()
  const popularProducts = await getPopularProducts()
  const dealsProducts = await getDealsProducts()
  const hero = await getHero()
  const banners = await getBanner()
  const features = await getFeatures()
  const featureCategories = await getFeaturedCategories()
  const categories = await categoryModel.getCategories()

  return (
    <Layout>
      <Header>
        <Navigation categories={categories || []} />
      </Header>
      <LayoutContent className="py-0">
        <HeroSlider slides={hero} sideBanners={banners} />
        <Features features={features} />
        <Categories categories={mainCategories} />
        <FeaturedCategories categories={featureCategories} />
        <PopularProducts products={popularProducts} />
        <DailyDeals products={dealsProducts} />
        <Newsletter />
      </LayoutContent>
    </Layout>
  )
}



üìÅ ARCHIVO: src/config/tailwind.theme.config.ts
------------------------------------------------------------------------------------
import type { Config } from 'tailwindcss'

// Funci√≥n para generar variaciones de un color base
function generateColorVariations(baseColor: string) {
  // Funci√≥n auxiliar para mezclar colores (simula color-mix)
  function mixColor(color: string, mixWith: string, amount: number): string {
    // Convertir color hexadecimal a componentes RGB
    const parseHex = (hex: string): [number, number, number] => {
      const r = parseInt(hex.slice(1, 3), 16)
      const g = parseInt(hex.slice(3, 5), 16)
      const b = parseInt(hex.slice(5, 7), 16)
      return [r, g, b]
    }

    // Convertir RGB a hexadecimal
    const toHex = (r: number, g: number, b: number): string => {
      return `#${Math.round(r).toString(16).padStart(2, '0')}${Math.round(g)
        .toString(16)
        .padStart(2, '0')}${Math.round(b).toString(16).padStart(2, '0')}`
    }

    // Obtener componentes RGB
    const [r1, g1, b1] = parseHex(color)
    const [r2, g2, b2] = parseHex(mixWith)

    // Mezclar colores seg√∫n el porcentaje
    const r = r1 * (1 - amount) + r2 * amount
    const g = g1 * (1 - amount) + g2 * amount
    const b = b1 * (1 - amount) + b2 * amount

    return toHex(r, g, b)
  }

  // Crear variaciones mezclando con blanco (m√°s claro) y negro (m√°s oscuro)
  return {
    DEFAULT: baseColor,
    50: mixColor(baseColor, '#FFFFFF', 0.95), // 95% blanco
    100: mixColor(baseColor, '#FFFFFF', 0.9), // 90% blanco
    200: mixColor(baseColor, '#FFFFFF', 0.8), // 80% blanco
    300: mixColor(baseColor, '#FFFFFF', 0.7), // 70% blanco
    400: mixColor(baseColor, '#FFFFFF', 0.4), // 40% blanco
    500: baseColor, // Color base
    600: mixColor(baseColor, '#000000', 0.1), // 10% negro
    700: mixColor(baseColor, '#000000', 0.2), // 20% negro
    800: mixColor(baseColor, '#000000', 0.3), // 30% negro
    900: mixColor(baseColor, '#000000', 0.4), // 40% negro
    950: mixColor(baseColor, '#000000', 0.5) // 50% negro
  }
}

export const themes = {
  'modern-ecommerce': {
    colors: {
      primary: generateColorVariations('#334155'),
      secondary: generateColorVariations('#4A3AD7'),
      accent: generateColorVariations('#22C55E')
    },
    borderRadius: {
      small: '0.25rem',
      medium: '0.5rem',
      large: '1rem'
    },
    fontSizes: {
      small: '0.875rem',
      medium: '1rem',
      large: '1.25rem',
      xlarge: '1.5rem',
      xxlarge: '2rem'
    },
    spacing: {
      small: '0.5rem',
      medium: '1rem',
      large: '1.5rem',
      xlarge: '2rem'
    }
  }
  // Puedes agregar m√°s temas aqu√≠
}

export type ThemeName = keyof typeof themes

// Crear un preset de Tailwind para el tema actual
export function createTailwindPreset(themeName: ThemeName): Partial<Config> {
  const theme = themes[themeName]

  return {
    theme: {
      extend: {
        fontFamily: {
          roboto: ['var(--font-roboto)'],
          'open-sans': ['var(--font-open-sans)']
        },
        colors: {
          primary: theme.colors.primary,
          secondary: theme.colors.secondary,
          accent: theme.colors.accent
        },
        borderRadius: {
          sm: theme.borderRadius.small,
          md: theme.borderRadius.medium,
          lg: theme.borderRadius.large
        },
        fontSize: {
          sm: theme.fontSizes.small,
          base: theme.fontSizes.medium,
          lg: theme.fontSizes.large,
          xl: theme.fontSizes.xlarge,
          '2xl': theme.fontSizes.xxlarge
        },
        spacing: {
          sm: theme.spacing.small,
          md: theme.spacing.medium,
          lg: theme.spacing.large,
          xl: theme.spacing.xlarge
        },
        screens: {
          '3xl': '1700px', // 5x5 grid
          '4xl': '1920px' // 6x6 grid
        }
      }
    }
  }
}



üìÅ ARCHIVO: src/config/index.ts
------------------------------------------------------------------------------------
import { type ThemeName } from './tailwind.theme.config'

export const siteConfig = {
  name: 'TechStore',
  description: 'Tu tienda de tecnolog√≠a y zapatillas',
  url: 'https://techstore.com',
  ogImage: 'https://techstore.com/og.jpg',
  links: {
    twitter: 'https://twitter.com/techstore',
    github: 'https://github.com/techstore'
  },
  contact: {
    email: 'info@techstore.com',
    phone: '+1 1800 900',
    address: 'Av. Javier Prado Este 123, Lima, Per√∫'
  },
  theme: 'modern-ecommerce' as ThemeName
}



üìÅ ARCHIVO: src/constants/search.constants.ts
------------------------------------------------------------------------------------
export const SEARCH_INITIAL_PAGE = 1
export const SEARCH_PRODUCTS_PER_PAGE = 12



üìÅ ARCHIVO: src/providers/theme/use-theme.hook.ts
------------------------------------------------------------------------------------
import { useContext } from 'react'
import { ThemeContext } from './Theme.context'

export function useTheme() {
  const context = useContext(ThemeContext)
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider')
  }
  return context
}



üìÅ ARCHIVO: src/providers/theme/Theme.context.ts
------------------------------------------------------------------------------------
import { createContext } from 'react'
import { type ThemeContextType } from './Theme.types'

export const ThemeContext = createContext<ThemeContextType | undefined>(
  undefined
)



üìÅ ARCHIVO: src/providers/theme/ThemeProvider.tsx
------------------------------------------------------------------------------------
'use client'
import React, { useEffect, useState } from 'react'
import { ThemeContext } from './Theme.context'
import { type Theme } from './Theme.types'

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<Theme>('system')
  const [isDarkMode, setIsDarkMode] = useState(false)

  // Cargar el tema desde localStorage al iniciar
  useEffect(() => {
    const savedTheme = localStorage.getItem('theme') as Theme | null
    if (savedTheme) {
      setTheme(savedTheme)
    }
  }, [])

  // Aplicar el tema cuando cambia
  useEffect(() => {
    localStorage.setItem('theme', theme)

    // Determinar si se debe usar el modo oscuro
    const root = window.document.documentElement
    root.classList.remove('light', 'dark')

    if (theme === 'system') {
      const systemTheme = window.matchMedia('(prefers-color-scheme: dark)')
        .matches
        ? 'dark'
        : 'light'
      root.classList.add(systemTheme)
      setIsDarkMode(systemTheme === 'dark')
    } else {
      root.classList.add(theme)
      setIsDarkMode(theme === 'dark')
    }
  }, [theme])

  // Escuchar cambios en el tema del sistema
  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')

    const handleChange = () => {
      if (theme === 'system') {
        const systemTheme = mediaQuery.matches ? 'dark' : 'light'
        document.documentElement.classList.remove('light', 'dark')
        document.documentElement.classList.add(systemTheme)
        setIsDarkMode(systemTheme === 'dark')
      }
    }

    mediaQuery.addEventListener('change', handleChange)
    return () => { mediaQuery.removeEventListener('change', handleChange) }
  }, [theme])

  const value = {
    theme,
    setTheme,
    isDarkMode
  }

  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>
}



üìÅ ARCHIVO: src/providers/theme/index.ts
------------------------------------------------------------------------------------
export type { ThemeContextType } from './Theme.types'
export { ThemeProvider } from './ThemeProvider'
export { useTheme } from './use-theme.hook'



üìÅ ARCHIVO: src/providers/theme/Theme.types.ts
------------------------------------------------------------------------------------
export type Theme = 'light' | 'dark' | 'system'

export interface ThemeContextType {
  theme: Theme
  setTheme: (theme: Theme) => void
  isDarkMode: boolean
}



üìÅ ARCHIVO: src/providers/cart/CartProvider.tsx
------------------------------------------------------------------------------------
'use client'
import { useCart } from '@/hooks/useCart'
import { CartContext } from './Cart.context'

export function CartProvider({ children }: { children: React.ReactNode }) {
  // Simplemente usar el hook y pasar todo el valor
  const cartValue = useCart()

  return (
    <CartContext.Provider value={cartValue}>{children}</CartContext.Provider>
  )
}



üìÅ ARCHIVO: src/providers/cart/Cart.context.ts
------------------------------------------------------------------------------------
import { createContext } from 'react'
import { type CartContextProps } from './Cart.types'

export const CartContext = createContext<CartContextProps | undefined>(
  undefined
)



üìÅ ARCHIVO: src/providers/cart/use-cart.hook.ts
------------------------------------------------------------------------------------
import { useContext } from 'react'
import { CartContext } from './Cart.context'

export function useCartContext() {
  const context = useContext(CartContext)
  if (context === undefined) {
    throw new Error('useCartContext must be used within a CartProvider')
  }
  return context
}



üìÅ ARCHIVO: src/providers/cart/Cart.types.ts
------------------------------------------------------------------------------------
import type useCart from '@/hooks/useCart'
export type CartContextProps = ReturnType<typeof useCart>



üìÅ ARCHIVO: src/providers/cart/index.ts
------------------------------------------------------------------------------------
export type { CartContextProps } from './Cart.types'
export { CartProvider } from './CartProvider'
export { useCartContext } from './use-cart.hook'



üìÅ ARCHIVO: src/providers/auth-modal/AuthModal.context.ts
------------------------------------------------------------------------------------
import { createContext } from 'react'
import { type AuthModalContextType } from './AuthModal.types'

export const AuthModalContext = createContext<AuthModalContextType | undefined>(
  undefined
)



üìÅ ARCHIVO: src/providers/auth-modal/AuthModal.types.ts
------------------------------------------------------------------------------------
// types/auth-modal.ts
export interface AuthCallbacks {
  onLoginSuccess?: () => void
  onRegisterSuccess?: () => void
  onClose?: () => void
}

export interface AuthModalContextType {
  openLogin: (callbacks?: AuthCallbacks) => void
  openRegister: (callbacks?: AuthCallbacks) => void
}



üìÅ ARCHIVO: src/providers/auth-modal/AuthModalProvider.tsx
------------------------------------------------------------------------------------
'use client'
import { AuthModals } from '@/components/auth/AuthModals'
import React, { useState } from 'react'
import { AuthModalContext } from './AuthModal.context'
import { type AuthCallbacks } from './AuthModal.types'

interface AuthModalProviderProps {
  children: React.ReactNode
}

export function AuthModalProvider({ children }: AuthModalProviderProps) {
  const [isLoginOpen, setIsLoginOpen] = useState(false)
  const [isRegisterOpen, setIsRegisterOpen] = useState(false)
  const [currentCallbacks, setCurrentCallbacks] = useState<AuthCallbacks>({})

  const openLogin = (callbacks: AuthCallbacks = {}) => {
    console.log(
      'üîê Opening login modal with callbacks:',
      Object.keys(callbacks)
    )
    setCurrentCallbacks(callbacks)
    setIsLoginOpen(true)
    setIsRegisterOpen(false)
  }

  const openRegister = (callbacks: AuthCallbacks = {}) => {
    console.log(
      'üìù Opening register modal with callbacks:',
      Object.keys(callbacks)
    )
    setCurrentCallbacks(callbacks)
    setIsRegisterOpen(true)
    setIsLoginOpen(false)
  }

  const closeAll = () => {
    console.log('‚ùå Closing all auth modals')
    setIsLoginOpen(false)
    setIsRegisterOpen(false)

    // Ejecutar callback de cierre si existe
    if (currentCallbacks.onClose) {
      console.log('üîÑ Executing onClose callback')
      currentCallbacks.onClose()
    }

    setCurrentCallbacks({})
  }

  const switchToRegister = () => {
    console.log('üîÑ Switching to register')
    setIsLoginOpen(false)
    setIsRegisterOpen(true)
  }

  const switchToLogin = () => {
    console.log('üîÑ Switching to login')
    setIsRegisterOpen(false)
    setIsLoginOpen(true)
  }

  const handleLoginSuccess = () => {
    console.log('‚úÖ Login successful')
    setIsLoginOpen(false)

    // Ejecutar callback de √©xito de login si existe
    if (currentCallbacks.onLoginSuccess) {
      console.log('üéØ Executing onLoginSuccess callback')
      currentCallbacks.onLoginSuccess()
    }

    setCurrentCallbacks({})
  }

  const handleRegisterSuccess = () => {
    console.log('‚úÖ Register successful')
    setIsRegisterOpen(false)

    // Ejecutar callback de √©xito de registro si existe
    if (currentCallbacks.onRegisterSuccess) {
      console.log('üéØ Executing onRegisterSuccess callback')
      currentCallbacks.onRegisterSuccess()
    }

    setCurrentCallbacks({})
  }

  return (
    <AuthModalContext.Provider value={{ openLogin, openRegister }}>
      {children}

      {/* üëà MODAL DE LOGIN - Usando tu Modal con Portal */}
      <AuthModals
        closeAll={closeAll}
        isLoginOpen={isLoginOpen}
        isRegisterOpen={isRegisterOpen}
        onLoginSuccess={handleLoginSuccess}
        onRegisterSuccess={handleRegisterSuccess}
        onSwitchToRegister={switchToRegister}
        onSwitchToLogin={switchToLogin}
      />
    </AuthModalContext.Provider>
  )
}



üìÅ ARCHIVO: src/providers/auth-modal/use-auth-modal.hook.ts
------------------------------------------------------------------------------------
// hooks/useAuthModal.ts
import { useContext } from 'react'
import { AuthModalContext } from './AuthModal.context'

export function useAuthModal() {
  const context = useContext(AuthModalContext)
  if (context === undefined) {
    throw new Error('useAuthModal must be used within an AuthModalProvider')
  }
  return context
}



üìÅ ARCHIVO: src/providers/auth-modal/index.ts
------------------------------------------------------------------------------------
export type { AuthCallbacks, AuthModalContextType } from './AuthModal.types'
export { AuthModalProvider } from './AuthModalProvider'
export { useAuthModal } from './use-auth-modal.hook'



üìÅ ARCHIVO: src/providers/Providers.tsx
------------------------------------------------------------------------------------
'use client'
import MiniCart from '@/components/ui/MiniCart'
import { AuthModalProvider } from '@/providers/auth-modal'
import { SessionProvider } from 'next-auth/react'
import { type ReactNode } from 'react'
import { CartProvider } from './cart/CartProvider'
import { ThemeProvider } from './theme/ThemeProvider'

interface ProvidersProps {
  children: ReactNode
}

export function Providers({ children }: ProvidersProps) {
  return (
    <ThemeProvider>
      <SessionProvider>
        <AuthModalProvider>
          <CartProvider>
            <main>
              {children}
              <MiniCart />
            </main>
          </CartProvider>
        </AuthModalProvider>
      </SessionProvider>
    </ThemeProvider>
  )
}



üìÅ ARCHIVO: src/backend/promotion/Promotion.mapper.ts
------------------------------------------------------------------------------------
import { type Promotions as PromotionRaw } from '@/types/database'
import { type Promotions as Promotion } from '@/types/domain'

export const PromotionMapper = (data: PromotionRaw): Promotion => {
  return {
    id: data.id,
    name: data.name,
    description: data.description,
    createdAt: data.created_at,
    discountType: data.discount_type,
    discountValue: data.discount_value,
    endDate: data.end_date,
    startDate: data.start_date,
    updatedAt: data.updated_at,
    isActive: data.is_active,
    minPurchaseAmount: data.min_purchase_amount,
    promotionVariants: undefined
  }
}

export const PromotionsMapper = (
  data: PromotionRaw[] | null
): Promotion[] | undefined => {
  if (data === null) return undefined
  return data.map(PromotionMapper)
}



üìÅ ARCHIVO: src/backend/promotion/Promotion.model.ts
------------------------------------------------------------------------------------
import { type Promotions as PromotionRaw } from '@/types/database'
import { type Promotions as Promotion } from '@/types/domain'

// me
import { PromotionMapper, PromotionsMapper } from './Promotion.mapper'
import oPromotionRep from './Promotion.repository'

export class PromotionModel {
  public async getPromotions(): Promise<Promotion[] | undefined> {
    const brandsRaw = await oPromotionRep.getPromotions()
    return PromotionsMapper(brandsRaw)
  }

  public async getPromotionById(id: number): Promise<Promotion | undefined> {
    const brandRaw = await oPromotionRep.getPromotionById(id)
    if (!brandRaw) return undefined
    return PromotionMapper(brandRaw)
  }

  public async createPromotion(
    brandData: Omit<PromotionRaw, 'id'>
  ): Promise<Promotion | undefined> {
    const created = await oPromotionRep.createPromotion(brandData)
    if (!created) return undefined
    return PromotionMapper(created)
  }

  public async updatePromotion(
    brandData: Omit<PromotionRaw, 'id'>,
    id: number
  ): Promise<Promotion | undefined> {
    const updated = await oPromotionRep.updatePromotion(brandData, id)
    if (!updated) return undefined
    return PromotionMapper(updated)
  }

  public async deletePromotion(id: number): Promise<void> {
    await oPromotionRep.deletePromotion(id)
  }
}

const promotionModel = new PromotionModel()
export default promotionModel



üìÅ ARCHIVO: src/backend/promotion/index.ts
------------------------------------------------------------------------------------
export * from './Promotion.mapper'
export { default } from './Promotion.model'
export * from './Promotion.repository'



üìÅ ARCHIVO: src/backend/promotion/Promotion.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type Promotions as PromotionRaw } from '@/types/database'

export class PromotionRepository {
  public async getPromotions(): Promise<PromotionRaw[] | null> {
    const promotions = await executeQuery<PromotionRaw[]>({
      query: 'SELECT * FROM promotions'
    })

    if (promotions.length === 0) return null
    return promotions
  }

  public async getPromotionById(id: number): Promise<PromotionRaw | null> {
    const promotions = await executeQuery<PromotionRaw[]>({
      query: 'SELECT * FROM promotions WHERE id = ?',
      values: [id]
    })

    if (promotions.length === 0) return null
    return promotions[0]
  }

  public async createPromotion(
    promotion: Omit<PromotionRaw, 'id'>
  ): Promise<PromotionRaw | null> {
    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO promotions SET ?',
      values: [promotion]
    })

    return await this.getPromotionById(result.insertId)
  }

  public async updatePromotion(
    promotionData: Omit<PromotionRaw, 'id'>,
    id: number
  ): Promise<PromotionRaw | null> {
    await executeQuery({
      query: 'UPDATE promotions SET ? WHERE id=?',
      values: [promotionData, id]
    })

    return await this.getPromotionById(id)
  }

  public async deletePromotion(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM promotions WHERE id=?',
      values: [id]
    })
  }
}

const promotionRepository = new PromotionRepository()
export default promotionRepository



üìÅ ARCHIVO: src/backend/order/Order.mapper.ts
------------------------------------------------------------------------------------
import { type Orders as OrdersRaw } from '@/types/database'
import { type Orders as Order } from '@/types/domain'

export const OrderMapper = (orderRaw: OrdersRaw): Order => {
  return {
    id: orderRaw.id,
    customerId: orderRaw.customer_id,
    orderNumber: orderRaw.order_number,
    status: orderRaw.status,
    createdAt: orderRaw.created_at,
    updatedAt: orderRaw.updated_at,

    // Montos
    subtotal: Number(orderRaw.subtotal),
    discountAmount: Number(orderRaw.discount_amount),
    shippingCost: Number(orderRaw.shipping_cost),
    taxAmount: Number(orderRaw.tax_amount),
    totalAmount: Number(orderRaw.total_amount),

    // Informaci√≥n de env√≠o
    shippingAddressId: orderRaw.shipping_address_id,
    shippingMethod: orderRaw.shipping_method,
    estimatedDelivery: orderRaw.estimated_delivery,

    // Informaci√≥n de pago
    paymentMethod: orderRaw.payment_method,
    paymentStatus: orderRaw.payment_status,
    paidAt: orderRaw.paid_at,

    // Notas
    customerNotes: orderRaw.customer_notes,
    adminNotes: orderRaw.admin_notes
  }
}

export const OrdersMapper = (
  ordersRaw: OrdersRaw[] | null
): Order[] | undefined => {
  if (!ordersRaw || ordersRaw.length === 0) return undefined
  return ordersRaw.map(OrderMapper)
}

export const OrderToRawMapper = (
  order: Omit<Order, 'id' | 'createdAt' | 'updatedAt'>
): Omit<OrdersRaw, 'id' | 'created_at' | 'updated_at'> => {
  return {
    customer_id: order.customerId,
    order_number: order.orderNumber,
    status: order.status,

    // Montos
    subtotal: order.subtotal,
    discount_amount: order.discountAmount,
    shipping_cost: order.shippingCost,
    tax_amount: order.taxAmount,
    total_amount: order.totalAmount,

    // Informaci√≥n de env√≠o
    shipping_address_id: order.shippingAddressId,
    shipping_method: order.shippingMethod,
    estimated_delivery: order.estimatedDelivery,

    // Informaci√≥n de pago
    payment_method: order.paymentMethod,
    payment_status: order.paymentStatus,
    paid_at: order.paidAt,

    // Notas
    customer_notes: order.customerNotes,
    admin_notes: order.adminNotes
  }
}



üìÅ ARCHIVO: src/backend/order/Order.model.ts
------------------------------------------------------------------------------------
import { type Orders as Order } from '@/types/domain'

import { OrderMapper, OrdersMapper, OrderToRawMapper } from './Order.mapper'
import oOrderRep from './Order.repository'

export class OrderModel {
  public async getOrders(): Promise<Order[] | undefined> {
    const ordersRaw = await oOrderRep.getOrders()
    return OrdersMapper(ordersRaw)
  }

  public async getOrderById(id: number): Promise<Order | undefined> {
    const orderRaw = await oOrderRep.getOrderById(id)
    if (!orderRaw) return undefined
    return OrderMapper(orderRaw)
  }

  public async getOrderByNumber(
    orderNumber: string
  ): Promise<Order | undefined> {
    const orderRaw = await oOrderRep.getOrderByNumber(orderNumber)
    if (!orderRaw) return undefined
    return OrderMapper(orderRaw)
  }

  public async getOrdersByCustomerId(
    customerId: number
  ): Promise<Order[] | undefined> {
    const ordersRaw = await oOrderRep.getOrdersByCustomerId(customerId)
    return OrdersMapper(ordersRaw)
  }

  public async getOrdersByStatus(status: string): Promise<Order[] | undefined> {
    const ordersRaw = await oOrderRep.getOrdersByStatus(status)
    return OrdersMapper(ordersRaw)
  }

  public async createOrder(
    orderData: Omit<Order, 'id' | 'createdAt' | 'updatedAt'>
  ): Promise<Order | undefined> {
    const orderRaw = OrderToRawMapper(orderData)
    const created = await oOrderRep.createOrder(orderRaw)
    if (!created) return undefined
    return OrderMapper(created)
  }

  public async updateOrder(
    orderData: Partial<Omit<Order, 'id' | 'createdAt' | 'updatedAt'>>,
    id: number
  ): Promise<Order | undefined> {
    // Convertir solo los campos que se van a actualizar
    const updateRaw: any = {}

    if (orderData.customerId !== undefined) { updateRaw.customer_id = orderData.customerId }
    if (orderData.orderNumber !== undefined) { updateRaw.order_number = orderData.orderNumber }
    if (orderData.status !== undefined) updateRaw.status = orderData.status
    if (orderData.subtotal !== undefined) { updateRaw.subtotal = orderData.subtotal }
    if (orderData.discountAmount !== undefined) { updateRaw.discount_amount = orderData.discountAmount }
    if (orderData.shippingCost !== undefined) { updateRaw.shipping_cost = orderData.shippingCost }
    if (orderData.taxAmount !== undefined) { updateRaw.tax_amount = orderData.taxAmount }
    if (orderData.totalAmount !== undefined) { updateRaw.total_amount = orderData.totalAmount }
    if (orderData.shippingAddressId !== undefined) { updateRaw.shipping_address_id = orderData.shippingAddressId }
    if (orderData.shippingMethod !== undefined) { updateRaw.shipping_method = orderData.shippingMethod }
    if (orderData.estimatedDelivery !== undefined) { updateRaw.estimated_delivery = orderData.estimatedDelivery }
    if (orderData.paymentMethod !== undefined) { updateRaw.payment_method = orderData.paymentMethod }
    if (orderData.paymentStatus !== undefined) { updateRaw.payment_status = orderData.paymentStatus }
    if (orderData.paidAt !== undefined) updateRaw.paid_at = orderData.paidAt
    if (orderData.customerNotes !== undefined) { updateRaw.customer_notes = orderData.customerNotes }
    if (orderData.adminNotes !== undefined) { updateRaw.admin_notes = orderData.adminNotes }

    const updated = await oOrderRep.updateOrder(updateRaw, id)
    if (!updated) return undefined
    return OrderMapper(updated)
  }

  public async updateOrderStatus(
    id: number,
    status: string,
    adminNotes?: string
  ): Promise<Order | undefined> {
    const updated = await oOrderRep.updateOrderStatus(id, status, adminNotes)
    if (!updated) return undefined
    return OrderMapper(updated)
  }

  public async updatePaymentStatus(
    id: number,
    paymentStatus: string,
    paidAt?: Date
  ): Promise<Order | undefined> {
    const updated = await oOrderRep.updatePaymentStatus(
      id,
      paymentStatus,
      paidAt
    )
    if (!updated) return undefined
    return OrderMapper(updated)
  }

  public async deleteOrder(id: number): Promise<void> {
    await oOrderRep.deleteOrder(id)
  }

  public async getOrderSummary(): Promise<any[] | undefined> {
    const summary = await oOrderRep.getOrderSummary()
    if (!summary) return undefined
    return summary
  }
}

const orderModel = new OrderModel()
export default orderModel



üìÅ ARCHIVO: src/backend/order/index.ts
------------------------------------------------------------------------------------
export * from './Order.mapper'
export { default } from './Order.model'
export * from './Order.repository'



üìÅ ARCHIVO: src/backend/order/Order.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type Orders as OrdersRaw } from '@/types/database'

export class OrderRepository {
  public async getOrders(): Promise<OrdersRaw[] | null> {
    const orders = await executeQuery<OrdersRaw[]>({
      query: 'SELECT * FROM orders ORDER BY created_at DESC'
    })

    if (orders.length === 0) return null
    return orders
  }

  public async getOrderById(id: number): Promise<OrdersRaw | null> {
    const orders = await executeQuery<OrdersRaw[]>({
      query: 'SELECT * FROM orders WHERE id = ?',
      values: [id]
    })

    if (orders.length === 0) return null
    return orders[0]
  }

  public async getOrderByNumber(
    orderNumber: string
  ): Promise<OrdersRaw | null> {
    const orders = await executeQuery<OrdersRaw[]>({
      query: 'SELECT * FROM orders WHERE order_number = ?',
      values: [orderNumber]
    })

    if (orders.length === 0) return null
    return orders[0]
  }

  public async getOrdersByCustomerId(
    customerId: number
  ): Promise<OrdersRaw[] | null> {
    const orders = await executeQuery<OrdersRaw[]>({
      query:
        'SELECT * FROM orders WHERE customer_id = ? ORDER BY created_at DESC',
      values: [customerId]
    })

    if (orders.length === 0) return null
    return orders
  }

  public async getOrdersByStatus(status: string): Promise<OrdersRaw[] | null> {
    const orders = await executeQuery<OrdersRaw[]>({
      query: 'SELECT * FROM orders WHERE status = ? ORDER BY created_at DESC',
      values: [status]
    })

    if (orders.length === 0) return null
    return orders
  }

  public async createOrder(
    order: Omit<OrdersRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<OrdersRaw | null> {
    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO orders SET ?',
      values: [order]
    })

    return await this.getOrderById(result.insertId)
  }

  public async updateOrder(
    orderData: Partial<Omit<OrdersRaw, 'id' | 'created_at' | 'updated_at'>>,
    id: number
  ): Promise<OrdersRaw | null> {
    await executeQuery({
      query: 'UPDATE orders SET ? WHERE id = ?',
      values: [orderData, id]
    })

    return await this.getOrderById(id)
  }

  public async updateOrderStatus(
    id: number,
    status: string,
    adminNotes?: string
  ): Promise<OrdersRaw | null> {
    const updateData: any = { status }
    if (adminNotes) updateData.admin_notes = adminNotes

    await executeQuery({
      query: 'UPDATE orders SET ? WHERE id = ?',
      values: [updateData, id]
    })

    return await this.getOrderById(id)
  }

  public async updatePaymentStatus(
    id: number,
    paymentStatus: string,
    paidAt?: Date
  ): Promise<OrdersRaw | null> {
    const updateData: any = { payment_status: paymentStatus }
    if (paidAt) updateData.paid_at = paidAt

    await executeQuery({
      query: 'UPDATE orders SET ? WHERE id = ?',
      values: [updateData, id]
    })

    return await this.getOrderById(id)
  }

  public async deleteOrder(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM orders WHERE id = ?',
      values: [id]
    })
  }

  public async getOrderSummary(): Promise<any[] | null> {
    const summary = await executeQuery<any[]>({
      query: 'SELECT * FROM order_summary ORDER BY created_at DESC'
    })

    if (summary.length === 0) return null
    return summary
  }
}

const orderRepository = new OrderRepository()
export default orderRepository



üìÅ ARCHIVO: src/backend/filters/Filters.interfaces.ts
------------------------------------------------------------------------------------
export interface AvailableFilters {
  categories: FilterCategory[]
  brands: FilterBrand[]
  priceRange: PriceRange
  attributes: FilterAttribute[]
}

export interface FilterCategory {
  id: number
  name: string
  count: number
}

export interface FilterBrand {
  id: number
  name: string
  count: number
}

export interface PriceRange {
  min: number
  max: number
}

export interface FilterAttribute {
  id: number
  name: string
  displayType: string
  options: FilterAttributeOption[]
}

export interface FilterAttributeOption {
  id: number
  value: string
  additionalCost?: number
  count: number
}



üìÅ ARCHIVO: src/backend/filters/Filters.mapper.ts
------------------------------------------------------------------------------------
import {
  type AvailableFilters,
  type FilterAttribute,
  type FilterBrand,
  type FilterCategory
} from './Filters.interfaces'

export const FilterCategoryMapper = (data: FilterCategory): FilterCategory => {
  return {
    id: data.id,
    name: data.name,
    count: data.count
  }
}

export const FilterCategoriesMapper = (
  data: FilterCategory[]
): FilterCategory[] => {
  return data.map(FilterCategoryMapper)
}

export const FilterBrandMapper = (data: FilterBrand): FilterBrand => {
  return {
    id: data.id,
    name: data.name,
    count: data.count
  }
}

export const FilterBrandsMapper = (data: FilterBrand[]): FilterBrand[] => {
  return data.map(FilterBrandMapper)
}

export const FilterAttributeMapper = (
  data: FilterAttribute
): FilterAttribute => {
  return {
    id: data.id,
    name: data.name,
    displayType: data.displayType,
    options: data.options.map((option) => ({
      id: option.id,
      value: option.value,
      additionalCost: option.additionalCost,
      count: option.count
    }))
  }
}

export const FilterAttributesMapper = (
  data: FilterAttribute[]
): FilterAttribute[] => {
  return data.map(FilterAttributeMapper)
}

export const AvailableFiltersMapper = (
  categories: FilterCategory[],
  brands: FilterBrand[],
  priceRange: { min: number, max: number },
  attributes: FilterAttribute[]
): AvailableFilters => {
  return {
    categories: FilterCategoriesMapper(categories),
    brands: FilterBrandsMapper(brands),
    priceRange,
    attributes: FilterAttributesMapper(attributes)
  }
}



üìÅ ARCHIVO: src/backend/filters/Filters.model.ts
------------------------------------------------------------------------------------
// me
import { type AvailableFilters } from './Filters.interfaces'
import { AvailableFiltersMapper } from './Filters.mapper'
import oFiltersRep from './Filters.repository'

export class FiltersModel {
  public async getAvailableFilters(): Promise<AvailableFilters> {
    const [categories, brands, priceRange, attributes] = await Promise.all([
      oFiltersRep.getAvailableCategories(),
      oFiltersRep.getAvailableBrands(),
      oFiltersRep.getPriceRange(),
      oFiltersRep.getAvailableAttributes()
    ])

    return AvailableFiltersMapper(categories, brands, priceRange, attributes)
  }

  public async getAvailableCategories() {
    return await oFiltersRep.getAvailableCategories()
  }

  public async getAvailableBrands() {
    return await oFiltersRep.getAvailableBrands()
  }

  public async getPriceRange() {
    return await oFiltersRep.getPriceRange()
  }

  public async getAvailableAttributes() {
    return await oFiltersRep.getAvailableAttributes()
  }
}

const filtersModel = new FiltersModel()
export default filtersModel



üìÅ ARCHIVO: src/backend/filters/Filters.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import {
  type FilterAttribute,
  type FilterBrand,
  type FilterCategory,
  type PriceRange
} from './Filters.interfaces'

export class FiltersRepository {
  public async getAvailableCategories(): Promise<FilterCategory[]> {
    const categoriesQuery = `
      SELECT c.id, c.name, COUNT(DISTINCT pv.id) as count
      FROM categories c
      JOIN product_categories pc ON c.id = pc.category_id
      JOIN products p ON pc.product_id = p.id
      JOIN product_variants pv ON p.id = pv.product_id
      GROUP BY c.id
      ORDER BY count DESC
    `
    const categories = await executeQuery<FilterCategory[]>({
      query: categoriesQuery
    })

    return categories
  }

  public async getAvailableBrands(): Promise<FilterBrand[]> {
    const brandsQuery = `
      SELECT b.id, b.name, COUNT(DISTINCT pv.id) as count
      FROM brands b
      JOIN products p ON b.id = p.brand_id
      JOIN product_variants pv ON p.id = pv.product_id
      GROUP BY b.id
      ORDER BY count DESC
    `
    const brands = await executeQuery<FilterBrand[]>({
      query: brandsQuery
    })

    return brands
  }

  public async getPriceRange(): Promise<PriceRange> {
    const priceRangeQuery = `
      SELECT MIN(pv.price) as min, MAX(pv.price) as max
      FROM product_variants pv
    `
    const priceRange = await executeQuery<[PriceRange]>({
      query: priceRangeQuery
    })

    return priceRange[0] || { min: 0, max: 0 }
  }

  public async getAvailableAttributes(): Promise<FilterAttribute[]> {
    const attributesQuery = `
      SELECT 
        a.id, a.name, a.display_type,
        ao.id as option_id, ao.value as option_value, ao.additional_cost,
        COUNT(DISTINCT pv.id) as count
      FROM attributes a
      JOIN attribute_options ao ON a.id = ao.attribute_id
      JOIN variant_attribute_options vao ON ao.id = vao.attribute_option_id
      JOIN product_variants pv ON vao.variant_id = pv.id
      GROUP BY a.id, ao.id
      ORDER BY a.id, count DESC
    `
    const attributeOptions = await executeQuery<
      Array<{
        id: number
        name: string
        display_type: string
        option_id: number
        option_value: string
        additional_cost: number
        count: number
      }>
    >({
      query: attributesQuery
    })

    const attributesMap = new Map<number, FilterAttribute>()

    attributeOptions.forEach((option) => {
      if (!attributesMap.has(option.id)) {
        attributesMap.set(option.id, {
          id: option.id,
          name: option.name,
          displayType: option.display_type,
          options: []
        })
      }

      attributesMap.get(option.id)?.options.push({
        id: option.option_id,
        value: option.option_value,
        additionalCost: option.additional_cost,
        count: option.count
      })
    })

    return Array.from(attributesMap.values())
  }
}

const filtersRepository = new FiltersRepository()
export default filtersRepository



üìÅ ARCHIVO: src/backend/filters/index.ts
------------------------------------------------------------------------------------
export * from './Filters.interfaces'
export * from './Filters.mapper'
export { default } from './Filters.model'
export * from './Filters.repository'



üìÅ ARCHIVO: src/backend/attribute/Attribute.interfaces.ts
------------------------------------------------------------------------------------
// generated
import {
  type Attributes as Attribute,
  type AttributeOptions as AttributeOption
} from '@/types/domain'

// me
export interface AttributeWithOptions extends Attribute {
  options?: AttributeOption[]
}



üìÅ ARCHIVO: src/backend/attribute/Attribute.model.ts
------------------------------------------------------------------------------------
// generated
import { type Attributes as AttributeRaw } from '@/types/database'
import { type AttributeOptions as AttributeOption } from '@/types/domain'

// others
import attributeOptionModel from '@/backend/attribute-option/AttributeOption.model'

// me
import { type AttributeWithOptions } from './Attribute.interfaces'
import { AttributeMapper, AttributeMappers } from './Attribute.mapper'
import oAttributeRep from './Attribute.repository'

export class AttributeModel {
  // ‚úÖ Obtener todos los attributes con sus opciones (SIN images por defecto)
  public async getAttributes(): Promise<AttributeWithOptions[] | undefined> {
    const attributesRaw = await oAttributeRep.getAttributes()
    const attributes = AttributeMappers(attributesRaw)

    if (!attributes) return undefined

    // Para cada atributo, obtener sus opciones SIN images
    return await Promise.all(
      attributes.map(async (attribute) => ({
        ...attribute,
        options: await this.getAttributeOptions(attribute.id)
      }))
    )
  }

  // ‚úÖ Obtener todos los attributes con opciones E IMAGES (l√≥gica de negocio)
  public async getAttributesWithImages(): Promise<
    AttributeWithOptions[] | undefined
  > {
    const attributesRaw = await oAttributeRep.getAttributes()
    const attributes = AttributeMappers(attributesRaw)

    if (!attributes) return undefined

    // Para cada atributo, obtener sus opciones CON images usando el MODEL
    return await Promise.all(
      attributes.map(async (attribute) => ({
        ...attribute,
        options: await attributeOptionModel.getAttributeOptionsWithImages(
          attribute.id
        )
      }))
    )
  }

  // ‚úÖ Obtener attribute por ID con sus opciones (SIN images por defecto)
  public async getAttributeById(
    id: number
  ): Promise<AttributeWithOptions | undefined> {
    const attributeRaw = await oAttributeRep.getAttributeById(id)

    if (!attributeRaw) return undefined

    const attribute = AttributeMapper(attributeRaw)
    const options = await this.getAttributeOptions(attribute.id)

    return {
      ...attribute,
      options
    }
  }

  // ‚úÖ Obtener attribute por ID con opciones E IMAGES (l√≥gica de negocio)
  public async getAttributeByIdWithImages(
    id: number
  ): Promise<AttributeWithOptions | undefined> {
    const attributeRaw = await oAttributeRep.getAttributeById(id)

    if (!attributeRaw) return undefined

    const attribute = AttributeMapper(attributeRaw)
    const options = await attributeOptionModel.getAttributeOptionsWithImages(
      attribute.id
    )

    return {
      ...attribute,
      options
    }
  }

  // ‚úÖ Obtener solo las opciones de un atributo
  public async getAttributeOptions(
    attributeId: number
  ): Promise<AttributeOption[] | undefined> {
    const optionsRaw =
      await attributeOptionModel.getAttributeOptions(attributeId)
    if (!optionsRaw) return undefined
    return optionsRaw
  }

  // ‚úÖ Crear attribute - delega al repository
  public async createAttribute(
    attributeData: Omit<AttributeRaw, 'id'>
  ): Promise<AttributeWithOptions | undefined> {
    const created = await oAttributeRep.createAttribute(attributeData)

    if (!created) return undefined

    return await this.getAttributeById(created.id)
  }

  // ‚úÖ Actualizar attribute - delega al repository
  public async updateAttribute(
    attributeData: Omit<AttributeRaw, 'id'>,
    id: number
  ): Promise<AttributeWithOptions | undefined> {
    const updated = await oAttributeRep.updateAttribute(attributeData, id)

    if (!updated) return undefined

    return await this.getAttributeById(updated.id)
  }

  // ‚úÖ Eliminar attribute - delega al repository
  public async deleteAttribute(id: number): Promise<void> {
    await oAttributeRep.deleteAttribute(id)
  }
}

const attributeModel = new AttributeModel()
export default attributeModel



üìÅ ARCHIVO: src/backend/attribute/index.ts
------------------------------------------------------------------------------------
export * from './Attribute.interfaces'
export * from './Attribute.mapper'
export { default } from './Attribute.model'
export * from './Attribute.repository'



üìÅ ARCHIVO: src/backend/attribute/Attribute.mapper.ts
------------------------------------------------------------------------------------
// generated
import { type Attributes as AttributeRaw } from '@/types/database'
import { type Attributes as Attribute } from '@/types/domain'

export const AttributeMapper = (data: AttributeRaw): Attribute => {
  return {
    ...data,
    displayType: data.display_type
  }
}

export const AttributeMappers = (
  data: AttributeRaw[] | null
): Attribute[] | undefined => {
  if (data === null) return undefined
  return data.map(AttributeMapper)
}



üìÅ ARCHIVO: src/backend/attribute/Attribute.repository.ts
------------------------------------------------------------------------------------
// generated
import { executeQuery } from '@/lib/db'
import { type Attributes as AttributeRaw } from '@/types/database'

export class AttributeRepository {
  public async getAttributes(): Promise<AttributeRaw[] | null> {
    const attributes = await executeQuery<AttributeRaw[]>({
      query: 'SELECT * FROM attributes'
    })

    if (attributes.length === 0) return null
    return attributes
  }

  public async getAttributeById(id: number): Promise<AttributeRaw | null> {
    const attributes = await executeQuery<AttributeRaw[]>({
      query: 'SELECT * FROM attributes WHERE id = ?',
      values: [id]
    })

    if (attributes.length === 0) return null

    return attributes[0]
  }

  public async createAttribute(
    attribute: Omit<AttributeRaw, 'id'>
  ): Promise<AttributeRaw | null> {
    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO attributes SET ?',
      values: [attribute]
    })

    return await this.getAttributeById(result.insertId)
  }

  public async updateAttribute(
    attributeData: Omit<AttributeRaw, 'id'>,
    id: number
  ): Promise<AttributeRaw | null> {
    await executeQuery({
      query: 'UPDATE attributes SET ? WHERE id=?',
      values: [attributeData, id]
    })

    return await this.getAttributeById(id)
  }

  public async deleteAttribute(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM attributes WHERE id=?',
      values: [id]
    })
  }
}

const attributeRepository = new AttributeRepository()
export default attributeRepository



üìÅ ARCHIVO: src/backend/category/Category.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type Categories as CategoriesRaw } from '@/types/database'

export class CategoryRepository {
  public async getCategories(): Promise<CategoriesRaw[] | null> {
    const categories = await executeQuery<CategoriesRaw[]>({
      query: 'SELECT * FROM categories ORDER BY name'
    })

    if (categories.length === 0) return null
    return categories
  }

  public async getCategoryById(id: number): Promise<CategoriesRaw | null> {
    const categories = await executeQuery<CategoriesRaw[]>({
      query: 'SELECT * FROM categories WHERE id = ?',
      values: [id]
    })

    if (categories.length === 0) return null
    return categories[0]
  }

  public async getCategoriesByProductId(
    productId: number
  ): Promise<CategoriesRaw[] | null> {
    const categories = await executeQuery<CategoriesRaw[]>({
      query: `
        SELECT c.id, c.name, c.description, c.parent_id, c.image_url
        FROM categories c
        JOIN product_categories pc ON c.id = pc.category_id
        WHERE pc.product_id = ?
      `,
      values: [productId]
    })

    if (categories.length === 0) return null
    return categories
  }

  public async createCategory(
    category: Omit<CategoriesRaw, 'id'>
  ): Promise<CategoriesRaw | null> {
    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO categories SET ?',
      values: [category]
    })

    return await this.getCategoryById(result.insertId)
  }

  public async updateCategory(
    categoryData: Omit<CategoriesRaw, 'id'>,
    id: number
  ): Promise<CategoriesRaw | null> {
    await executeQuery({
      query: 'UPDATE categories SET ? WHERE id=?',
      values: [categoryData, id]
    })

    return await this.getCategoryById(id)
  }

  public async deleteCategory(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM categories WHERE id=?',
      values: [id]
    })
  }

  public async addProductToCategory(
    productId: number,
    categoryId: number
  ): Promise<void> {
    await executeQuery({
      query:
        'INSERT INTO product_categories (product_id, category_id) VALUES (?, ?)',
      values: [productId, categoryId]
    })
  }

  public async removeProductFromCategory(
    productId: number,
    categoryId: number
  ): Promise<void> {
    await executeQuery({
      query:
        'DELETE FROM product_categories WHERE product_id = ? AND category_id = ?',
      values: [productId, categoryId]
    })
  }
}

const categoryRepository = new CategoryRepository()
export default categoryRepository



üìÅ ARCHIVO: src/backend/category/Category.model.ts
------------------------------------------------------------------------------------
import { type Categories as CategoriesRaw } from '@/types/database'
import { type Categories as Category } from '@/types/domain'

// me
import { type CategoryWithChildren } from './Category.interfaces'
import { CategoriesMapper, CategoryMapper } from './Category.mapper'
import oCategoryRep from './Category.repository'

export class CategoryModel {
  public async getCategories(): Promise<Category[] | undefined> {
    const categoriesRaw = await oCategoryRep.getCategories()
    return CategoriesMapper(categoriesRaw)
  }

  public async getCategoriesHierarchy(): Promise<Category[] | undefined> {
    const categories = await this.getCategories()
    if (!categories) return undefined

    // Construir la jerarqu√≠a
    const categoryMap = new Map<number, CategoryWithChildren>()
    const rootCategories: Category[] = []

    // Crear el mapa de categor√≠as
    categories.forEach((category) => {
      categoryMap.set(category.id, {
        ...category,
        children: []
      })
    })

    // Construir la jerarqu√≠a
    categories.forEach((category) => {
      const categoryWithChildren = categoryMap.get(category.id)!

      if (category.parentId === null || category.parentId === undefined) {
        rootCategories.push(categoryWithChildren)
      } else {
        const parent = categoryMap.get(category.parentId)
        if (parent) {
          if (!parent.children) {
            parent.children = []
          }
          parent.children.push(categoryWithChildren)
        }
      }
    })

    return rootCategories
  }

  public async getCategoryById(id: number): Promise<Category | undefined> {
    const categoryRaw = await oCategoryRep.getCategoryById(id)
    if (!categoryRaw) return undefined
    return CategoryMapper(categoryRaw)
  }

  public async getCategoriesByProductId(
    productId: number
  ): Promise<Category[] | undefined> {
    const categoriesRaw = await oCategoryRep.getCategoriesByProductId(productId)
    return CategoriesMapper(categoriesRaw)
  }

  public async createCategory(
    categoryData: Omit<CategoriesRaw, 'id'>
  ): Promise<Category | undefined> {
    const created = await oCategoryRep.createCategory(categoryData)
    if (!created) return undefined
    return CategoryMapper(created)
  }

  public async updateCategory(
    categoryData: Omit<CategoriesRaw, 'id'>,
    id: number
  ): Promise<Category | undefined> {
    const updated = await oCategoryRep.updateCategory(categoryData, id)
    if (!updated) return undefined
    return CategoryMapper(updated)
  }

  public async deleteCategory(id: number): Promise<void> {
    await oCategoryRep.deleteCategory(id)
  }

  public async addProductToCategory(
    productId: number,
    categoryId: number
  ): Promise<void> {
    await oCategoryRep.addProductToCategory(productId, categoryId)
  }

  public async removeProductFromCategory(
    productId: number,
    categoryId: number
  ): Promise<void> {
    await oCategoryRep.removeProductFromCategory(productId, categoryId)
  }
}

const categoryModel = new CategoryModel()
export default categoryModel



üìÅ ARCHIVO: src/backend/category/Category.interfaces.ts
------------------------------------------------------------------------------------
import { type Categories as Category } from '@/types/domain'

export interface CategoryWithChildren extends Category {
  children?: Category[]
}



üìÅ ARCHIVO: src/backend/category/Category.mapper.ts
------------------------------------------------------------------------------------
import { type Categories as CategoryRaw } from '@/types/database'
import { type Categories as Category } from '@/types/domain'

export const CategoryMapper = (data: CategoryRaw): Category => {
  return {
    id: data.id,
    name: data.name,
    description: data.description,
    imageUrl: data.image_url,
    parentId: data.parent_id
  }
}

export const CategoriesMapper = (
  data: CategoryRaw[] | null
): Category[] | undefined => {
  if (data === null) return undefined
  return data.map(CategoryMapper)
}



üìÅ ARCHIVO: src/backend/category/index.ts
------------------------------------------------------------------------------------
export * from './Category.interfaces'
export * from './Category.mapper'
export { default } from './Category.model'
export * from './Category.repository'



üìÅ ARCHIVO: src/backend/customer-address/CustomerAddress.mapper.ts
------------------------------------------------------------------------------------
import { type CustomersAddresses as CustomerAddressRaw } from '@/types/database'
import { type CustomersAddresses } from '@/types/domain'

export const CustomerAddressMapper = (
  data: CustomerAddressRaw
): CustomersAddresses => {
  return {
    id: data.id,
    idCustomer: data.id_customer,
    alias: data.alias,
    department: data.department,
    province: data.province,
    district: data.district,
    streetName: data.street_name,
    streetNumber: data.street_number,
    apartment: data.apartment || undefined,
    latitude: data.latitude || undefined,
    longitude: data.longitude || undefined,
    isDefault: data.is_default,
    createdAt: data.created_at,
    updatedAt: data.updated_at,
    customer: undefined // Se puede popular despu√©s si es necesario
  }
}

export const CustomerAddressesMapper = (
  data: CustomerAddressRaw[] | null
): CustomersAddresses[] | undefined => {
  if (data === null) return undefined
  return data.map(CustomerAddressMapper)
}



üìÅ ARCHIVO: src/backend/customer-address/CustomerAddress.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type CustomersAddresses as CustomerAddressRaw } from '@/types/database'

export class CustomerAddressRepository {
  public async getAddress(id: number): Promise<CustomerAddressRaw | null> {
    const addresses = await executeQuery<CustomerAddressRaw[]>({
      query: 'SELECT * FROM customers_addresses WHERE id = ?',
      values: [id]
    })

    if (addresses.length === 0) return null
    return addresses[0]
  }

  public async getAddressByCustomer(
    customerId: number
  ): Promise<CustomerAddressRaw[] | null> {
    const addresses = await executeQuery<CustomerAddressRaw[]>({
      query: `
        SELECT * FROM customers_addresses 
        WHERE id_customer = ? 
        ORDER BY is_default DESC, created_at ASC
      `,
      values: [customerId]
    })

    if (addresses.length === 0) return null
    return addresses
  }

  public async getAddresses(): Promise<CustomerAddressRaw[] | null> {
    const addresses = await executeQuery<CustomerAddressRaw[]>({
      query: 'SELECT * FROM customers_addresses ORDER BY created_at DESC'
    })

    if (addresses.length === 0) return null
    return addresses
  }

  public async createAddress(data: {
    idCustomer: number
    alias: string
    department: string
    province: string
    district: string
    streetName: string
    streetNumber: string
    apartment?: string
    latitude?: number
    longitude?: number
    isDefault?: boolean
  }): Promise<CustomerAddressRaw | null> {
    // Si es direcci√≥n por defecto, quitar default de las dem√°s
    if (data.isDefault) {
      await this.removeDefaultFromCustomer(data.idCustomer)
    }

    const result = await executeQuery<{ insertId: number }>({
      query: `
        INSERT INTO customers_addresses (
          id_customer, alias, department, province, district, 
          street_name, street_number, apartment, latitude, longitude, is_default
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `,
      values: [
        data.idCustomer,
        data.alias,
        data.department,
        data.province,
        data.district,
        data.streetName,
        data.streetNumber,
        data.apartment || null,
        data.latitude || null,
        data.longitude || null,
        data.isDefault ? 1 : 0
      ]
    })

    return await this.getAddress(result.insertId)
  }

  public async updateAddress(
    id: number,
    data: {
      alias?: string
      department?: string
      province?: string
      district?: string
      streetName?: string
      streetNumber?: string
      apartment?: string
      latitude?: number
      longitude?: number
    }
  ): Promise<CustomerAddressRaw | null> {
    const fields: string[] = []
    const values: any[] = []

    if (data.alias !== undefined) {
      fields.push('alias = ?')
      values.push(data.alias)
    }
    if (data.department !== undefined) {
      fields.push('department = ?')
      values.push(data.department)
    }
    if (data.province !== undefined) {
      fields.push('province = ?')
      values.push(data.province)
    }
    if (data.district !== undefined) {
      fields.push('district = ?')
      values.push(data.district)
    }
    if (data.streetName !== undefined) {
      fields.push('street_name = ?')
      values.push(data.streetName)
    }
    if (data.streetNumber !== undefined) {
      fields.push('street_number = ?')
      values.push(data.streetNumber)
    }
    if (data.apartment !== undefined) {
      fields.push('apartment = ?')
      values.push(data.apartment)
    }
    if (data.latitude !== undefined) {
      fields.push('latitude = ?')
      values.push(data.latitude)
    }
    if (data.longitude !== undefined) {
      fields.push('longitude = ?')
      values.push(data.longitude)
    }

    if (fields.length === 0) {
      return await this.getAddress(id)
    }

    values.push(id)

    await executeQuery({
      query: `UPDATE customers_addresses SET ${fields.join(', ')} WHERE id = ?`,
      values
    })

    return await this.getAddress(id)
  }

  public async deleteAddress(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM customers_addresses WHERE id = ?',
      values: [id]
    })
  }

  public async setDefaultAddress(
    customerId: number,
    addressId: number
  ): Promise<void> {
    // Quitar default de todas las direcciones del cliente
    await this.removeDefaultFromCustomer(customerId)

    // Establecer la nueva como default
    await executeQuery({
      query:
        'UPDATE customers_addresses SET is_default = 1 WHERE id = ? AND id_customer = ?',
      values: [addressId, customerId]
    })
  }

  private async removeDefaultFromCustomer(customerId: number): Promise<void> {
    await executeQuery({
      query:
        'UPDATE customers_addresses SET is_default = 0 WHERE id_customer = ?',
      values: [customerId]
    })
  }
}

const customerAddressRepository = new CustomerAddressRepository()
export default customerAddressRepository



üìÅ ARCHIVO: src/backend/customer-address/index.ts
------------------------------------------------------------------------------------
export * from './CustomerAddress.mapper'
export { default } from './CustomerAddress.model'
export * from './CustomerAddress.repository'



üìÅ ARCHIVO: src/backend/customer-address/CustomerAddress.model.ts
------------------------------------------------------------------------------------
// backend/customerAddress/CustomerAddress.model.ts
import { type CustomersAddresses } from '@/types/domain'
import {
  CustomerAddressMapper,
  CustomerAddressesMapper
} from './CustomerAddress.mapper'
import customerAddressRepository from './CustomerAddress.repository'

export class CustomerAddressModel {
  public async getAddress(id: number): Promise<CustomersAddresses | undefined> {
    const addressRaw = await customerAddressRepository.getAddress(id)
    if (!addressRaw) return undefined
    return CustomerAddressMapper(addressRaw)
  }

  public async getAddressByCustomer(
    customerId: number
  ): Promise<CustomersAddresses[] | undefined> {
    const addressesRaw =
      await customerAddressRepository.getAddressByCustomer(customerId)
    return CustomerAddressesMapper(addressesRaw)
  }

  public async getAddresses(): Promise<CustomersAddresses[] | undefined> {
    const addressesRaw = await customerAddressRepository.getAddresses()
    return CustomerAddressesMapper(addressesRaw)
  }

  public async createAddress(data: {
    idCustomer: number
    alias: string
    department: string
    province: string
    district: string
    streetName: string
    streetNumber: string
    apartment?: string
    latitude?: number
    longitude?: number
    isDefault?: boolean
  }): Promise<CustomersAddresses | undefined> {
    const created = await customerAddressRepository.createAddress(data)
    if (!created) return undefined
    return CustomerAddressMapper(created)
  }

  public async updateAddress(
    id: number,
    data: {
      alias?: string
      department?: string
      province?: string
      district?: string
      streetName?: string
      streetNumber?: string
      apartment?: string
      latitude?: number
      longitude?: number
    }
  ): Promise<CustomersAddresses | undefined> {
    const updated = await customerAddressRepository.updateAddress(id, data)
    if (!updated) return undefined
    return CustomerAddressMapper(updated)
  }

  public async deleteAddress(id: number): Promise<void> {
    await customerAddressRepository.deleteAddress(id)
  }

  public async setDefaultAddress(
    customerId: number,
    addressId: number
  ): Promise<void> {
    await customerAddressRepository.setDefaultAddress(
      customerId,
      addressId
    )
  }
}

const customerAddressModel = new CustomerAddressModel()
export default customerAddressModel



üìÅ ARCHIVO: src/backend/shipping-zone-method/ShippingZoneMethod.repository.ts
------------------------------------------------------------------------------------
// üìÑ ShippingZoneMethod.repository.ts
import { executeQuery } from '@/lib/db'
import { type ShippingZoneMethods as ShippingZoneMethodRaw } from '@/types/database'

interface ShippingZoneMethodWithDetails extends ShippingZoneMethodRaw {
  method_name?: string
  zone_name?: string
  zone_districts?: any
}

export class ShippingZoneMethodRepository {
  public async getZoneMethodById(
    id: number
  ): Promise<ShippingZoneMethodRaw | null> {
    const methods = await executeQuery<ShippingZoneMethodRaw[]>({
      query: 'SELECT * FROM shipping_zone_methods WHERE id = ?',
      values: [id]
    })

    if (methods.length === 0) return null
    return methods[0]
  }

  public async getZoneMethodByIds(
    shippingMethodId: number,
    shippingZoneId: number
  ): Promise<ShippingZoneMethodRaw | null> {
    const methods = await executeQuery<ShippingZoneMethodRaw[]>({
      query: `
        SELECT * FROM shipping_zone_methods 
        WHERE shipping_method_id = ? AND shipping_zone_id = ?
        AND is_active = 1
      `,
      values: [shippingMethodId, shippingZoneId]
    })

    if (methods.length === 0) return null
    return methods[0]
  }

  public async getZoneMethodsByShippingMethodId(
    shippingMethodId: number
  ): Promise<ShippingZoneMethodWithDetails[] | null> {
    const methods = await executeQuery<ShippingZoneMethodWithDetails[]>({
      query: `
        SELECT 
          szm.*,
          sz.name as zone_name,
          sz.districts as zone_districts
        FROM shipping_zone_methods szm
        JOIN shipping_zones sz ON szm.shipping_zone_id = sz.id
        WHERE szm.shipping_method_id = ? 
        AND szm.is_active = 1 
        AND sz.is_active = 1
        ORDER BY sz.name ASC
      `,
      values: [shippingMethodId]
    })

    if (methods.length === 0) return null
    return methods
  }

  public async getZoneMethodsByZoneId(
    shippingZoneId: number
  ): Promise<ShippingZoneMethodWithDetails[] | null> {
    const methods = await executeQuery<ShippingZoneMethodWithDetails[]>({
      query: `
        SELECT 
          szm.*,
          sm.name as method_name
        FROM shipping_zone_methods szm
        JOIN shipping_methods sm ON szm.shipping_method_id = sm.id
        WHERE szm.shipping_zone_id = ? 
        AND szm.is_active = 1 
        AND sm.is_active = 1
        ORDER BY sm.display_order ASC, sm.name ASC
      `,
      values: [shippingZoneId]
    })

    if (methods.length === 0) return null
    return methods
  }

  public async getAllZoneMethodsWithDetails(): Promise<
    ShippingZoneMethodWithDetails[] | null
  > {
    const methods = await executeQuery<ShippingZoneMethodWithDetails[]>({
      query: `
        SELECT 
          szm.*,
          sm.name as method_name,
          sz.name as zone_name,
          sz.districts as zone_districts
        FROM shipping_zone_methods szm
        JOIN shipping_methods sm ON szm.shipping_method_id = sm.id
        JOIN shipping_zones sz ON szm.shipping_zone_id = sz.id
        WHERE szm.is_active = 1 
        AND sm.is_active = 1 
        AND sz.is_active = 1
        ORDER BY sz.name ASC, sm.display_order ASC, sm.name ASC
      `
    })

    if (methods.length === 0) return null
    return methods
  }

  public async createZoneMethod(
    method: Omit<ShippingZoneMethodRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<ShippingZoneMethodRaw | null> {
    const methodData = {
      ...method,
      created_at: new Date(),
      updated_at: new Date()
    }

    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO shipping_zone_methods SET ?',
      values: [methodData]
    })

    return await this.getZoneMethodById(result.insertId)
  }

  public async updateZoneMethod(
    methodData: Partial<Omit<ShippingZoneMethodRaw, 'id' | 'created_at'>>,
    id: number
  ): Promise<ShippingZoneMethodRaw | null> {
    const updateData = {
      ...methodData,
      updated_at: new Date()
    }

    await executeQuery({
      query: 'UPDATE shipping_zone_methods SET ? WHERE id = ?',
      values: [updateData, id]
    })

    return await this.getZoneMethodById(id)
  }

  public async deleteZoneMethod(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM shipping_zone_methods WHERE id = ?',
      values: [id]
    })
  }

  public async activateZoneMethod(id: number): Promise<void> {
    await executeQuery({
      query:
        'UPDATE shipping_zone_methods SET is_active = 1, updated_at = ? WHERE id = ?',
      values: [new Date(), id]
    })
  }

  public async deactivateZoneMethod(id: number): Promise<void> {
    await executeQuery({
      query:
        'UPDATE shipping_zone_methods SET is_active = 0, updated_at = ? WHERE id = ?',
      values: [new Date(), id]
    })
  }

  public async deleteZoneMethodsByShippingMethodId(
    shippingMethodId: number
  ): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM shipping_zone_methods WHERE shipping_method_id = ?',
      values: [shippingMethodId]
    })
  }

  public async deleteZoneMethodsByZoneId(
    shippingZoneId: number
  ): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM shipping_zone_methods WHERE shipping_zone_id = ?',
      values: [shippingZoneId]
    })
  }
}

const shippingZoneMethodRepository = new ShippingZoneMethodRepository()
export default shippingZoneMethodRepository



üìÅ ARCHIVO: src/backend/shipping-zone-method/ShippingZoneMethod.model.ts
------------------------------------------------------------------------------------
// üìÑ ShippingZoneMethod.model.ts
import { type ShippingZoneMethods as ShippingZoneMethodRaw } from '@/types/database'
import { type ShippingZoneMethods as ShippingZoneMethod } from '@/types/domain'

import oShippingMethodRep from '@/backend/shipping-method/ShippingMethod.repository'
import oShippingZoneRep from '@/backend/shipping-zone/ShippingZone.repository'

import {
  type ShippingCalculation,
  type ShippingZoneMethodExtended
} from './ShippingZoneMethod.interfaces'
import { ShippingZoneMethodMapper } from './ShippingZoneMethod.mapper'
import oShippingZoneMethodRep from './ShippingZoneMethod.repository'

export class ShippingZoneMethodModel {
  public async getZoneMethodById(
    id: number
  ): Promise<ShippingZoneMethod | undefined> {
    const methodRaw = await oShippingZoneMethodRep.getZoneMethodById(id)
    if (!methodRaw) return undefined
    return ShippingZoneMethodMapper(methodRaw)
  }

  public async getZoneMethodByIds(
    shippingMethodId: number,
    shippingZoneId: number
  ): Promise<ShippingZoneMethod | undefined> {
    const methodRaw = await oShippingZoneMethodRep.getZoneMethodByIds(
      shippingMethodId,
      shippingZoneId
    )
    if (!methodRaw) return undefined
    return ShippingZoneMethodMapper(methodRaw)
  }

  public async getZoneMethodsByShippingMethodId(
    shippingMethodId: number
  ): Promise<ShippingZoneMethodExtended[] | undefined> {
    const methodsRaw =
      await oShippingZoneMethodRep.getZoneMethodsByShippingMethodId(
        shippingMethodId
      )
    if (!methodsRaw) return undefined

    return methodsRaw.map((method) => ({
      ...ShippingZoneMethodMapper(method),
      zoneName: method.zone_name,
      zoneDistricts: method.zone_districts
    }))
  }

  public async getZoneMethodsByZoneId(
    shippingZoneId: number
  ): Promise<ShippingZoneMethodExtended[] | undefined> {
    const methodsRaw =
      await oShippingZoneMethodRep.getZoneMethodsByZoneId(shippingZoneId)
    if (!methodsRaw) return undefined

    return methodsRaw.map((method) => ({
      ...ShippingZoneMethodMapper(method),
      methodName: method.method_name
    }))
  }

  public async getAllZoneMethodsWithDetails(): Promise<
    ShippingZoneMethodExtended[] | undefined
  > {
    const methodsRaw =
      await oShippingZoneMethodRep.getAllZoneMethodsWithDetails()
    if (!methodsRaw) return undefined

    return methodsRaw.map((method) => ({
      ...ShippingZoneMethodMapper(method),
      methodName: method.method_name,
      zoneName: method.zone_name,
      zoneDistricts: method.zone_districts
    }))
  }

  public async createZoneMethod(
    methodData: Omit<ShippingZoneMethodRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<ShippingZoneMethod | undefined> {
    const created = await oShippingZoneMethodRep.createZoneMethod(methodData)
    if (!created) return undefined
    return ShippingZoneMethodMapper(created)
  }

  public async updateZoneMethod(
    methodData: Partial<Omit<ShippingZoneMethodRaw, 'id' | 'created_at'>>,
    id: number
  ): Promise<ShippingZoneMethod | undefined> {
    const updated = await oShippingZoneMethodRep.updateZoneMethod(
      methodData,
      id
    )
    if (!updated) return undefined
    return ShippingZoneMethodMapper(updated)
  }

  public async deleteZoneMethod(id: number): Promise<void> {
    await oShippingZoneMethodRep.deleteZoneMethod(id)
  }

  public async activateZoneMethod(id: number): Promise<void> {
    await oShippingZoneMethodRep.activateZoneMethod(id)
  }

  public async deactivateZoneMethod(id: number): Promise<void> {
    await oShippingZoneMethodRep.deactivateZoneMethod(id)
  }

  // M√©todo principal para calcular opciones de env√≠o
  public async calculateShippingOptions(
    district: string,
    province: string,
    department: string,
    orderValue: number
  ): Promise<ShippingCalculation[] | undefined> {
    // Buscar la zona que corresponde a la direcci√≥n

    const zone = await oShippingZoneRep.getShippingZoneByDistrict(
      district,
      province,
      department
    )

    if (!zone) return undefined

    // Obtener m√©todos disponibles para esta zona
    const zoneMethods = await oShippingZoneMethodRep.getZoneMethodsByZoneId(
      zone.id
    )
    if (!zoneMethods) return undefined

    const calculations: ShippingCalculation[] = []

    for (const zoneMethod of zoneMethods) {
      // Obtener detalles del m√©todo de env√≠o base
      const shippingMethod = await oShippingMethodRep.getShippingMethodById(
        zoneMethod.shipping_method_id
      )
      if (!shippingMethod) continue

      // Calcular si el env√≠o es gratis
      const threshold = zoneMethod.free_shipping_threshold

      console.log('threshold', Number(orderValue), '>=', Number(threshold))
      let isFree = false
      if (threshold) {
        isFree = orderValue >= threshold
      }

      console.log('isFree', isFree)
      // const isFree = threshold !== null && orderValue >= threshold

      // Calcular costo final
      const finalCost = isFree ? 0 : zoneMethod.cost

      // Obtener d√≠as estimados (usar los espec√≠ficos de la zona o los del m√©todo base)
      const estimatedDaysMin =
        zoneMethod.estimated_days_min ?? shippingMethod.estimated_days_min ?? 1
      const estimatedDaysMax =
        zoneMethod.estimated_days_max ?? shippingMethod.estimated_days_max ?? 7

      calculations.push({
        methodId: shippingMethod.id,
        zoneId: zone.id,
        baseCost: shippingMethod.base_cost,
        finalCost,
        isFree,
        estimatedDays: {
          min: estimatedDaysMin,
          max: estimatedDaysMax
        },
        methodName: shippingMethod.name,
        zoneName: zone.name
      })
    }

    return calculations.length > 0 ? calculations : undefined
  }

  // M√©todo para obtener costo espec√≠fico de un m√©todo en una zona
  public async getShippingCost(
    shippingMethodId: number,
    district: string,
    province: string,
    department: string,
    orderValue: number
  ): Promise<ShippingCalculation | undefined> {
    const zone = await oShippingZoneRep.getShippingZoneByDistrict(
      district,
      province,
      department
    )
    if (!zone) return undefined

    const zoneMethod = await oShippingZoneMethodRep.getZoneMethodByIds(
      shippingMethodId,
      zone.id
    )
    if (!zoneMethod) return undefined

    const shippingMethod =
      await oShippingMethodRep.getShippingMethodById(shippingMethodId)
    if (!shippingMethod) return undefined

    const threshold = zoneMethod.free_shipping_threshold
    const isFree = threshold !== null && orderValue >= threshold
    const finalCost = isFree ? 0 : zoneMethod.cost

    const estimatedDaysMin =
      zoneMethod.estimated_days_min ?? shippingMethod.estimated_days_min ?? 1
    const estimatedDaysMax =
      zoneMethod.estimated_days_max ?? shippingMethod.estimated_days_max ?? 7

    return {
      methodId: shippingMethod.id,
      zoneId: zone.id,
      baseCost: shippingMethod.base_cost,
      finalCost,
      isFree,
      estimatedDays: {
        min: estimatedDaysMin,
        max: estimatedDaysMax
      },
      methodName: shippingMethod.name,
      zoneName: zone.name
    }
  }

  // M√©todo para validar si un m√©todo est√° disponible en una direcci√≥n
  public async isMethodAvailableForAddress(
    shippingMethodId: number,
    district: string,
    province: string,
    department: string
  ): Promise<boolean> {
    const zone = await oShippingZoneRep.getShippingZoneByDistrict(
      district,
      province,
      department
    )
    if (!zone) return false

    const zoneMethod = await oShippingZoneMethodRep.getZoneMethodByIds(
      shippingMethodId,
      zone.id
    )
    return zoneMethod !== null
  }
}

const shippingZoneMethodModel = new ShippingZoneMethodModel()
export default shippingZoneMethodModel



üìÅ ARCHIVO: src/backend/shipping-zone-method/ShippingZoneMethod.mapper.ts
------------------------------------------------------------------------------------
import { type ShippingZoneMethods as ShippingZoneMethodRaw } from '@/types/database'
import { type ShippingZoneMethods as ShippingZoneMethod } from '@/types/domain'

export const ShippingZoneMethodMapper = (
  data: ShippingZoneMethodRaw
): ShippingZoneMethod => {
  return {
    id: data.id,
    shippingMethodId: data.shipping_method_id,
    shippingZoneId: data.shipping_zone_id,
    cost: data.cost,
    estimatedDaysMin: data.estimated_days_min,
    estimatedDaysMax: data.estimated_days_max,
    freeShippingThreshold: data.free_shipping_threshold,
    isActive: data.is_active,
    createdAt: data.created_at,
    updatedAt: data.updated_at
  }
}

export const ShippingZoneMethodsMapper = (
  data: ShippingZoneMethodRaw[] | null
): ShippingZoneMethod[] | undefined => {
  if (data === null) return undefined
  return data.map(ShippingZoneMethodMapper)
}



üìÅ ARCHIVO: src/backend/shipping-zone-method/index.ts
------------------------------------------------------------------------------------
// üìÑ index.ts
export * from './ShippingZoneMethod.interfaces'
export * from './ShippingZoneMethod.mapper'
export { default } from './ShippingZoneMethod.model'
export * from './ShippingZoneMethod.repository'



üìÅ ARCHIVO: src/backend/shipping-zone-method/ShippingZoneMethod.interfaces.ts
------------------------------------------------------------------------------------
// üìÑ ShippingZoneMethod.interfaces.ts
import { type ShippingZoneMethods as ShippingZoneMethod } from '@/types/domain'

export interface ShippingZoneMethodExtended extends ShippingZoneMethod {
  methodName?: string
  zoneName?: string
  zoneDistricts?: any[]
}

export interface ShippingCalculation {
  methodId: number
  zoneId: number
  baseCost: number
  finalCost: number
  isFree: boolean
  estimatedDays: {
    min: number
    max: number
  }
  methodName: string
  zoneName: string
}



üìÅ ARCHIVO: src/backend/shipping-zone/ShippingZone.mapper.ts
------------------------------------------------------------------------------------
// üìÑ ShippingZone.mapper.ts
import { type ShippingZones as ShippingZoneRaw } from '@/types/database'
import { type ShippingZones as ShippingZone } from '@/types/domain'

export const ShippingZoneMapper = (data: ShippingZoneRaw): ShippingZone => {
  return {
    id: data.id,
    name: data.name,
    districts: data.districts,
    isActive: data.is_active,
    createdAt: data.created_at,
    updatedAt: data.updated_at
  }
}

export const ShippingZonesMapper = (
  data: ShippingZoneRaw[] | null
): ShippingZone[] | undefined => {
  if (data === null) return undefined
  return data.map(ShippingZoneMapper)
}



üìÅ ARCHIVO: src/backend/shipping-zone/ShippingZone.repository.ts
------------------------------------------------------------------------------------
// üìÑ ShippingZone.repository.ts
import { executeQuery } from '@/lib/db'
import { type ShippingZones as ShippingZoneRaw } from '@/types/database'
import { type DistrictInfo } from './ShippingZone.interfaces'

export class ShippingZoneRepository {
  public async getShippingZones(): Promise<ShippingZoneRaw[] | null> {
    const zones = await executeQuery<ShippingZoneRaw[]>({
      query: `
        SELECT * FROM shipping_zones 
        WHERE is_active = 1 
        ORDER BY name ASC
      `
    })

    if (zones.length === 0) return null
    return zones
  }

  public async getShippingZoneById(
    id: number
  ): Promise<ShippingZoneRaw | null> {
    const zones = await executeQuery<ShippingZoneRaw[]>({
      query: 'SELECT * FROM shipping_zones WHERE id = ?',
      values: [id]
    })

    if (zones.length === 0) return null
    return zones[0]
  }

  public async getShippingZoneByDistrict(
    district: string,
    province?: string,
    department?: string
  ): Promise<ShippingZoneRaw | null> {
    const zones = await executeQuery<ShippingZoneRaw[]>({
      query: `
        SELECT * FROM shipping_zones 
        WHERE JSON_CONTAINS(districts, ?) 
        AND is_active = 1
        LIMIT 1
      `,
      values: [JSON.stringify(district)]
    })

    // console.log('zones', zones)

    if (zones.length === 0) return null
    return zones[0]
  }

  public async createShippingZone(
    zone: Omit<ShippingZoneRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<ShippingZoneRaw | null> {
    const zoneData = {
      ...zone,
      created_at: new Date(),
      updated_at: new Date()
    }

    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO shipping_zones SET ?',
      values: [zoneData]
    })

    return await this.getShippingZoneById(result.insertId)
  }

  public async updateShippingZone(
    zoneData: Partial<Omit<ShippingZoneRaw, 'id' | 'created_at'>>,
    id: number
  ): Promise<ShippingZoneRaw | null> {
    const updateData = {
      ...zoneData,
      updated_at: new Date()
    }

    await executeQuery({
      query: 'UPDATE shipping_zones SET ? WHERE id = ?',
      values: [updateData, id]
    })

    return await this.getShippingZoneById(id)
  }

  public async deleteShippingZone(id: number): Promise<void> {
    // Primero eliminar las relaciones con m√©todos de env√≠o
    await executeQuery({
      query: 'DELETE FROM shipping_zone_methods WHERE shipping_zone_id = ?',
      values: [id]
    })

    // Luego eliminar la zona
    await executeQuery({
      query: 'DELETE FROM shipping_zones WHERE id = ?',
      values: [id]
    })
  }

  public async activateShippingZone(id: number): Promise<void> {
    await executeQuery({
      query:
        'UPDATE shipping_zones SET is_active = 1, updated_at = ? WHERE id = ?',
      values: [new Date(), id]
    })
  }

  public async deactivateShippingZone(id: number): Promise<void> {
    await executeQuery({
      query:
        'UPDATE shipping_zones SET is_active = 0, updated_at = ? WHERE id = ?',
      values: [new Date(), id]
    })
  }

  public async addDistrictToZone(
    zoneId: number,
    district: DistrictInfo
  ): Promise<void> {
    // Obtener la zona actual
    const zone = await this.getShippingZoneById(zoneId)
    if (!zone) throw new Error('Zona de env√≠o no encontrada')

    // Parsear distritos actuales
    const currentDistricts = Array.isArray(zone.districts)
      ? zone.districts
      : JSON.parse(zone.districts as string)

    // Agregar nuevo distrito si no existe
    const exists = currentDistricts.some(
      (d: DistrictInfo) =>
        d.name === district.name &&
        d.province === district.province &&
        d.department === district.department
    )

    if (!exists) {
      currentDistricts.push(district)

      await executeQuery({
        query:
          'UPDATE shipping_zones SET districts = ?, updated_at = ? WHERE id = ?',
        values: [JSON.stringify(currentDistricts), new Date(), zoneId]
      })
    }
  }

  public async removeDistrictFromZone(
    zoneId: number,
    district: DistrictInfo
  ): Promise<void> {
    // Obtener la zona actual
    const zone = await this.getShippingZoneById(zoneId)
    if (!zone) throw new Error('Zona de env√≠o no encontrada')

    // Parsear distritos actuales
    const currentDistricts = Array.isArray(zone.districts)
      ? zone.districts
      : JSON.parse(zone.districts as string)

    // Filtrar el distrito a eliminar
    const updatedDistricts = currentDistricts.filter(
      (d: DistrictInfo) =>
        !(
          d.name === district.name &&
          d.province === district.province &&
          d.department === district.department
        )
    )

    await executeQuery({
      query:
        'UPDATE shipping_zones SET districts = ?, updated_at = ? WHERE id = ?',
      values: [JSON.stringify(updatedDistricts), new Date(), zoneId]
    })
  }
}

const shippingZoneRepository = new ShippingZoneRepository()
export default shippingZoneRepository



üìÅ ARCHIVO: src/backend/shipping-zone/ShippingZone.interfaces.ts
------------------------------------------------------------------------------------
// üìÑ ShippingZone.interfaces.ts
import { type ShippingZones as ShippingZone } from '@/types/domain'

export interface ShippingZoneWithMethods extends ShippingZone {
  methods?: ShippingZoneMethodInfo[]
}

export interface ShippingZoneMethodInfo {
  id: number
  shippingMethodId: number
  methodName: string
  cost: number
  estimatedDaysMin?: number
  estimatedDaysMax?: number
  freeShippingThreshold?: number
  isActive?: number
}

export interface DistrictInfo {
  name: string
  province: string
  department: string
}



üìÅ ARCHIVO: src/backend/shipping-zone/ShippingZone.model.ts
------------------------------------------------------------------------------------
// üìÑ ShippingZone.model.ts
import { type ShippingZones as ShippingZoneRaw } from '@/types/database'
import { type ShippingZones as ShippingZone } from '@/types/domain'

import oShippingZoneMethodRep from '@/backend/shipping-zone-method'
import {
  type DistrictInfo,
  type ShippingZoneWithMethods
} from './ShippingZone.interfaces'
import { ShippingZoneMapper, ShippingZonesMapper } from './ShippingZone.mapper'
import oShippingZoneRep from './ShippingZone.repository'

export class ShippingZoneModel {
  public async getShippingZones(): Promise<ShippingZone[] | undefined> {
    const zonesRaw = await oShippingZoneRep.getShippingZones()
    return ShippingZonesMapper(zonesRaw)
  }

  public async getShippingZoneById(
    id: number
  ): Promise<ShippingZone | undefined> {
    const zoneRaw = await oShippingZoneRep.getShippingZoneById(id)
    if (!zoneRaw) return undefined
    return ShippingZoneMapper(zoneRaw)
  }

  public async getShippingZoneByAddress(
    district: string,
    province: string,
    department: string
  ): Promise<ShippingZone | undefined> {
    const zoneRaw = await oShippingZoneRep.getShippingZoneByDistrict(
      district,
      province,
      department
    )
    if (!zoneRaw) return undefined
    return ShippingZoneMapper(zoneRaw)
  }

  public async getShippingZonesWithMethods(): Promise<
    ShippingZoneWithMethods[] | undefined
  > {
    const zones = await this.getShippingZones()
    if (!zones) return undefined

    const zonesWithMethods: ShippingZoneWithMethods[] = []

    for (const zone of zones) {
      const methods = await oShippingZoneMethodRep.getZoneMethodsByZoneId(
        zone.id
      )
      zonesWithMethods.push({
        ...zone,
        methods: methods || []
      })
    }

    return zonesWithMethods
  }

  public async createShippingZone(
    zoneData: Omit<ShippingZoneRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<ShippingZone | undefined> {
    const created = await oShippingZoneRep.createShippingZone(zoneData)
    if (!created) return undefined
    return ShippingZoneMapper(created)
  }

  public async updateShippingZone(
    zoneData: Partial<Omit<ShippingZoneRaw, 'id' | 'created_at'>>,
    id: number
  ): Promise<ShippingZone | undefined> {
    const updated = await oShippingZoneRep.updateShippingZone(zoneData, id)
    if (!updated) return undefined
    return ShippingZoneMapper(updated)
  }

  public async deleteShippingZone(id: number): Promise<void> {
    await oShippingZoneRep.deleteShippingZone(id)
  }

  public async activateShippingZone(id: number): Promise<void> {
    await oShippingZoneRep.activateShippingZone(id)
  }

  public async deactivateShippingZone(id: number): Promise<void> {
    await oShippingZoneRep.deactivateShippingZone(id)
  }

  public async addDistrictToZone(
    zoneId: number,
    district: DistrictInfo
  ): Promise<void> {
    await oShippingZoneRep.addDistrictToZone(zoneId, district)
  }

  public async removeDistrictFromZone(
    zoneId: number,
    district: DistrictInfo
  ): Promise<void> {
    await oShippingZoneRep.removeDistrictFromZone(zoneId, district)
  }

  // M√©todo helper para obtener distritos formateados
  public getDistrictsFromZone(zone: ShippingZone): DistrictInfo[] {
    if (!zone.districts) return []

    if (Array.isArray(zone.districts)) {
      return zone.districts as DistrictInfo[]
    }

    try {
      return JSON.parse(zone.districts as string) as DistrictInfo[]
    } catch {
      return []
    }
  }

  // M√©todo para verificar si una direcci√≥n est√° en una zona
  public isAddressInZone(
    zone: ShippingZone,
    district: string,
    province: string,
    department: string
  ): boolean {
    const districts = this.getDistrictsFromZone(zone)

    return districts.some(
      (d) =>
        d.name.toLowerCase() === district.toLowerCase() &&
        d.province.toLowerCase() === province.toLowerCase() &&
        d.department.toLowerCase() === department.toLowerCase()
    )
  }
}

const shippingZoneModel = new ShippingZoneModel()
export default shippingZoneModel



üìÅ ARCHIVO: src/backend/shipping-zone/index.ts
------------------------------------------------------------------------------------
// üìÑ index.ts
export * from './ShippingZone.interfaces'
export * from './ShippingZone.mapper'
export { default } from './ShippingZone.model'
export * from './ShippingZone.repository'



üìÅ ARCHIVO: src/backend/brand/Brand.mapper.ts
------------------------------------------------------------------------------------
import { type Brands as BrandRaw } from '@/types/database'
import { type Brands as Brand } from '@/types/domain'

export const BrandMapper = (data: BrandRaw): Brand => {
  return {
    ...data,
    products: undefined
  }
}

export const BrandsMapper = (data: BrandRaw[] | null): Brand[] | undefined => {
  if (data === null) return undefined
  return data.map(BrandMapper)
}



üìÅ ARCHIVO: src/backend/brand/Brand.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type Brands as BrandsRaw } from '@/types/database'

export class BrandRepository {
  public async getBrands(): Promise<BrandsRaw[] | null> {
    const brands = await executeQuery<BrandsRaw[]>({
      query: 'SELECT * FROM brands'
    })

    if (brands.length === 0) return null
    return brands
  }

  public async getBrandById(id: number): Promise<BrandsRaw | null> {
    const brands = await executeQuery<BrandsRaw[]>({
      query: 'SELECT * FROM brands WHERE id = ?',
      values: [id]
    })

    if (brands.length === 0) return null
    return brands[0]
  }

  public async createBrand(
    brand: Omit<BrandsRaw, 'id'>
  ): Promise<BrandsRaw | null> {
    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO brands SET ?',
      values: [brand]
    })

    return await this.getBrandById(result.insertId)
  }

  public async updateBrand(
    brandData: Omit<BrandsRaw, 'id'>,
    id: number
  ): Promise<BrandsRaw | null> {
    await executeQuery({
      query: 'UPDATE brands SET ? WHERE id=?',
      values: [brandData, id]
    })

    return await this.getBrandById(id)
  }

  public async deleteBrand(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM brands WHERE id=?',
      values: [id]
    })
  }
}

const brandRepository = new BrandRepository()
export default brandRepository



üìÅ ARCHIVO: src/backend/brand/index.ts
------------------------------------------------------------------------------------
export * from './Brand.mapper'
export { default } from './Brand.model'
export * from './Brand.repository'



üìÅ ARCHIVO: src/backend/brand/Brand.model.ts
------------------------------------------------------------------------------------
import { type Brands as BrandsRaw } from '@/types/database'
import { type Brands as Brand } from '@/types/domain'

// me
import { BrandMapper, BrandsMapper } from './Brand.mapper'
import oBrandRep from './Brand.repository'

export class BrandModel {
  public async getBrands(): Promise<Brand[] | undefined> {
    const brandsRaw = await oBrandRep.getBrands()
    return BrandsMapper(brandsRaw)
  }

  public async getBrandById(id: number): Promise<Brand | undefined> {
    const brandRaw = await oBrandRep.getBrandById(id)
    if (!brandRaw) return undefined
    return BrandMapper(brandRaw)
  }

  public async createBrand(
    brandData: Omit<BrandsRaw, 'id'>
  ): Promise<Brand | undefined> {
    const created = await oBrandRep.createBrand(brandData)
    if (!created) return undefined
    return BrandMapper(created)
  }

  public async updateBrand(
    brandData: Omit<BrandsRaw, 'id'>,
    id: number
  ): Promise<Brand | undefined> {
    const updated = await oBrandRep.updateBrand(brandData, id)
    if (!updated) return undefined
    return BrandMapper(updated)
  }

  public async deleteBrand(id: number): Promise<void> {
    await oBrandRep.deleteBrand(id)
  }
}

const brandModel = new BrandModel()
export default brandModel



üìÅ ARCHIVO: src/backend/product-variant/ProductVariant.model.ts
------------------------------------------------------------------------------------
// others
import oAttributeOptionImageModel from '@/backend/attribute-option-image'
import oPromotionVariantModel from '@/backend/promotion-variant'
import oVariantAttributeOptionModel from '@/backend/variant-attribute-option'
import oVariantImageModel from '@/backend/variant-image'
import oVariantRatingModel, {
  type VariantRatingWithCustomer
} from '@/backend/variant-rating'

// me
import {
  ProductVariantMapper,
  ProductVariantsMapper
} from './ProductVariant.mapper'

import oProductVariantRep from './ProductVariant.repository'

import { type ProductVariants as ProductVariantRaw } from '@/types/database'
import {
  type AttributeOptionImages,
  type ProductVariants as ProductVariant,
  type VariantAttributeOptions as VariantAttributeOption,
  type VariantAttributeOptions
} from '@/types/domain'

import attributeOptionImageModel from '@/backend/attribute-option-image'
import variantAttributeOptionModel from '@/backend/variant-attribute-option'
import variantRatingModel from '@/backend/variant-rating'
import {
  type ProductVariantComplete,
  type ProductVariantWithAttributeOptions,
  type ProductVariantWithImages
} from './ProductVariant.interfaces'

export class ProductVariantModel {
  public async getProductVariants(): Promise<ProductVariant[] | undefined> {
    const variantsRaw = await oProductVariantRep.getProductVariants()
    return ProductVariantsMapper(variantsRaw)
  }

  public async getProductVariantById(
    id: number
  ): Promise<ProductVariant | undefined> {
    const variantRaw = await oProductVariantRep.getProductVariantById(id)
    if (!variantRaw) return undefined
    return ProductVariantMapper(variantRaw)
  }

  public async getProductVariantsByProductId(
    productId: number
  ): Promise<ProductVariant[] | undefined> {
    const variantsRaw =
      await oProductVariantRep.getProductVariantsByProductId(productId)
    return ProductVariantsMapper(variantsRaw)
  }

  public async getProductVariantBySku(
    sku: string
  ): Promise<ProductVariant | undefined> {
    const variantRaw = await oProductVariantRep.getProductVariantBySku(sku)
    if (!variantRaw) return undefined
    return ProductVariantMapper(variantRaw)
  }

  public async createProductVariant(
    variantData: Omit<ProductVariantRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<ProductVariant | undefined> {
    const created = await oProductVariantRep.createProductVariant(variantData)
    if (!created) return undefined
    return ProductVariantMapper(created)
  }

  public async updateProductVariant(
    variantData: Partial<
      Omit<ProductVariantRaw, 'id' | 'created_at' | 'updated_at'>
    >,
    id: number
  ): Promise<ProductVariant | undefined> {
    const updated = await oProductVariantRep.updateProductVariant(
      variantData,
      id
    )
    if (!updated) return undefined
    return ProductVariantMapper(updated)
  }

  public async deleteProductVariant(id: number): Promise<void> {
    await oProductVariantRep.deleteProductVariant(id)
  }

  public async deleteProductVariantsByProductId(
    productId: number
  ): Promise<void> {
    await oProductVariantRep.deleteProductVariantsByProductId(productId)
  }

  public async updateProductVariantStock(
    id: number,
    stock: number
  ): Promise<ProductVariant | undefined> {
    const updated = await oProductVariantRep.updateProductVariantStock(
      id,
      stock
    )
    if (!updated) return undefined
    return ProductVariantMapper(updated)
  }

  public async getProductVariantsWithAttributeOptions(): Promise<
    ProductVariantWithAttributeOptions[] | undefined
  > {
    const variantsRaw = await oProductVariantRep.getProductVariants()
    const variants = ProductVariantsMapper(variantsRaw)

    if (!variants) return undefined

    const variantIds = variants.map((variant) => variant.id)
    const attributeOptionsByVariantId =
      await oVariantAttributeOptionModel.getVariantAttributeOptionsByVariantIds(
        variantIds
      )

    return variants.map((variant) => ({
      ...variant,
      variantAttributeOptions: attributeOptionsByVariantId.get(variant.id) || []
    }))
  }

  public async getProductVariantByIdWithAttributeOptions(
    id: number
  ): Promise<ProductVariantWithAttributeOptions | undefined> {
    const variantRaw = await oProductVariantRep.getProductVariantById(id)
    if (!variantRaw) return undefined

    const variant = ProductVariantMapper(variantRaw)
    const attributeOptions =
      await oVariantAttributeOptionModel.getVariantAttributeOptionsByVariantId(
        id
      )

    return {
      ...variant,
      variantAttributeOptions: attributeOptions || []
    }
  }

  public async getProductVariantsByProductIdWithAttributeOptions(
    productId: number
  ): Promise<ProductVariantWithAttributeOptions[] | undefined> {
    const variantsRaw =
      await oProductVariantRep.getProductVariantsByProductId(productId)
    const variants = ProductVariantsMapper(variantsRaw)

    if (!variants) return undefined

    return await Promise.all(
      variants.map(async (variant) => {
        // Obtener atributos usando composici√≥n con datos completos
        const variantAttributeOptionWithDetails =
          await oVariantAttributeOptionModel.getVariantAttributeOptionsWithDetailsById(
            variant.id
          )

        const attributeOptions: VariantAttributeOption[] =
          variantAttributeOptionWithDetails?.map((option) => ({
            variantId: option.variantId,
            attributeOptionId: option.attributeOptionId,
            attributeOption: option.attributeOption
          })) || []

        return {
          ...variant,
          variantAttributeOptions: attributeOptions
        }
      })
    )
  }

  public async getProductVariantsByProductIds(
    productIds: number[]
  ): Promise<Map<number, ProductVariant[]>> {
    const variantsRaw =
      await oProductVariantRep.getProductVariantsByProductIds(productIds)

    if (!variantsRaw) return new Map()

    const variantsByProductId = new Map<number, ProductVariant[]>()

    for (const variantRaw of variantsRaw) {
      const variant = ProductVariantMapper(variantRaw)
      const productId = variant.productId

      if (!variantsByProductId.has(productId)) {
        variantsByProductId.set(productId, [])
      }

      variantsByProductId.get(productId)!.push(variant)
    }

    return variantsByProductId
  }

  public async getProductVariantWithImages(
    id: number
  ): Promise<ProductVariantWithImages | undefined> {
    const variantRaw = await oProductVariantRep.getProductVariantById(id)
    if (!variantRaw) return undefined

    const variant = ProductVariantMapper(variantRaw)
    const images = await oVariantImageModel.getVariantImages(id)

    return {
      ...variant,
      variantImages: images
    }
  }

  public async getVariantAttributeOptions(
    variantId: number
  ): Promise<VariantAttributeOptions[] | undefined> {
    const variantAttributeOptionWithDetails =
      await variantAttributeOptionModel.getVariantAttributeOptionsWithDetailsById(
        variantId
      )

    const attributeOptions: VariantAttributeOptions[] = await Promise.all(
      variantAttributeOptionWithDetails?.map(async (option) => ({
        variantId: option.variantId,
        attributeOptionId: option.attributeOptionId,
        attributeOption: {
          ...option.attributeOption,
          attributeOptionImages:
            await attributeOptionImageModel.getAttributeOptionImages(
              option.attributeOptionId
            ),
          attributeId: Number(option.attributeOption?.attributeId),
          id: Number(option.attributeOption?.id),
          value: option.attributeOption?.value || '',
          attribute: {
            ...option.attributeOption?.attribute,
            id: Number(option.attributeOption?.attribute?.id),
            displayType:
              option.attributeOption?.attribute?.displayType || 'color',
            name: option.attributeOption?.attribute?.name || ''
          }
        }
      })) || []
    )
    return attributeOptions
  }

  public async getProductVariant(
    id: number
  ): Promise<ProductVariantComplete | undefined> {
    const variantRaw = await oProductVariantRep.getProductVariantById(id)
    if (!variantRaw) return undefined

    const variant = ProductVariantMapper(variantRaw)

    const variantAttributeOptions =
      await productVariantModel.getVariantAttributeOptions(id)

    // Obtener im√°genes de la variante
    const variantImages = await oVariantImageModel.getVariantImages(id)

    // Obtener promoci√≥n usando composici√≥n
    const promotionsVariant =
      await oPromotionVariantModel.getPromotionsForVariant(id)

    // Obtener ratings usando composici√≥n
    const ratingSummary = await oVariantRatingModel.getVariantRatingSummary(id)

    const variantRatingSearch =
      await variantRatingModel.getRatingsByVariantId(id)

    const variantRatings: VariantRatingWithCustomer[] =
      variantRatingSearch.ratings.map((rating) => ({
        ...rating
      }))

    const result: ProductVariantComplete = {
      ...variant,
      variantAttributeOptions,
      variantImages,
      variantRatings
    }

    // A√±adir promoci√≥n si existe
    // if (bestPromotion) {
    result.promotionVariants = promotionsVariant
    // }

    // A√±adir ratings si existen
    if (ratingSummary && ratingSummary.totalRatings > 0) {
      result.variantRatingSummary = {
        variantId: ratingSummary.variantId,
        totalRatings: ratingSummary.totalRatings,
        averageRating: ratingSummary.averageRating,
        fiveStar: ratingSummary.fiveStar,
        fourStar: ratingSummary.fourStar,
        threeStar: ratingSummary.threeStar,
        twoStar: ratingSummary.twoStar,
        oneStar: ratingSummary.oneStar,
        verifiedPurchases: ratingSummary.verifiedPurchases
      }
    }

    return result
  }

  // ============================================================================
  // M√âTODOS PARA ATRIBUTOS (delegados al modelo VariantAttributeOption)
  // ============================================================================

  public async addAttributeOptionToVariant(
    variantId: number,
    attributeOptionId: number
  ): Promise<void> {
    await oVariantAttributeOptionModel.addAttributeOptionToVariant(
      variantId,
      attributeOptionId
    )
  }

  public async removeAttributeOptionFromVariant(
    variantId: number,
    attributeOptionId: number
  ): Promise<void> {
    await oVariantAttributeOptionModel.removeAttributeOptionFromVariant(
      variantId,
      attributeOptionId
    )
  }

  // ============================================================================
  // M√âTODOS PARA OBTENER IM√ÅGENES DE ATRIBUTOS (usando composici√≥n)
  // ============================================================================

  private async getAttributeImagesForVariant(
    variantId: number,
    productId: number
  ): Promise<AttributeOptionImages[]> {
    // Obtener los attribute option IDs de esta variante
    const attributeOptions =
      await oVariantAttributeOptionModel.getVariantAttributeOptionsByVariantId(
        variantId
      )

    if (!attributeOptions || attributeOptions.length === 0) {
      return []
    }

    // Obtener todas las opciones de atributos del producto usando el repository
    const productAttributeOptionIds =
      await oProductVariantRep.getAttributeOptionIdsByProductId(productId)

    if (!productAttributeOptionIds || productAttributeOptionIds.length === 0) {
      return []
    }

    const allOptionIds = productAttributeOptionIds.map(
      (row) => row.attribute_option_id
    )

    // Usar el modelo de AttributeOptionImage para obtener las im√°genes
    const imagesByOptionId =
      await oAttributeOptionImageModel.getAttributeOptionImagesByOptionIds(
        allOptionIds
      )

    // Convertir el Map a array
    const allImages: AttributeOptionImages[] = []
    imagesByOptionId.forEach((images: AttributeOptionImages[]) => {
      allImages.push(...images)
    })

    return allImages
  }

  // ============================================================================
  // ALIAS PARA COMPATIBILIDAD CON ProductVariantModel.ts ORIGINAL
  // ============================================================================

  public async getVariants() {
    return await this.getProductVariants()
  }

  public async getVariantById(id: number) {
    return await this.getProductVariant(id)
  }

  public async getVariantsByProductId(productId: number) {
    return await this.getProductVariantsByProductIdWithAttributeOptions(
      productId
    )
  }

  public async createVariant(
    variant: Omit<ProductVariantRaw, 'id' | 'created_at' | 'updated_at'>
  ) {
    return await this.createProductVariant(variant)
  }

  public async updateVariant(
    variantData: Partial<
      Omit<ProductVariantRaw, 'id' | 'created_at' | 'updated_at'>
    >,
    id: number
  ) {
    return await this.updateProductVariant(variantData, id)
  }

  public async deleteVariant(id: number) {
    await this.deleteProductVariant(id)
  }

  /**
   * Actualizar stock de una variante (puede ser positivo o negativo)
   * @param id - ID de la variante
   * @param quantityChange - Cambio en el stock (negativo para reducir, positivo para aumentar)
   */
  public async updateStock(
    id: number,
    quantityChange: number
  ): Promise<ProductVariant | undefined> {
    const updated = await oProductVariantRep.updateStock(id, quantityChange)
    if (!updated) return undefined
    return ProductVariantMapper(updated)
  }

  /**
   * Establecer stock exacto de una variante
   * @param id - ID de la variante
   * @param newStock - Nuevo stock
   */
  public async setStock(
    id: number,
    newStock: number
  ): Promise<ProductVariant | undefined> {
    const updated = await oProductVariantRep.setStock(id, newStock)
    if (!updated) return undefined
    return ProductVariantMapper(updated)
  }

  /**
   * Reducir stock de una variante
   * @param id - ID de la variante
   * @param quantity - Cantidad a reducir
   */
  public async reduceStock(
    id: number,
    quantity: number
  ): Promise<ProductVariant | undefined> {
    return await this.updateStock(id, -quantity)
  }

  /**
   * Aumentar stock de una variante
   * @param id - ID de la variante
   * @param quantity - Cantidad a aumentar
   */
  public async increaseStock(
    id: number,
    quantity: number
  ): Promise<ProductVariant | undefined> {
    return await this.updateStock(id, quantity)
  }

  /**
   * Verificar si hay stock suficiente
   * @param id - ID de la variante
   * @param requiredQuantity - Cantidad requerida
   */
  public async hasEnoughStock(
    id: number,
    requiredQuantity: number
  ): Promise<boolean> {
    const variant = await this.getProductVariantById(id)
    if (!variant) return false
    return variant.stock >= requiredQuantity
  }

  /**
   * Obtener variantes con stock bajo
   * @param threshold - Umbral de stock bajo (por defecto 10)
   */
  public async getVariantsWithLowStock(
    threshold: number = 10
  ): Promise<ProductVariant[] | undefined> {
    // Necesitar√≠as agregar este m√©todo al repository tambi√©n
    const variantsRaw =
      await oProductVariantRep.getVariantsWithLowStock(threshold)
    return ProductVariantsMapper(variantsRaw)
  }
}

const productVariantModel = new ProductVariantModel()
export default productVariantModel



üìÅ ARCHIVO: src/backend/product-variant/ProductVariant.interfaces.ts
------------------------------------------------------------------------------------
import {
  type ProductVariants as ProductVariant,
  type VariantAttributeOptions as VariantAttributeOption,
  type VariantImages as VariantImage,
  type VariantRatingSummary
} from '@/types/domain'

export interface ProductVariantWithAttributeOptions extends ProductVariant {
  variantAttributeOptions: VariantAttributeOption[]
}

export interface ProductVariantWithImages extends ProductVariant {
  variantImages?: VariantImage[]
}
export interface ProductVariantComplete extends ProductVariant {
  variantRatingSummary?: VariantRatingSummary
}



üìÅ ARCHIVO: src/backend/product-variant/ProductVariant.mapper.ts
------------------------------------------------------------------------------------
import { type ProductVariants as ProductVariantRaw } from '@/types/database'
import { type ProductVariants as ProductVariant } from '@/types/domain'

export const ProductVariantMapper = (
  data: ProductVariantRaw
): ProductVariant => {
  return {
    id: data.id,
    productId: data.product_id,
    sku: data.sku,
    price: data.price,
    stock: data.stock,
    createdAt: data.created_at,
    updatedAt: data.updated_at,
    product: undefined,
    promotionVariants: undefined,
    variantAttributeOptions: undefined,
    variantImages: undefined,
    variantRatings: undefined
  }
}

export const ProductVariantsMapper = (
  data: ProductVariantRaw[] | null
): ProductVariant[] | undefined => {
  if (data === null) return undefined
  return data.map(ProductVariantMapper)
}



üìÅ ARCHIVO: src/backend/product-variant/index.ts
------------------------------------------------------------------------------------
export * from './ProductVariant.interfaces'
export * from './ProductVariant.mapper'
export { default } from './ProductVariant.model'
export * from './ProductVariant.repository'



üìÅ ARCHIVO: src/backend/product-variant/ProductVariant.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type ProductVariants as ProductVariantRaw } from '@/types/database'

export class ProductVariantRepository {
  public async getProductVariants(): Promise<ProductVariantRaw[] | null> {
    const variants = await executeQuery<ProductVariantRaw[]>({
      query: 'SELECT * FROM product_variants ORDER BY id ASC'
    })

    if (variants.length === 0) return null
    return variants
  }

  public async getProductVariantById(
    id: number
  ): Promise<ProductVariantRaw | null> {
    const variants = await executeQuery<ProductVariantRaw[]>({
      query: 'SELECT * FROM product_variants WHERE id = ?',
      values: [id]
    })

    if (variants.length === 0) return null
    return variants[0]
  }

  public async getProductVariantsByProductId(
    productId: number
  ): Promise<ProductVariantRaw[] | null> {
    const variants = await executeQuery<ProductVariantRaw[]>({
      query:
        'SELECT * FROM product_variants WHERE product_id = ? ORDER BY id ASC',
      values: [productId]
    })

    if (variants.length === 0) return null
    return variants
  }

  public async getProductVariantsByProductIds(
    productIds: number[]
  ): Promise<ProductVariantRaw[] | null> {
    if (productIds.length === 0) return null

    const placeholders = productIds.map(() => '?').join(',')
    const variants = await executeQuery<ProductVariantRaw[]>({
      query: `SELECT * FROM product_variants WHERE product_id IN (${placeholders}) ORDER BY product_id, id ASC`,
      values: productIds
    })

    if (variants.length === 0) return null
    return variants
  }

  public async getProductVariantBySku(
    sku: string
  ): Promise<ProductVariantRaw | null> {
    const variants = await executeQuery<ProductVariantRaw[]>({
      query: 'SELECT * FROM product_variants WHERE sku = ?',
      values: [sku]
    })

    if (variants.length === 0) return null
    return variants[0]
  }

  public async createProductVariant(
    variant: Omit<ProductVariantRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<ProductVariantRaw | null> {
    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO product_variants SET ?',
      values: [variant]
    })

    return await this.getProductVariantById(result.insertId)
  }

  public async updateProductVariant(
    variantData: Partial<
      Omit<ProductVariantRaw, 'id' | 'created_at' | 'updated_at'>
    >,
    id: number
  ): Promise<ProductVariantRaw | null> {
    await executeQuery({
      query: 'UPDATE product_variants SET ? WHERE id = ?',
      values: [variantData, id]
    })

    return await this.getProductVariantById(id)
  }

  public async deleteProductVariant(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM product_variants WHERE id = ?',
      values: [id]
    })
  }

  public async deleteProductVariantsByProductId(
    productId: number
  ): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM product_variants WHERE product_id = ?',
      values: [productId]
    })
  }

  public async updateProductVariantStock(
    id: number,
    stock: number
  ): Promise<ProductVariantRaw | null> {
    await executeQuery({
      query: 'UPDATE product_variants SET stock = ? WHERE id = ?',
      values: [stock, id]
    })

    return await this.getProductVariantById(id)
  }

  public async getAttributeOptionIdsByProductId(
    productId: number
  ): Promise<Array<{ attribute_option_id: number }> | null> {
    const optionIds = await executeQuery<Array<{ attribute_option_id: number }>>({
      query: `
        SELECT DISTINCT vao.attribute_option_id
        FROM variant_attribute_options vao 
        JOIN product_variants pv ON vao.variant_id = pv.id 
        WHERE pv.product_id = ?
      `,
      values: [productId]
    })

    if (optionIds.length === 0) return null
    return optionIds
  }

  /**
   * Actualizar stock de una variante (con validaci√≥n de stock m√≠nimo)
   */
  public async updateStock(
    id: number,
    quantityChange: number
  ): Promise<ProductVariantRaw | null> {
    try {
      // Primero verificar el stock actual
      const currentVariant = await this.getProductVariantById(id)
      if (!currentVariant) {
        throw new Error('Variante no encontrada')
      }

      const newStock = currentVariant.stock + quantityChange
      if (newStock < 0) {
        throw new Error(
          `Stock insuficiente. Stock actual: ${currentVariant.stock}, cantidad solicitada: ${Math.abs(quantityChange)}`
        )
      }

      // Actualizar el stock
      await executeQuery({
        query:
          'UPDATE product_variants SET stock = ?, updated_at = NOW() WHERE id = ?',
        values: [newStock, id]
      })

      return await this.getProductVariantById(id)
    } catch (error) {
      console.error('Error updating stock:', error)
      throw error
    }
  }

  /**
   * Establecer stock exacto
   */
  public async setStock(
    id: number,
    newStock: number
  ): Promise<ProductVariantRaw | null> {
    if (newStock < 0) {
      throw new Error('El stock no puede ser negativo')
    }

    await executeQuery({
      query:
        'UPDATE product_variants SET stock = ?, updated_at = NOW() WHERE id = ?',
      values: [newStock, id]
    })

    return await this.getProductVariantById(id)
  }

  /**
   * Obtener variantes con stock bajo
   */
  public async getVariantsWithLowStock(
    threshold: number = 10
  ): Promise<ProductVariantRaw[] | null> {
    const variants = await executeQuery<ProductVariantRaw[]>({
      query:
        'SELECT * FROM product_variants WHERE stock <= ? ORDER BY stock ASC',
      values: [threshold]
    })

    if (variants.length === 0) return null
    return variants
  }

  /**
   * Obtener variantes sin stock
   */
  public async getOutOfStockVariants(): Promise<ProductVariantRaw[] | null> {
    const variants = await executeQuery<ProductVariantRaw[]>({
      query:
        'SELECT * FROM product_variants WHERE stock = 0 ORDER BY updated_at DESC'
    })

    if (variants.length === 0) return null
    return variants
  }

  /**
   * Actualizar m√∫ltiples stocks en una transacci√≥n
   */
  public async updateMultipleStocks(
    updates: Array<{ id: number, quantityChange: number }>
  ): Promise<boolean> {
    try {
      // Verificar que todos los productos tienen stock suficiente antes de actualizar
      for (const update of updates) {
        const variant = await this.getProductVariantById(update.id)
        if (!variant) {
          throw new Error(`Variante ${update.id} no encontrada`)
        }

        if (variant.stock + update.quantityChange < 0) {
          throw new Error(
            `Stock insuficiente para variante ${update.id}. Stock actual: ${variant.stock}, cantidad solicitada: ${Math.abs(update.quantityChange)}`
          )
        }
      }

      // Si todas las validaciones pasan, actualizar todos los stocks
      for (const update of updates) {
        await executeQuery({
          query:
            'UPDATE product_variants SET stock = stock + ?, updated_at = NOW() WHERE id = ?',
          values: [update.quantityChange, update.id]
        })
      }

      return true
    } catch (error) {
      console.error('Error updating multiple stocks:', error)
      throw error
    }
  }

  /**
   * Reservar stock (marcar como pendiente)
   * Nota: Esto requerir√≠a una columna adicional 'reserved_stock' en la tabla
   */
  public async reserveStock(
    id: number,
    quantity: number
  ): Promise<ProductVariantRaw | null> {
    const variant = await this.getProductVariantById(id)
    if (!variant) {
      throw new Error('Variante no encontrada')
    }

    // Verificar stock disponible (asumiendo que tienes una columna reserved_stock)
    // const availableStock = variant.stock - (variant.reserved_stock || 0)
    const availableStock = variant.stock // Por ahora usar solo stock total

    if (availableStock < quantity) {
      throw new Error(
        `Stock insuficiente para reservar. Disponible: ${availableStock}, solicitado: ${quantity}`
      )
    }

    // Por ahora solo reducimos el stock directamente
    // En una implementaci√≥n m√°s compleja, tendr√≠as una columna reserved_stock
    return await this.updateStock(id, -quantity)
  }
}

const productVariantRepository = new ProductVariantRepository()
export default productVariantRepository



üìÅ ARCHIVO: src/backend/attribute-option/AttributeOption.interfaces.ts
------------------------------------------------------------------------------------
// generated
import { type AttributeOptions as AttributeOption } from '@/types/domain'

// me
export interface AttributeOptionWithImages extends AttributeOption {
  attributeOptionImages?: AttributeOption['attributeOptionImages']
}

export interface AttributeOptionWithVariantOptions extends AttributeOption {
  variantAttributeOptions?: AttributeOption['variantAttributeOptions']
}

export interface AttributeOptionComplete extends AttributeOption {
  attributeOptionImages?: AttributeOption['attributeOptionImages']
  variantAttributeOptions?: AttributeOption['variantAttributeOptions']
}



üìÅ ARCHIVO: src/backend/attribute-option/AttributeOption.model.ts
------------------------------------------------------------------------------------
// generated
import { type AttributeOptions as AttributeOptionRaw } from '@/types/database'
import { type AttributeOptions as AttributeOption } from '@/types/domain'

// others
import attributeOptionImageModel from '@/backend/attribute-option-image'
import variantAttributeOptionModel from '@/backend/variant-attribute-option'

// me
import {
  AttributeOptionMapper,
  AttributeOptionMapperWithImages,
  AttributeOptionsMapper
} from './AttributeOption.mapper'
import oAttributeOptionRep from './AttributeOption.repository'

import {
  type AttributeOptionComplete,
  type AttributeOptionWithImages,
  type AttributeOptionWithVariantOptions
} from './AttributeOption.interfaces'

export class AttributeOptionModel {
  // ‚úÖ Obtener opciones por attribute ID (SIN relaciones por defecto)
  public async getAttributeOptions(
    attributeId: number
  ): Promise<AttributeOption[] | undefined> {
    const optionsRaw =
      await oAttributeOptionRep.getAttributeOptions(attributeId)
    return AttributeOptionsMapper(optionsRaw)
  }

  // ‚úÖ Obtener opciones por attribute ID CON images (l√≥gica de negocio)
  public async getAttributeOptionsWithImages(
    attributeId: number
  ): Promise<AttributeOptionWithImages[] | undefined> {
    const optionsRaw =
      await oAttributeOptionRep.getAttributeOptions(attributeId)

    if (!optionsRaw) return undefined

    // Mapear opciones b√°sicas
    const options = AttributeOptionsMapper(optionsRaw)
    if (!options) return undefined

    // Obtener images para todas las opciones (batch loading optimizado)
    const optionIds = options.map((option) => option.id)
    const imagesByOptionId =
      await attributeOptionImageModel.getAttributeOptionImagesByOptionIds(
        optionIds
      )

    // Combinar opciones con sus images
    return options.map((option) => ({
      ...option,
      attributeOptionImages: imagesByOptionId.get(option.id) || []
    }))
  }

  // ‚úÖ Obtener opciones por attribute ID CON variant options (l√≥gica de negocio)
  public async getAttributeOptionsWithVariantOptions(
    attributeId: number
  ): Promise<AttributeOptionWithVariantOptions[] | undefined> {
    const optionsRaw =
      await oAttributeOptionRep.getAttributeOptions(attributeId)

    if (!optionsRaw) return undefined

    // Mapear opciones b√°sicas
    const options = AttributeOptionsMapper(optionsRaw)
    if (!options) return undefined

    // Obtener variant options para todas las opciones (batch loading optimizado)
    const optionIds = options.map((option) => option.id)
    const variantOptionsByOptionId =
      await variantAttributeOptionModel.getVariantAttributeOptionsByAttributeOptionIds(
        optionIds
      )

    // Combinar opciones con sus variant options
    return options.map((option) => ({
      ...option,
      variantAttributeOptions: variantOptionsByOptionId.get(option.id) || []
    }))
  }

  // ‚úÖ Obtener opciones COMPLETAS por attribute ID (con images Y variant options)
  public async getAttributeOptionsComplete(
    attributeId: number
  ): Promise<AttributeOptionComplete[] | undefined> {
    const optionsRaw =
      await oAttributeOptionRep.getAttributeOptions(attributeId)

    if (!optionsRaw) return undefined

    // Mapear opciones b√°sicas
    const options = AttributeOptionsMapper(optionsRaw)
    if (!options) return undefined

    // Obtener images y variant options para todas las opciones (batch loading optimizado)
    const optionIds = options.map((option) => option.id)
    const [imagesByOptionId, variantOptionsByOptionId] = await Promise.all([
      attributeOptionImageModel.getAttributeOptionImagesByOptionIds(optionIds),
      variantAttributeOptionModel.getVariantAttributeOptionsByAttributeOptionIds(
        optionIds
      )
    ])

    // Combinar opciones con todas sus relaciones
    return options.map((option) => ({
      ...option,
      attributeOptionImages: imagesByOptionId.get(option.id) || [],
      variantAttributeOptions: variantOptionsByOptionId.get(option.id) || []
    }))
  }

  // ‚úÖ Obtener option por ID (SIN images por defecto)
  public async getAttributeOptionById(
    id: number
  ): Promise<AttributeOption | undefined> {
    const optionRaw = await oAttributeOptionRep.getAttributeOptionById(id)

    if (!optionRaw) return undefined

    return AttributeOptionMapper(optionRaw)
  }

  // ‚úÖ Obtener option por ID CON images (l√≥gica de negocio)
  public async getAttributeOptionByIdWithImages(
    id: number
  ): Promise<AttributeOptionWithImages | undefined> {
    const optionRaw = await oAttributeOptionRep.getAttributeOptionById(id)

    if (!optionRaw) return undefined

    // Obtener images de la option
    const images = await attributeOptionImageModel.getAttributeOptionImages(id)

    return AttributeOptionMapperWithImages(optionRaw, images)
  }

  // ‚úÖ Crear option - delega al repository
  public async createAttributeOption(
    optionData: Omit<AttributeOptionRaw, 'id'>
  ): Promise<AttributeOption | undefined> {
    const created = await oAttributeOptionRep.createAttributeOption(optionData)

    if (!created) return undefined

    return AttributeOptionMapper(created)
  }

  // ‚úÖ Actualizar option - delega al repository
  public async updateAttributeOption(
    optionData: Partial<AttributeOptionRaw>,
    id: number
  ): Promise<AttributeOption | undefined> {
    const updated = await oAttributeOptionRep.updateAttributeOption(
      optionData,
      id
    )

    if (!updated) return undefined

    return AttributeOptionMapper(updated)
  }

  // ‚úÖ Eliminar option - delega al repository
  public async deleteAttributeOption(id: number): Promise<void> {
    await oAttributeOptionRep.deleteAttributeOption(id)
  }

  // ‚úÖ Eliminar todas las opciones de un atributo
  public async deleteAttributeOptionsByAttributeId(
    attributeId: number
  ): Promise<void> {
    await oAttributeOptionRep.deleteAttributeOptionsByAttributeId(
      attributeId
    )
  }
}

const attributeOptionModel = new AttributeOptionModel()
export default attributeOptionModel



üìÅ ARCHIVO: src/backend/attribute-option/index.ts
------------------------------------------------------------------------------------
export * from './AttributeOption.interfaces'
export { default } from './AttributeOption.model'
export * from './AttributeOption.repository'



üìÅ ARCHIVO: src/backend/attribute-option/AttributeOption.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type AttributeOptions as AttributeOptionRaw } from '@/types/database'

export class AttributeOptionRepository {
  // ‚úÖ Obtener opciones por attribute ID
  public async getAttributeOptions(
    attributeId: number
  ): Promise<AttributeOptionRaw[] | null> {
    const attributeOptions = await executeQuery<AttributeOptionRaw[]>({
      query: 'SELECT * FROM attribute_options WHERE attribute_id = ?',
      values: [attributeId]
    })

    if (attributeOptions.length === 0) return null
    return attributeOptions
  }

  // ‚úÖ Obtener option por ID
  public async getAttributeOptionById(
    id: number
  ): Promise<AttributeOptionRaw | null> {
    const options = await executeQuery<AttributeOptionRaw[]>({
      query: 'SELECT * FROM attribute_options WHERE id = ?',
      values: [id]
    })

    if (options.length === 0) return null
    return options[0]
  }

  // ‚úÖ Crear option
  public async createAttributeOption(
    option: Omit<AttributeOptionRaw, 'id'>
  ): Promise<AttributeOptionRaw | null> {
    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO attribute_options SET ?',
      values: [option]
    })

    return await this.getAttributeOptionById(result.insertId)
  }

  // ‚úÖ Actualizar option
  public async updateAttributeOption(
    optionData: Partial<AttributeOptionRaw>,
    id: number
  ): Promise<AttributeOptionRaw | null> {
    await executeQuery({
      query: 'UPDATE attribute_options SET ? WHERE id = ?',
      values: [optionData, id]
    })

    return await this.getAttributeOptionById(id)
  }

  // ‚úÖ Eliminar option por ID
  public async deleteAttributeOption(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM attribute_options WHERE id = ?',
      values: [id]
    })
  }

  // ‚úÖ Eliminar todas las opciones de un atributo
  public async deleteAttributeOptionsByAttributeId(
    attributeId: number
  ): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM attribute_options WHERE attribute_id = ?',
      values: [attributeId]
    })
  }
}

const attributeOptionRepository = new AttributeOptionRepository()
export default attributeOptionRepository



üìÅ ARCHIVO: src/backend/attribute-option/AttributeOption.mapper.ts
------------------------------------------------------------------------------------
// generated
import { type AttributeOptions as AttributeOptionRaw } from '@/types/database'
import {
  type AttributeOptions as AttributeOption,
  type AttributeOptionImages,
  type VariantAttributeOptions
} from '@/types/domain'

export const AttributeOptionMapper = (
  data: AttributeOptionRaw
): AttributeOption => {
  return {
    id: data.id,
    attributeId: data.attribute_id,
    value: data.value,
    additionalCost: data.additional_cost ?? undefined,
    attributeOptionImages: undefined,
    variantAttributeOptions: undefined
  }
}

export const AttributeOptionMapperWithImages = (
  data: AttributeOptionRaw,
  images?: AttributeOptionImages[]
): AttributeOption => {
  return {
    ...AttributeOptionMapper(data),
    attributeOptionImages: images
  }
}

export const AttributeOptionMapperWithVariantOptions = (
  data: AttributeOptionRaw,
  variantOptions?: VariantAttributeOptions[]
): AttributeOption => {
  return {
    ...AttributeOptionMapper(data),
    variantAttributeOptions: variantOptions
  }
}

export const AttributeOptionMapperComplete = (
  data: AttributeOptionRaw,
  images?: AttributeOptionImages[],
  variantOptions?: VariantAttributeOptions[]
): AttributeOption => {
  return {
    ...AttributeOptionMapper(data),
    attributeOptionImages: images,
    variantAttributeOptions: variantOptions
  }
}

export const AttributeOptionsMapper = (
  data: AttributeOptionRaw[] | null
): AttributeOption[] | undefined => {
  if (data === null) return undefined
  return data.map(AttributeOptionMapper)
}



üìÅ ARCHIVO: src/backend/coupon/Coupon.interfaces.ts
------------------------------------------------------------------------------------
// üìÑ backend/coupon/Coupon.interfaces.ts
import { type Coupons } from '@/types/domain'

// Cup√≥n con estad√≠sticas de uso
export interface CouponWithStats extends Coupons {
  totalUsages: number
  totalDiscountAmount: number
  uniqueCustomers: number
  lastUsed?: Date
}

// Validaci√≥n de cup√≥n
export interface CouponValidationResult {
  isValid: boolean
  coupon?: Coupons
  discountAmount: number
  error?: string
  reason?: string
}

// Filtros para buscar cupones
export interface CouponFilters {
  isActive?: boolean
  discountType?: 'percentage' | 'fixed_amount'
  applicableTo?: 'all' | 'categories' | 'products'
  startDate?: Date
  endDate?: Date
  minDiscountValue?: number
  maxDiscountValue?: number
  hasUsageLimit?: boolean
  isExpired?: boolean
}

// Datos para aplicar un cup√≥n
export interface ApplyCouponData {
  couponCode: string
  customerId: number
  orderId: number
  orderTotal: number
  applicableItems?: Array<{
    productId?: number
    categoryId?: number
    amount: number
  }>
}

// Resultado de aplicar cup√≥n
export interface ApplyCouponResult {
  success: boolean
  discountAmount: number
  finalAmount: number
  error?: string
  couponUsageId?: number
}

// Estad√≠sticas de cup√≥n
export interface CouponStats {
  totalCoupons: number
  activeCoupons: number
  expiredCoupons: number
  totalUsages: number
  totalDiscountGiven: number
  averageDiscountPerUsage: number
  topCoupons: Array<{
    coupon: Coupons
    usageCount: number
    discountGiven: number
  }>
}



üìÅ ARCHIVO: src/backend/coupon/Coupon.mapper.ts
------------------------------------------------------------------------------------
// üìÑ backend/coupon/Coupon.mapper.ts
import { type Coupons as CouponRaw } from '@/types/database'
import { type Coupons as CouponDomain } from '@/types/domain'

export function CouponMapper(couponRaw: CouponRaw): CouponDomain {
  return {
    id: couponRaw.id,
    name: couponRaw.name,
    description: couponRaw.description || null,
    code: couponRaw.code,
    discountType: couponRaw.discount_type,
    discountValue: couponRaw.discount_value,
    startDate: couponRaw.start_date,
    endDate: couponRaw.end_date,
    isActive: couponRaw.is_active || null,
    usageLimit: couponRaw.usage_limit || null,
    usageLimitPerCustomer: couponRaw.usage_limit_per_customer || null,
    usedCount: couponRaw.used_count || null,
    minPurchaseAmount: couponRaw.min_purchase_amount || null,
    maxDiscountAmount: couponRaw.max_discount_amount || null,
    applicableTo: couponRaw.applicable_to || null,
    applicableIds: couponRaw.applicable_ids || null,
    createdAt: couponRaw.created_at,
    updatedAt: couponRaw.updated_at,
    couponUsage: null // Se cargar√° por separado si es necesario
  }
}

export function CouponsMapper(
  couponsRaw: CouponRaw[] | null
): CouponDomain[] | undefined {
  if (!couponsRaw) return undefined
  return couponsRaw.map(CouponMapper)
}

export function CouponToRawMapper(
  coupon: Omit<CouponDomain, 'id' | 'createdAt' | 'updatedAt'>
): Omit<CouponRaw, 'id' | 'created_at' | 'updated_at'> {
  return {
    name: coupon.name,
    description: coupon.description || null,
    code: coupon.code,
    discount_type: coupon.discountType,
    discount_value: coupon.discountValue,
    start_date: coupon.startDate,
    end_date: coupon.endDate,
    is_active: coupon.isActive || null,
    usage_limit: coupon.usageLimit || null,
    usage_limit_per_customer: coupon.usageLimitPerCustomer || null,
    used_count: coupon.usedCount || null,
    min_purchase_amount: coupon.minPurchaseAmount || null,
    max_discount_amount: coupon.maxDiscountAmount || null,
    applicable_to: coupon.applicableTo || null,
    applicable_ids: coupon.applicableIds
      ? JSON.stringify(coupon.applicableIds)
      : null
  }
}



üìÅ ARCHIVO: src/backend/coupon/Coupon.repository.ts
------------------------------------------------------------------------------------
// üìÑ backend/coupon/Coupon.repository.ts
import { executeQuery } from '@/lib/db'
import {
  type Coupons as CouponRaw,
  type CouponUsage as CouponUsageRaw
} from '@/types/database'

export class CouponRepository {
  // Obtener todos los cupones
  public async getCoupons(): Promise<CouponRaw[] | null> {
    const coupons = await executeQuery<CouponRaw[]>({
      query: 'SELECT * FROM coupons ORDER BY created_at DESC'
    })

    if (coupons.length === 0) return null
    return coupons
  }

  // Obtener cupones activos
  public async getActiveCoupons(): Promise<CouponRaw[] | null> {
    const coupons = await executeQuery<CouponRaw[]>({
      query: `
        SELECT * FROM coupons 
        WHERE is_active = 1 
        AND start_date <= NOW() 
        AND end_date >= NOW()
        ORDER BY created_at DESC
      `
    })

    if (coupons.length === 0) return null
    return coupons
  }

  // Obtener cup√≥n por ID
  public async getCouponById(id: number): Promise<CouponRaw | null> {
    const coupons = await executeQuery<CouponRaw[]>({
      query: 'SELECT * FROM coupons WHERE id = ?',
      values: [id]
    })

    if (coupons.length === 0) return null
    return coupons[0]
  }

  // Obtener cup√≥n por c√≥digo
  public async getCouponByCode(code: string): Promise<CouponRaw | null> {
    const coupons = await executeQuery<CouponRaw[]>({
      query: 'SELECT * FROM coupons WHERE code = ?',
      values: [code]
    })

    if (coupons.length === 0) return null
    return coupons[0]
  }

  // Obtener cupones con estad√≠sticas
  public async getCouponsWithStats(): Promise<any[] | null> {
    const results = await executeQuery<any[]>({
      query: `
        SELECT 
          c.*,
          COUNT(cu.id) as total_usages,
          COALESCE(SUM(cu.discount_amount), 0) as total_discount_amount,
          COUNT(DISTINCT cu.customer_id) as unique_customers,
          MAX(cu.used_at) as last_used
        FROM coupons c
        LEFT JOIN coupon_usage cu ON c.id = cu.coupon_id
        GROUP BY c.id
        ORDER BY c.created_at DESC
      `
    })

    if (results.length === 0) return null
    return results
  }

  // Crear cup√≥n
  public async createCoupon(
    couponData: Omit<CouponRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<CouponRaw | null> {
    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO coupons SET ?',
      values: [couponData]
    })

    return await this.getCouponById(result.insertId)
  }

  // Actualizar cup√≥n
  public async updateCoupon(
    couponData: Partial<Omit<CouponRaw, 'id' | 'created_at'>>,
    id: number
  ): Promise<CouponRaw | null> {
    await executeQuery({
      query: 'UPDATE coupons SET ?, updated_at = NOW() WHERE id = ?',
      values: [couponData, id]
    })

    return await this.getCouponById(id)
  }

  // Eliminar cup√≥n
  public async deleteCoupon(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM coupons WHERE id = ?',
      values: [id]
    })
  }

  // Activar cup√≥n
  public async activateCoupon(id: number): Promise<void> {
    await executeQuery({
      query:
        'UPDATE coupons SET is_active = 1, updated_at = NOW() WHERE id = ?',
      values: [id]
    })
  }

  // Desactivar cup√≥n
  public async deactivateCoupon(id: number): Promise<void> {
    await executeQuery({
      query:
        'UPDATE coupons SET is_active = 0, updated_at = NOW() WHERE id = ?',
      values: [id]
    })
  }

  // Incrementar contador de uso
  public async incrementUsageCount(id: number): Promise<void> {
    await executeQuery({
      query:
        'UPDATE coupons SET used_count = COALESCE(used_count, 0) + 1, updated_at = NOW() WHERE id = ?',
      values: [id]
    })
  }

  // Obtener uso de cup√≥n por customer
  public async getCouponUsageByCustomer(
    couponId: number,
    customerId: number
  ): Promise<number> {
    const results = await executeQuery<Array<{ usage_count: number }>>({
      query: `
        SELECT COUNT(*) as usage_count 
        FROM coupon_usage 
        WHERE coupon_id = ? AND customer_id = ?
      `,
      values: [couponId, customerId]
    })

    return results[0]?.usage_count || 0
  }

  // Registrar uso de cup√≥n
  public async createCouponUsage(
    usageData: Omit<CouponUsageRaw, 'id'>
  ): Promise<CouponUsageRaw | null> {
    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO coupon_usage SET ?',
      values: [usageData]
    })

    const created = await executeQuery<CouponUsageRaw[]>({
      query: 'SELECT * FROM coupon_usage WHERE id = ?',
      values: [result.insertId]
    })

    return created.length > 0 ? created[0] : null
  }

  // Obtener estad√≠sticas generales
  public async getCouponStats(): Promise<any | null> {
    const results = await executeQuery<any[]>({
      query: `
        SELECT 
          COUNT(*) as total_coupons,
          COUNT(CASE WHEN is_active = 1 THEN 1 END) as active_coupons,
          COUNT(CASE WHEN end_date < NOW() THEN 1 END) as expired_coupons,
          (SELECT COUNT(*) FROM coupon_usage) as total_usages,
          (SELECT COALESCE(SUM(discount_amount), 0) FROM coupon_usage) as total_discount_given
        FROM coupons
      `
    })

    return results.length > 0 ? results[0] : null
  }

  // Obtener cupones por filtros
  public async getCouponsByFilters(filters: {
    isActive?: boolean
    discountType?: string
    applicableTo?: string
    isExpired?: boolean
  }): Promise<CouponRaw[] | null> {
    let query = 'SELECT * FROM coupons WHERE 1=1'
    const values: any[] = []

    if (filters.isActive !== undefined) {
      query += ' AND is_active = ?'
      values.push(filters.isActive ? 1 : 0)
    }

    if (filters.discountType) {
      query += ' AND discount_type = ?'
      values.push(filters.discountType)
    }

    if (filters.applicableTo) {
      query += ' AND applicable_to = ?'
      values.push(filters.applicableTo)
    }

    if (filters.isExpired !== undefined) {
      if (filters.isExpired) {
        query += ' AND end_date < NOW()'
      } else {
        query += ' AND end_date >= NOW()'
      }
    }

    query += ' ORDER BY created_at DESC'

    const coupons = await executeQuery<CouponRaw[]>({
      query,
      values: values.length > 0 ? values : undefined
    })

    if (coupons.length === 0) return null
    return coupons
  }

  // Obtener usos de un cup√≥n espec√≠fico
  public async getCouponUsages(
    couponId: number
  ): Promise<CouponUsageRaw[] | null> {
    const usages = await executeQuery<CouponUsageRaw[]>({
      query: `
        SELECT cu.*, c.name as customer_name, c.email as customer_email
        FROM coupon_usage cu
        LEFT JOIN customers c ON cu.customer_id = c.id
        WHERE cu.coupon_id = ?
        ORDER BY cu.used_at DESC
      `,
      values: [couponId]
    })

    if (usages.length === 0) return null
    return usages
  }

  // Verificar si un c√≥digo ya existe
  public async codeExists(code: string, excludeId?: number): Promise<boolean> {
    let query = 'SELECT COUNT(*) as count FROM coupons WHERE code = ?'
    const values: any[] = [code]

    if (excludeId) {
      query += ' AND id != ?'
      values.push(excludeId)
    }

    const results = await executeQuery<Array<{ count: number }>>({
      query,
      values
    })

    return results[0].count > 0
  }
}

const oCouponRep = new CouponRepository()
export default oCouponRep



üìÅ ARCHIVO: src/backend/coupon/index.ts
------------------------------------------------------------------------------------
// üìÑ backend/coupon/index.ts
export * from './Coupon.interfaces'
export * from './Coupon.mapper'
export { default } from './Coupon.model'



üìÅ ARCHIVO: src/backend/coupon/Coupon.model.ts
------------------------------------------------------------------------------------
// üìÑ backend/coupon/Coupon.model.ts
import { type CouponUsage as CouponUsageRaw } from '@/types/database'
import { type Coupons as Coupon, type CouponUsage } from '@/types/domain'

import {
  type ApplyCouponData,
  type ApplyCouponResult,
  type CouponFilters,
  type CouponStats,
  type CouponValidationResult,
  type CouponWithStats
} from './Coupon.interfaces'
import { CouponMapper, CouponsMapper, CouponToRawMapper } from './Coupon.mapper'
import oCouponRep from './Coupon.repository'

export class CouponModel {
  public async getCoupons(): Promise<Coupon[] | undefined> {
    const couponsRaw = await oCouponRep.getCoupons()
    return CouponsMapper(couponsRaw)
  }

  public async getActiveCoupons(): Promise<Coupon[] | undefined> {
    const couponsRaw = await oCouponRep.getActiveCoupons()
    return CouponsMapper(couponsRaw)
  }

  public async getCouponById(id: number): Promise<Coupon | undefined> {
    const couponRaw = await oCouponRep.getCouponById(id)
    if (!couponRaw) return undefined
    return CouponMapper(couponRaw)
  }

  public async getCouponByCode(code: string): Promise<Coupon | undefined> {
    const couponRaw = await oCouponRep.getCouponByCode(code)
    if (!couponRaw) return undefined
    return CouponMapper(couponRaw)
  }

  public async getCouponsWithStats(): Promise<CouponWithStats[] | undefined> {
    const couponsRaw = await oCouponRep.getCouponsWithStats()
    if (!couponsRaw) return undefined

    return couponsRaw.map((coupon) => ({
      ...CouponMapper(coupon),
      totalUsages: coupon.total_usages || 0,
      totalDiscountAmount: coupon.total_discount_amount || 0,
      uniqueCustomers: coupon.unique_customers || 0,
      lastUsed: coupon.last_used || undefined
    }))
  }

  public async createCoupon(
    couponData: Omit<Coupon, 'id' | 'createdAt' | 'updatedAt' | 'couponUsage'>
  ): Promise<Coupon | undefined> {
    const couponRaw = CouponToRawMapper(couponData)
    const created = await oCouponRep.createCoupon(couponRaw)
    if (!created) return undefined
    return CouponMapper(created)
  }

  public async updateCoupon(
    couponData: Partial<
      Omit<Coupon, 'id' | 'createdAt' | 'updatedAt' | 'couponUsage'>
    >,
    id: number
  ): Promise<Coupon | undefined> {
    // Convertir solo los campos que se van a actualizar
    const updateRaw: any = {}

    if (couponData.name !== undefined) updateRaw.name = couponData.name
    if (couponData.description !== undefined) { updateRaw.description = couponData.description }
    if (couponData.code !== undefined) updateRaw.code = couponData.code
    if (couponData.discountType !== undefined) { updateRaw.discount_type = couponData.discountType }
    if (couponData.discountValue !== undefined) { updateRaw.discount_value = couponData.discountValue }
    if (couponData.startDate !== undefined) { updateRaw.start_date = couponData.startDate }
    if (couponData.endDate !== undefined) { updateRaw.end_date = couponData.endDate }
    if (couponData.isActive !== undefined) { updateRaw.is_active = couponData.isActive }
    if (couponData.usageLimit !== undefined) { updateRaw.usage_limit = couponData.usageLimit }
    if (couponData.usageLimitPerCustomer !== undefined) { updateRaw.usage_limit_per_customer = couponData.usageLimitPerCustomer }
    if (couponData.usedCount !== undefined) { updateRaw.used_count = couponData.usedCount }
    if (couponData.minPurchaseAmount !== undefined) { updateRaw.min_purchase_amount = couponData.minPurchaseAmount }
    if (couponData.maxDiscountAmount !== undefined) { updateRaw.max_discount_amount = couponData.maxDiscountAmount }
    if (couponData.applicableTo !== undefined) { updateRaw.applicable_to = couponData.applicableTo }
    if (couponData.applicableIds !== undefined) {
      updateRaw.applicable_ids = couponData.applicableIds
        ? JSON.stringify(couponData.applicableIds)
        : null
    }

    const updated = await oCouponRep.updateCoupon(updateRaw, id)
    if (!updated) return undefined
    return CouponMapper(updated)
  }

  public async deleteCoupon(id: number): Promise<void> {
    await oCouponRep.deleteCoupon(id)
  }

  public async activateCoupon(id: number): Promise<void> {
    await oCouponRep.activateCoupon(id)
  }

  public async deactivateCoupon(id: number): Promise<void> {
    await oCouponRep.deactivateCoupon(id)
  }

  // Validar cup√≥n para un cliente y monto espec√≠fico
  public async validateCoupon(
    code: string,
    customerId: number,
    orderTotal: number,
    applicableItems?: Array<{
      productId?: number
      categoryId?: number
      amount: number
    }>
  ): Promise<CouponValidationResult> {
    try {
      const coupon = await this.getCouponByCode(code)

      if (!coupon) {
        return {
          isValid: false,
          discountAmount: 0,
          error: 'Cup√≥n no v√°lido'
        }
      }

      // Verificar si est√° activo
      if (!coupon.isActive) {
        return {
          isValid: false,
          discountAmount: 0,
          error: 'Cup√≥n no activo'
        }
      }

      // Verificar fechas
      const now = new Date()
      if (now < new Date(coupon.startDate) || now > new Date(coupon.endDate)) {
        return {
          isValid: false,
          discountAmount: 0,
          error: 'Cup√≥n expirado'
        }
      }

      // Verificar monto m√≠nimo
      if (coupon.minPurchaseAmount && orderTotal < coupon.minPurchaseAmount) {
        return {
          isValid: false,
          discountAmount: 0,
          error: `Monto m√≠nimo requerido: S/ ${coupon.minPurchaseAmount}`
        }
      }

      // Verificar l√≠mite de uso general
      if (
        coupon.usageLimit &&
        coupon.usedCount &&
        coupon.usedCount >= coupon.usageLimit
      ) {
        return {
          isValid: false,
          discountAmount: 0,
          error: 'Cup√≥n agotado'
        }
      }

      // Verificar l√≠mite de uso por cliente
      if (coupon.usageLimitPerCustomer) {
        const customerUsage = await oCouponRep.getCouponUsageByCustomer(
          coupon.id,
          customerId
        )
        if (customerUsage >= coupon.usageLimitPerCustomer) {
          return {
            isValid: false,
            discountAmount: 0,
            error: 'L√≠mite de uso excedido para este cliente'
          }
        }
      }

      // Calcular descuento
      let discountAmount = 0
      let applicableAmount = orderTotal

      // Si el cup√≥n es espec√≠fico para productos/categor√≠as
      if (
        coupon.applicableTo &&
        coupon.applicableTo !== 'all' &&
        applicableItems
      ) {
        applicableAmount = this.calculateApplicableAmount(
          coupon,
          applicableItems
        )

        if (applicableAmount === 0) {
          return {
            isValid: false,
            discountAmount: 0,
            error: 'Cup√≥n no aplicable a los productos seleccionados'
          }
        }
      }

      if (coupon.discountType === 'percentage') {
        discountAmount = (applicableAmount * coupon.discountValue) / 100

        // Aplicar descuento m√°ximo si existe
        if (
          coupon.maxDiscountAmount &&
          discountAmount > coupon.maxDiscountAmount
        ) {
          discountAmount = coupon.maxDiscountAmount
        }
      } else {
        discountAmount = Math.min(coupon.discountValue, applicableAmount)
      }

      return {
        isValid: true,
        coupon,
        discountAmount,
        reason: `Descuento aplicado: S/ ${discountAmount.toFixed(2)}`
      }
    } catch (error) {
      console.error('Error validating coupon:', error)
      return {
        isValid: false,
        discountAmount: 0,
        error: 'Error validando cup√≥n'
      }
    }
  }

  // Aplicar cup√≥n a una orden
  public async applyCoupon(data: ApplyCouponData): Promise<ApplyCouponResult> {
    try {
      const validation = await this.validateCoupon(
        data.couponCode,
        data.customerId,
        data.orderTotal,
        data.applicableItems
      )

      if (!validation.isValid || !validation.coupon) {
        return {
          success: false,
          discountAmount: 0,
          finalAmount: data.orderTotal,
          error: validation.error
        }
      }

      // Registrar el uso del cup√≥n
      const usageData: Omit<CouponUsageRaw, 'id'> = {
        coupon_id: validation.coupon.id,
        customer_id: data.customerId,
        order_id: data.orderId,
        discount_amount: validation.discountAmount,
        used_at: new Date()
      }

      const couponUsage = await oCouponRep.createCouponUsage(usageData)

      if (!couponUsage) {
        return {
          success: false,
          discountAmount: 0,
          finalAmount: data.orderTotal,
          error: 'Error registrando uso del cup√≥n'
        }
      }

      // Incrementar contador de uso
      await oCouponRep.incrementUsageCount(validation.coupon.id)

      const finalAmount = data.orderTotal - validation.discountAmount

      return {
        success: true,
        discountAmount: validation.discountAmount,
        finalAmount,
        couponUsageId: couponUsage.id
      }
    } catch (error) {
      console.error('Error applying coupon:', error)
      return {
        success: false,
        discountAmount: 0,
        finalAmount: data.orderTotal,
        error: 'Error aplicando cup√≥n'
      }
    }
  }

  // Calcular monto aplicable seg√∫n restricciones del cup√≥n
  private calculateApplicableAmount(
    coupon: Coupon,
    items: Array<{ productId?: number, categoryId?: number, amount: number }>
  ): number {
    if (!coupon.applicableIds) return 0

    let applicableIds: number[] = []

    try {
      applicableIds =
        typeof coupon.applicableIds === 'string'
          ? JSON.parse(coupon.applicableIds)
          : coupon.applicableIds
    } catch {
      return 0
    }

    let totalApplicable = 0

    for (const item of items) {
      if (coupon.applicableTo === 'products' && item.productId) {
        if (applicableIds.includes(item.productId)) {
          totalApplicable += item.amount
        }
      } else if (coupon.applicableTo === 'categories' && item.categoryId) {
        if (applicableIds.includes(item.categoryId)) {
          totalApplicable += item.amount
        }
      }
    }

    return totalApplicable
  }

  // Obtener estad√≠sticas generales
  public async getCouponStats(): Promise<CouponStats | undefined> {
    const statsRaw = await oCouponRep.getCouponStats()
    if (!statsRaw) return undefined

    const averageDiscountPerUsage =
      statsRaw.total_usages > 0
        ? statsRaw.total_discount_given / statsRaw.total_usages
        : 0

    // Obtener top cupones
    const topCouponsRaw = await oCouponRep.getCouponsWithStats()
    const topCoupons =
      topCouponsRaw?.slice(0, 5).map((coupon) => ({
        coupon: CouponMapper(coupon),
        usageCount: coupon.total_usages || 0,
        discountGiven: coupon.total_discount_amount || 0
      })) || []

    return {
      totalCoupons: statsRaw.total_coupons || 0,
      activeCoupons: statsRaw.active_coupons || 0,
      expiredCoupons: statsRaw.expired_coupons || 0,
      totalUsages: statsRaw.total_usages || 0,
      totalDiscountGiven: statsRaw.total_discount_given || 0,
      averageDiscountPerUsage,
      topCoupons
    }
  }

  // Filtrar cupones
  public async getFilteredCoupons(
    filters: CouponFilters
  ): Promise<Coupon[] | undefined> {
    const couponsRaw = await oCouponRep.getCouponsByFilters({
      isActive: filters.isActive,
      discountType: filters.discountType,
      applicableTo: filters.applicableTo,
      isExpired: filters.isExpired
    })

    let coupons = CouponsMapper(couponsRaw)
    if (!coupons) return undefined

    // Aplicar filtros adicionales en memoria
    if (filters.startDate) {
      coupons = coupons.filter(
        (coupon) => new Date(coupon.startDate) >= filters.startDate!
      )
    }

    if (filters.endDate) {
      coupons = coupons.filter(
        (coupon) => new Date(coupon.endDate) <= filters.endDate!
      )
    }

    if (filters.minDiscountValue !== undefined) {
      coupons = coupons.filter(
        (coupon) => coupon.discountValue >= filters.minDiscountValue!
      )
    }

    if (filters.maxDiscountValue !== undefined) {
      coupons = coupons.filter(
        (coupon) => coupon.discountValue <= filters.maxDiscountValue!
      )
    }

    if (filters.hasUsageLimit !== undefined) {
      coupons = coupons.filter((coupon) =>
        filters.hasUsageLimit
          ? coupon.usageLimit !== null
          : coupon.usageLimit === null
      )
    }

    return coupons
  }

  // Verificar si un c√≥digo ya existe
  public async codeExists(code: string, excludeId?: number): Promise<boolean> {
    return await oCouponRep.codeExists(code, excludeId)
  }

  // Obtener usos de un cup√≥n
  public async getCouponUsages(
    couponId: number
  ): Promise<CouponUsage[] | undefined> {
    const usagesRaw = await oCouponRep.getCouponUsages(couponId)
    if (!usagesRaw) return undefined

    return usagesRaw.map((usage) => ({
      id: usage.id,
      couponId: usage.coupon_id,
      customerId: usage.customer_id,
      orderId: usage.order_id,
      discountAmount: usage.discount_amount,
      usedAt: usage.used_at,
      coupon: null, // Se puede cargar por separado si es necesario
      customer: null, // Se puede cargar por separado si es necesario
      order: null // Se puede cargar por separado si es necesario
    }))
  }

  // Generar c√≥digo √∫nico para cup√≥n
  public async generateUniqueCode(prefix: string = 'COUPON'): Promise<string> {
    let attempts = 0
    const maxAttempts = 10

    while (attempts < maxAttempts) {
      const randomSuffix = Math.random()
        .toString(36)
        .substring(2, 8)
        .toUpperCase()
      const code = `${prefix}-${randomSuffix}`

      const exists = await this.codeExists(code)
      if (!exists) {
        return code
      }

      attempts++
    }

    // Si no se pudo generar un c√≥digo √∫nico, usar timestamp
    const timestamp = Date.now().toString(36).toUpperCase()
    return `${prefix}-${timestamp}`
  }

  // Verificar si un cup√≥n est√° expirado
  public isCouponExpired(coupon: Coupon): boolean {
    return new Date() > new Date(coupon.endDate)
  }

  // Verificar si un cup√≥n est√° activo y v√°lido
  public isCouponValid(coupon: Coupon): boolean {
    const now = new Date()
    return (
      coupon.isActive === 1 &&
      now >= new Date(coupon.startDate) &&
      now <= new Date(coupon.endDate)
    )
  }

  // Calcular descuento sin aplicar
  public calculateDiscount(
    coupon: Coupon,
    amount: number
  ): { discountAmount: number, finalAmount: number } {
    let discountAmount = 0

    if (coupon.discountType === 'percentage') {
      discountAmount = (amount * coupon.discountValue) / 100

      if (
        coupon.maxDiscountAmount &&
        discountAmount > coupon.maxDiscountAmount
      ) {
        discountAmount = coupon.maxDiscountAmount
      }
    } else {
      discountAmount = Math.min(coupon.discountValue, amount)
    }

    return {
      discountAmount,
      finalAmount: amount - discountAmount
    }
  }
}

const couponModel = new CouponModel()
export default couponModel



üìÅ ARCHIVO: src/backend/product/Product.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type Products as ProductRaw } from '@/types/database'

export class ProductRepository {
  public async getProducts(): Promise<ProductRaw[] | null> {
    const products = await executeQuery<ProductRaw[]>({
      query: 'SELECT * FROM products ORDER BY id ASC'
    })

    if (products.length === 0) return null
    return products
  }

  public async getProductById(id: number): Promise<ProductRaw | null> {
    const products = await executeQuery<ProductRaw[]>({
      query: 'SELECT * FROM products WHERE id = ?',
      values: [id]
    })

    if (products.length === 0) return null
    return products[0]
  }

  public async getProductsByBrandId(
    brandId: number
  ): Promise<ProductRaw[] | null> {
    const products = await executeQuery<ProductRaw[]>({
      query: 'SELECT * FROM products WHERE brand_id = ? ORDER BY name ASC',
      values: [brandId]
    })

    if (products.length === 0) return null
    return products
  }

  public async getProductsByBrandIds(
    brandIds: number[]
  ): Promise<ProductRaw[] | null> {
    if (brandIds.length === 0) return null

    const placeholders = brandIds.map(() => '?').join(',')
    const products = await executeQuery<ProductRaw[]>({
      query: `SELECT * FROM products WHERE brand_id IN (${placeholders}) ORDER BY brand_id, name ASC`,
      values: brandIds
    })

    if (products.length === 0) return null
    return products
  }

  public async searchProductsByName(
    searchTerm: string
  ): Promise<ProductRaw[] | null> {
    const products = await executeQuery<ProductRaw[]>({
      query: 'SELECT * FROM products WHERE name LIKE ? ORDER BY name ASC',
      values: [`%${searchTerm}%`]
    })

    if (products.length === 0) return null
    return products
  }

  public async getProductsPaginated(
    limit: number,
    offset: number
  ): Promise<ProductRaw[] | null> {
    const products = await executeQuery<ProductRaw[]>({
      query: 'SELECT * FROM products ORDER BY id ASC LIMIT ? OFFSET ?',
      values: [limit, offset]
    })

    if (products.length === 0) return null
    return products
  }

  public async getProductsCount(): Promise<number> {
    const result = await executeQuery<Array<{ count: number }>>({
      query: 'SELECT COUNT(*) as count FROM products'
    })

    return result[0].count
  }

  public async createProduct(
    product: Omit<ProductRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<ProductRaw | null> {
    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO products SET ?',
      values: [product]
    })

    return await this.getProductById(result.insertId)
  }

  public async updateProduct(
    productData: Partial<Omit<ProductRaw, 'id' | 'created_at' | 'updated_at'>>,
    id: number
  ): Promise<ProductRaw | null> {
    await executeQuery({
      query: 'UPDATE products SET ? WHERE id = ?',
      values: [productData, id]
    })

    return await this.getProductById(id)
  }

  public async deleteProduct(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM products WHERE id = ?',
      values: [id]
    })
  }
}

const productRepository = new ProductRepository()
export default productRepository



üìÅ ARCHIVO: src/backend/product/Product.model.ts
------------------------------------------------------------------------------------
// generated
import { type Products as ProductRaw } from '@/types/database'
import { type Products as Product, type VariantAttributeOptions } from '@/types/domain'

// me
import { ProductMapper, ProductsMapper } from './Product.mapper'
import oProductRep from './Product.repository'

// others
import brandModel from '@/backend/brand'
import categoryModel from '@/backend/category'
import filtersModel from '@/backend/filters'
import productVariantModel from '@/backend/product-variant'
import promotionVariantModel from '@/backend/promotion-variant'
import searchModel, {
  type ProductSearchFilters,
  type ProductSearchResult
} from '@/backend/search'
import variantAttributeOptionModel from '@/backend/variant-attribute-option'
import variantImageModel from '@/backend/variant-image'
import variantRatingModel, {
  type VariantRatingWithCustomer
} from '@/backend/variant-rating'

export class ProductModel {
  public async getProducts(): Promise<Product[] | undefined> {
    const productsRaw = await oProductRep.getProducts()
    return ProductsMapper(productsRaw)
  }

  public async getProductFullById(id: number): Promise<Product | undefined> {
    const productRaw = await oProductRep.getProductById(id)
    if (!productRaw) return undefined
    const product = ProductMapper(productRaw)

    if (!product.brandId) return product
    const brand = await brandModel.getBrandById(product.brandId)
    if (!brand) return product
    product.brand = brand

    const categories = await categoryModel.getCategoriesByProductId(product.id)
    if (!categories) return product

    product.productCategories = categories.map((category) => ({
      categoryId: category.id,
      productId: product.id,
      categories
    }))

    const productVariants =
      await productVariantModel.getProductVariantsByProductId(product.id)

    if (!productVariants) return product

    product.productVariants = await Promise.all(
      productVariants.map(async (productVariant) => {
        const variantAttributeOptionWithDetails =
          await variantAttributeOptionModel.getVariantAttributeOptionsWithDetailsById(
            productVariant.id
          )

        const attributeOptions: VariantAttributeOptions[] =
          variantAttributeOptionWithDetails?.map((option) => ({
            variantId: option.variantId,
            attributeOptionId: option.attributeOptionId,
            attributeOption: option.attributeOption
          })) || []

        // Obtener im√°genes de la variante
        const images = await variantImageModel.getVariantImages(id)

        return {
          ...productVariant,
          variantAttributeOptions: attributeOptions,
          variantImages: images
        }
      })
    )

    return product
  }

  public async getProductById(id: number): Promise<Product | undefined> {
    const productRaw = await oProductRep.getProductById(id)
    if (!productRaw) return undefined
    const product = ProductMapper(productRaw)

    if (!product.brandId) return product
    const brand = await brandModel.getBrandById(product.brandId)
    if (!brand) return product
    product.brand = brand

    const categories = await categoryModel.getCategoriesByProductId(product.id)
    if (!categories) return product

    product.productCategories = categories.map((category) => ({
      categoryId: category.id,
      productId: product.id,
      categories
    }))

    const productVariants =
      await productVariantModel.getProductVariantsByProductId(product.id)

    if (!productVariants) return product

    product.productVariants = productVariants.map((productVariant) => ({
      ...productVariant,
      price: productVariant.price,
      id: productVariant.id
    }))

    product.productVariants = await Promise.all(
      productVariants.map(async (productVariant) => {
        const variantAttributeOptions =
          await productVariantModel.getVariantAttributeOptions(
            productVariant.id
          )

        const promotionsVariant =
          await promotionVariantModel.getPromotionsForVariant(productVariant.id)

        const variantImages = await variantImageModel.getVariantImages(
          productVariant.id
        )

        const variantRatingSearch =
          await variantRatingModel.getRatingsByVariantId(productVariant.id)

        const variantRatings: VariantRatingWithCustomer[] =
          variantRatingSearch.ratings.map((rating) => ({
            ...rating
          }))

        return {
          ...productVariant,
          variantAttributeOptions,
          promotionVariants: promotionsVariant,
          variantImages,
          variantRatings
        }
      })
    )

    return product
  }

  public async getProductsByBrandId(
    brandId: number
  ): Promise<Product[] | undefined> {
    const productsRaw = await oProductRep.getProductsByBrandId(brandId)
    return ProductsMapper(productsRaw)
  }

  public async searchProductsByName(
    searchTerm: string
  ): Promise<Product[] | undefined> {
    const productsRaw = await oProductRep.searchProductsByName(searchTerm)
    return ProductsMapper(productsRaw)
  }

  public async getProductsPaginated(
    limit: number,
    offset: number
  ): Promise<Product[] | undefined> {
    const productsRaw = await oProductRep.getProductsPaginated(limit, offset)
    return ProductsMapper(productsRaw)
  }

  public async getProductsCount(): Promise<number> {
    return await oProductRep.getProductsCount()
  }

  public async createProduct(
    productData: Omit<ProductRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<Product | undefined> {
    const created = await oProductRep.createProduct(productData)
    if (!created) return undefined
    return ProductMapper(created)
  }

  public async updateProduct(
    productData: Partial<Omit<ProductRaw, 'id' | 'created_at' | 'updated_at'>>,
    id: number
  ): Promise<Product | undefined> {
    const updated = await oProductRep.updateProduct(productData, id)
    if (!updated) return undefined
    return ProductMapper(updated)
  }

  public async deleteProduct(id: number): Promise<void> {
    await oProductRep.deleteProduct(id)
  }

  // ============================================================================
  // M√âTODOS CON COMPOSICI√ìN (nueva estructura)
  // ============================================================================

  // public async getProductsWithVariants(): Promise<
  //   ProductWithVariants[] | undefined
  // > {
  //   const productsRaw = await oProductRep.getProducts()
  //   const products = ProductsMapper(productsRaw)

  //   if (!products) return undefined

  //   const productIds = products.map((product) => product.id)
  //   const variantsByProductId =
  //     await productVariantModel.getProductVariantsByProductIds(productIds)

  //   return products.map((product) => ({
  //     ...product,
  //     productVariants: variantsByProductId.get(product.id) || []
  //   }))
  // }

  public async getProductsWithBrands(): Promise<Product[] | undefined> {
    const productsRaw = await oProductRep.getProducts()
    const products = ProductsMapper(productsRaw)

    if (!products) return undefined

    const brandIds = [...new Set(products.map((product) => product.brandId))]
    const brandsMap = new Map()

    for (const brandId of brandIds) {
      if (brandId) {
        const brand = await brandModel.getBrandById(brandId)
        if (brand) {
          brandsMap.set(brandId, brand)
        }
      }
    }

    return products.map((product) => ({
      ...product,
      brands: brandsMap.get(product.brandId)
        ? [brandsMap.get(product.brandId)]
        : []
    }))
  }

  // public async getProductsWithCategories(): Promise<
  //   ProductWithCategories[] | undefined
  // > {
  //   const productsRaw = await oProductRep.getProducts()
  //   const products = ProductsMapper(productsRaw)

  //   if (!products) return undefined

  //   const productsWithCategories = await Promise.all(
  //     products.map(async (product) => {
  //       const categories = await categoryModel.getCategoriesByProductId(
  //         product.id
  //       )
  //       return {
  //         ...product,
  //         categories: categories || []
  //       }
  //     })
  //   )

  //   return productsWithCategories
  // }

  // public async getProductsComplete(): Promise<ProductComplete2[] | undefined> {
  //   const productsRaw = await oProductRep.getProducts()
  //   const products = ProductsMapper(productsRaw)

  //   if (!products) return undefined

  //   const productIds = products.map((product) => product.id)
  //   const variantsByProductId =
  //     await productVariantModel.getProductVariantsByProductIds(productIds)

  //   const brandIds = [...new Set(products.map((product) => product.brandId))]
  //   const brandsMap = new Map()

  //   for (const brandId of brandIds) {
  //     if (brandId) {
  //       const brand = await brandModel.getBrandById(brandId)
  //       if (brand) {
  //         brandsMap.set(brandId, brand)
  //       }
  //     }
  //   }

  //   const productsComplete = await Promise.all(
  //     products.map(async (product) => {
  //       const categories = await categoryModel.getCategoriesByProductId(
  //         product.id
  //       )
  //       return {
  //         ...product,
  //         productVariants: variantsByProductId.get(product.id) || [],
  //         brands: brandsMap.get(product.brandId)
  //           ? [brandsMap.get(product.brandId)]
  //           : [],
  //         categories: categories || []
  //       }
  //     })
  //   )

  //   return productsComplete
  // }

  // public async getProductByIdWithVariants(
  //   id: number
  // ): Promise<ProductWithVariants | undefined> {
  //   const productRaw = await oProductRep.getProductById(id)
  //   if (!productRaw) return undefined

  //   const product = ProductMapper(productRaw)
  //   const variants = await productVariantModel.getProductVariantsByProductId(id)

  //   return {
  //     ...product,
  //     productVariants: variants || []
  //   }
  // }

  // public async getProductByIdWithBrand(
  //   id: number
  // ): Promise<ProductWithBrand | undefined> {
  //   const productRaw = await oProductRep.getProductById(id)
  //   if (!productRaw) return undefined

  //   const product = ProductMapper(productRaw)

  //   if (product.brandId) {
  //     const brand = await brandModel.getBrandById(product.brandId)
  //     return {
  //       ...product,
  //       brands: brand ? [brand] : []
  //     }
  //   }

  //   return {
  //     ...product,
  //     brands: []
  //   }
  // }

  // public async getProductByIdWithCategories(
  //   id: number
  // ): Promise<ProductWithCategories | undefined> {
  //   const productRaw = await oProductRep.getProductById(id)
  //   if (!productRaw) return undefined

  //   const product = ProductMapper(productRaw)
  //   const categories = await categoryModel.getCategoriesByProductId(id)

  //   return {
  //     ...product,
  //     categories: categories || []
  //   }
  // }

  // public async getProductByIdComplete(
  //   id: number
  // ): Promise<ProductComplete | undefined> {
  //   const productRaw = await oProductRep.getProductById(id)
  //   if (!productRaw) return undefined

  //   const product = ProductMapper(productRaw)
  //   const variants =
  //     await productVariantModel.getProductVariantsByProductIdWithAttributeOptions(
  //       id
  //     )

  //   const brand = product.brandId
  //     ? await brandModel.getBrandById(product.brandId)
  //     : undefined
  //   const categories = await categoryModel.getCategoriesByProductId(id)

  //   return {
  //     ...product,
  //     productVariants: variants || [],
  //     brands: brand ? [brand] : [],
  //     categories: categories || []
  //   }
  // }

  // ============================================================================
  // M√âTODOS DE B√öSQUEDA Y FILTROS (delegaci√≥n a modelos especializados)
  // ============================================================================

  public async searchProducts(
    filters: ProductSearchFilters
  ): Promise<ProductSearchResult> {
    const result = await searchModel.searchProducts(filters)

    // Obtener filtros disponibles y a√±adirlos al resultado
    const availableFilters = await filtersModel.getAvailableFilters()

    return {
      ...result,
      filters: availableFilters
    }
  }

  public async searchProductVariants(
    filters: ProductSearchFilters
  ): Promise<ProductSearchResult> {
    return await this.searchProducts(filters)
  }

  public async getAvailableFilters() {
    return await filtersModel.getAvailableFilters()
  }
}

const productModel = new ProductModel()
export default productModel



üìÅ ARCHIVO: src/backend/product/Product.mapper.ts
------------------------------------------------------------------------------------
import { type Products as ProductRaw } from '@/types/database'
import { type Products as Product } from '@/types/domain'

export const ProductMapper = (data: ProductRaw): Product => {
  return {
    id: data.id,
    name: data.name,
    description: data.description ?? undefined,
    basePrice: data.base_price ?? undefined,
    brandId: data.brand_id,
    createdAt: data.created_at,
    updatedAt: data.updated_at,
    brands: undefined,
    productVariants: undefined,
    productCategories: undefined
  }
}

export const ProductsMapper = (
  data: ProductRaw[] | null
): Product[] | undefined => {
  if (data === null) return undefined
  return data.map(ProductMapper)
}



üìÅ ARCHIVO: src/backend/product/index.ts
------------------------------------------------------------------------------------
export * from './Product.interfaces'
export { default } from './Product.model'



üìÅ ARCHIVO: src/backend/product/Product.interfaces.ts
------------------------------------------------------------------------------------
import { type ProductVariantComplete } from '@/backend/product-variant'
export interface ProductComplete {
  variants: ProductVariantComplete[]
  variantId: number
  variantPrice: number
  name: string
}



üìÅ ARCHIVO: src/backend/search/Search.interfaces.ts
------------------------------------------------------------------------------------
import { type AvailableFilters } from '@/backend/filters'
import { type ProductVariantComplete } from '@/backend/product-variant'

export interface ProductSearchFilters {
  query?: string
  categoryId?: number
  brandId?: number
  minPrice?: number
  maxPrice?: number
  attributes?: Record<number, number[]>
  page?: number
  limit?: number
  sort?: 'price_asc' | 'price_desc' | 'name_asc' | 'name_desc' | 'newest'
}

export interface ProductSearchResult {
  products: ProductSearchItem[]
  totalCount: number
  page: number
  totalPages: number
  filters: AvailableFilters
}

export interface VariantSearchResult {
  variantId: number
  productId: number
  sku: string
  price: number
  stock: number
  productName: string
  productDescription: string
  brandId: number
  basePrice: number
}

export interface ProductSearchItem {
  id: number
  name: string
  description?: string
  brandId?: number
  brandName: string
  basePrice?: number
  minVariantPrice: number
  categories: CategorySummary[]
  variants: ProductVariantComplete[]
  mainImage?: string
  // Campos espec√≠ficos de variante para resultados de b√∫squeda
  variantId: number
  variantSku?: string
  variantPrice: number
  variantStock?: number
}

export interface CategorySummary {
  id: number
  name: string
}



üìÅ ARCHIVO: src/backend/search/Search.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type ProductSearchFilters } from './Search.interfaces'

export interface VariantSearchResultRaw {
  variant_id: number
  product_id: number
  sku: string
  price: number
  stock: number
  product_name: string
  product_description: string
  brand_id: number
  base_price: number
}

export class SearchRepository {
  public async searchProductVariants(
    filters: ProductSearchFilters
  ): Promise<{ results: VariantSearchResultRaw[], totalCount: number }> {
    try {
      let query = `
        SELECT 
          pv.id as variant_id, 
          pv.product_id, 
          pv.sku, 
          pv.price, 
          pv.stock,
          p.name as product_name, 
          p.description as product_description, 
          p.brand_id, 
          p.base_price
        FROM 
          product_variants pv
        JOIN 
          products p ON pv.product_id = p.id
      `

      const whereConditions: string[] = []
      const queryParams: Array<string | number> = []
      const additionalJoins: string[] = []

      // === B√öSQUEDA POR TEXTO MEJORADA ===
      if (filters.query && filters.query.trim().length > 0) {
        const searchTerms = filters.query
          .trim()
          .toLowerCase()
          .split(/\s+/)
          .filter((term) => term.length >= 2)

        if (searchTerms.length > 0) {
          // Agregar JOIN con brands para poder buscar en marcas
          if (!additionalJoins.some((join) => join.includes('brands'))) {
            additionalJoins.push('LEFT JOIN brands b ON p.brand_id = b.id')
          }

          // ESTRATEGIA SIMPLIFICADA: Solo usar el t√©rmino m√°s significativo para b√∫squedas complejas
          // Esto evita problemas con t√©rminos cortos como "xx" que pueden existir pero ser irrelevantes
          const significantTerms = searchTerms.filter(
            (term) => term.length >= 3
          )
          const finalSearchTerms =
            significantTerms.length > 0
              ? [significantTerms[0]]
              : [searchTerms[0]]

          if (finalSearchTerms.length === 1 || searchTerms.length === 1) {
            // B√∫squeda simple - un solo t√©rmino
            whereConditions.push(`
              (LOWER(p.name) LIKE LOWER(?) OR 
               LOWER(p.description) LIKE LOWER(?) OR 
               LOWER(pv.sku) LIKE LOWER(?) OR
               LOWER(b.name) LIKE LOWER(?) OR
               EXISTS (
                 SELECT 1 FROM variant_attribute_options vao_search
                 JOIN attribute_options ao_search ON vao_search.attribute_option_id = ao_search.id
                 WHERE vao_search.variant_id = pv.id 
                 AND LOWER(ao_search.value) LIKE LOWER(?)
               ))
            `)
            const searchTerm = `%${searchTerms[0]}%`
            queryParams.push(
              searchTerm,
              searchTerm,
              searchTerm,
              searchTerm,
              searchTerm
            )
          } else {
            // B√∫squeda multi-t√©rmino - MEJORADA
            // Crear condiciones para que TODOS los t√©rminos est√©n presentes
            const termConditions = searchTerms.map((term, index) => {
              const searchTerm = `%${term}%`
              queryParams.push(
                searchTerm,
                searchTerm,
                searchTerm,
                searchTerm,
                searchTerm
              )

              return `
                (LOWER(p.name) LIKE LOWER(?) OR 
                 LOWER(p.description) LIKE LOWER(?) OR 
                 LOWER(pv.sku) LIKE LOWER(?) OR
                 LOWER(b.name) LIKE LOWER(?) OR
                 EXISTS (
                   SELECT 1 FROM variant_attribute_options vao_${index}
                   JOIN attribute_options ao_${index} ON vao_${index}.attribute_option_id = ao_${index}.id
                   WHERE vao_${index}.variant_id = pv.id 
                   AND LOWER(ao_${index}.value) LIKE LOWER(?)
                 ))
              `
            })

            // Todos los t√©rminos deben coincidir (AND)
            whereConditions.push(`(${termConditions.join(' AND ')})`)
          }
        }
      }

      // === FILTRO POR CATEGOR√çA ===
      if (filters.categoryId && filters.categoryId > 0) {
        additionalJoins.push(
          'JOIN product_categories pc ON p.id = pc.product_id'
        )
        whereConditions.push('pc.category_id = ?')
        queryParams.push(filters.categoryId)
      }

      // === FILTRO POR MARCA ===
      if (filters.brandId && filters.brandId > 0) {
        whereConditions.push('p.brand_id = ?')
        queryParams.push(filters.brandId)
      }

      // === FILTROS POR PRECIO ===
      if (
        filters.minPrice !== undefined &&
        filters.minPrice !== null &&
        filters.minPrice >= 0
      ) {
        whereConditions.push('pv.price >= ?')
        queryParams.push(filters.minPrice)
      }

      if (
        filters.maxPrice !== undefined &&
        filters.maxPrice !== null &&
        filters.maxPrice > 0
      ) {
        whereConditions.push('pv.price <= ?')
        queryParams.push(filters.maxPrice)
      }

      // === FILTROS POR ATRIBUTOS ===
      if (filters.attributes && typeof filters.attributes === 'object') {
        const attributeEntries = Object.entries(filters.attributes).filter(
          ([, optionIds]) => Array.isArray(optionIds) && optionIds.length > 0
        )

        attributeEntries.forEach(([, optionIds], index) => {
          const vaoAlias = `vao_filter_${index}`
          additionalJoins.push(
            `JOIN variant_attribute_options ${vaoAlias} ON pv.id = ${vaoAlias}.variant_id`
          )
          const placeholders = optionIds.map(() => '?').join(', ')
          whereConditions.push(
            `${vaoAlias}.attribute_option_id IN (${placeholders})`
          )
          queryParams.push(...optionIds)
        })
      }

      // === CONSTRUIR CONSULTA FINAL ===
      // Agregar JOINs adicionales
      if (additionalJoins.length > 0) {
        query += ' ' + additionalJoins.join(' ')
      }

      // Agregar WHERE solo si hay condiciones
      if (whereConditions.length > 0) {
        query += ' WHERE ' + whereConditions.join(' AND ')
      }

      // GROUP BY para evitar duplicados
      query +=
        ' GROUP BY pv.id, pv.product_id, pv.sku, pv.price, pv.stock, p.name, p.description, p.brand_id, p.base_price'

      // === CONSULTA PARA CONTAR TOTAL ===
      const countQueryBase = query
        .split('GROUP BY')[0]
        .replace(
          /SELECT[\s\S]*?FROM/i,
          'SELECT COUNT(DISTINCT pv.id) as total FROM'
        )

      const countResult = await executeQuery<[{ total: number }]>({
        query: countQueryBase,
        values: [...queryParams] // Clonar array
      })
      const totalCount = countResult[0]?.total || 0

      // === ORDENAMIENTO ===
      if (filters.sort) {
        switch (filters.sort) {
          case 'price_asc':
            query += ' ORDER BY pv.price ASC'
            break
          case 'price_desc':
            query += ' ORDER BY pv.price DESC'
            break
          case 'name_asc':
            query += ' ORDER BY p.name ASC'
            break
          case 'name_desc':
            query += ' ORDER BY p.name DESC'
            break
          case 'newest':
            query += ' ORDER BY p.created_at DESC'
            break
          default:
            query += ' ORDER BY p.created_at DESC'
        }
      } else {
        query += ' ORDER BY p.created_at DESC'
      }

      // === PAGINACI√ìN ===
      const page = Math.max(1, filters.page || 1)
      const limit = Math.max(1, Math.min(100, filters.limit || 10))
      const offset = (page - 1) * limit

      query += ' LIMIT ? OFFSET ?'
      queryParams.push(limit, offset)

      // === EJECUTAR CONSULTA PRINCIPAL ===
      const results = await executeQuery<VariantSearchResultRaw[]>({
        query,
        values: queryParams
      })

      return { results, totalCount }
    } catch (error) {
      console.error('=== ERROR in searchProductVariants ===')
      console.error('Error:', error)
      console.error('Filters:', JSON.stringify(filters, null, 2))
      throw new Error(
        `Error en b√∫squeda de productos: ${error instanceof Error ? error.message : 'Error desconocido'}`
      )
    }
  }

  public async getSearchSuggestions(
    query: string,
    limit: number = 10
  ): Promise<string[]> {
    try {
      if (!query || query.trim().length < 2) {
        return []
      }

      // Solo tomar t√©rminos de 2+ caracteres, sin filtros complicados
      const searchTerms = query
        .trim()
        .toLowerCase()
        .split(/\s+/)
        .filter((term) => term.length >= 2)

      if (searchTerms.length === 0) {
        return []
      }

      // Siempre usar b√∫squeda simple con el primer t√©rmino v√°lido
      // Esto es m√°s estable y predecible
      return this.getSingleTermSuggestions(searchTerms[0], limit)
    } catch (error) {
      console.error('Error in getSearchSuggestions:', error)
      return []
    }
  }

  private async getSingleTermSuggestions(
    term: string,
    limit: number
  ): Promise<string[]> {
    try {
      const searchTerm = `%${term}%`

      const suggestions = await executeQuery<
        Array<{ suggestion: string, priority: number }>
      >({
        query: `
          SELECT DISTINCT suggestion, priority FROM (
            -- Productos que contienen el t√©rmino
            SELECT DISTINCT p.name as suggestion, 1 as priority
            FROM products p
            WHERE LOWER(p.name) LIKE LOWER(?)
            
            UNION
            
            -- SKUs que contienen el t√©rmino
            SELECT DISTINCT pv.sku as suggestion, 2 as priority
            FROM product_variants pv
            WHERE LOWER(pv.sku) LIKE LOWER(?)
            
            UNION
            
            -- Productos + atributos espec√≠ficos
            SELECT DISTINCT CONCAT(p.name, ' ', ao.value) as suggestion, 3 as priority
            FROM products p
            JOIN product_variants pv ON p.id = pv.product_id
            JOIN variant_attribute_options vao ON pv.id = vao.variant_id
            JOIN attribute_options ao ON vao.attribute_option_id = ao.id
            WHERE (LOWER(p.name) LIKE LOWER(?) OR LOWER(ao.value) LIKE LOWER(?))
            
            UNION
            
            -- Productos + marca
            SELECT DISTINCT CONCAT(p.name, ' ', b.name) as suggestion, 4 as priority
            FROM products p
            JOIN brands b ON p.brand_id = b.id
            WHERE (LOWER(p.name) LIKE LOWER(?) OR LOWER(b.name) LIKE LOWER(?))
            
            UNION
            
            -- Solo valores de atributos
            SELECT DISTINCT ao.value as suggestion, 5 as priority
            FROM attribute_options ao
            WHERE LOWER(ao.value) LIKE LOWER(?)
            
            UNION
            
            -- Solo nombres de marcas
            SELECT DISTINCT b.name as suggestion, 6 as priority
            FROM brands b
            WHERE LOWER(b.name) LIKE LOWER(?)
          ) AS suggestions_union
          ORDER BY priority ASC, suggestion ASC
          LIMIT ?
        `,
        values: [
          searchTerm,
          searchTerm,
          searchTerm,
          searchTerm,
          searchTerm,
          searchTerm,
          searchTerm,
          searchTerm,
          limit
        ]
      })

      return suggestions.map((item) => item.suggestion)
    } catch (error) {
      console.error('Error in getSingleTermSuggestions:', error)
      return []
    }
  }

  private async getMultiTermSuggestions(
    terms: string[],
    limit: number
  ): Promise<string[]> {
    try {
      // Para m√∫ltiples t√©rminos, enfoque m√°s directo y efectivo
      const suggestions = await executeQuery<
        Array<{ suggestion: string, priority: number }>
      >({
        query: `
          SELECT DISTINCT suggestion, priority FROM (
            -- Productos que contienen TODOS los t√©rminos en el nombre
            SELECT DISTINCT p.name as suggestion, 1 as priority
            FROM products p
            WHERE ${terms.map(() => 'LOWER(p.name) LIKE LOWER(?)').join(' AND ')}
            
            UNION
            
            -- Productos + atributos donde al menos coincidan los t√©rminos
            SELECT DISTINCT CONCAT(p.name, ' ', ao.value) as suggestion, 2 as priority
            FROM products p
            JOIN product_variants pv ON p.id = pv.product_id
            JOIN variant_attribute_options vao ON pv.id = vao.variant_id
            JOIN attribute_options ao ON vao.attribute_option_id = ao.id
            WHERE ${terms.map(() => '(LOWER(p.name) LIKE LOWER(?) OR LOWER(ao.value) LIKE LOWER(?))').join(' AND ')}
            
            UNION
            
            -- Productos + marca donde coincidan los t√©rminos
            SELECT DISTINCT CONCAT(p.name, ' ', b.name) as suggestion, 3 as priority
            FROM products p
            JOIN brands b ON p.brand_id = b.id
            WHERE ${terms.map(() => '(LOWER(p.name) LIKE LOWER(?) OR LOWER(b.name) LIKE LOWER(?))').join(' AND ')}
          ) AS suggestions_union
          ORDER BY priority ASC, suggestion ASC
          LIMIT ?
        `,
        values: [
          // Para productos simples
          ...terms.map((term) => `%${term}%`),
          // Para productos + atributos (2 par√°metros por t√©rmino)
          ...terms.flatMap((term) => [`%${term}%`, `%${term}%`]),
          // Para productos + marca (2 par√°metros por t√©rmino)
          ...terms.flatMap((term) => [`%${term}%`, `%${term}%`]),
          // L√≠mite
          limit
        ]
      })

      return suggestions.map((item) => item.suggestion)
    } catch (error) {
      console.error('Error in getMultiTermSuggestions:', error)
      // Fallback a b√∫squeda simple si falla
      return await this.getSingleTermSuggestions(terms.join(' '), limit)
    }
  }
}

const searchRepository = new SearchRepository()
export default searchRepository



üìÅ ARCHIVO: src/backend/search/index.ts
------------------------------------------------------------------------------------
export * from './Search.interfaces'
export * from './Search.mapper'
export { default } from './Search.model'
export * from './Search.repository'



üìÅ ARCHIVO: src/backend/search/Search.model.ts
------------------------------------------------------------------------------------
// me
import {
  ProductSearchItemMapper,
  VariantSearchResultsMapper
} from './Search.mapper'
import oSearchRep from './Search.repository'

// others
import oAttributeModel from '@/backend/attribute'
import oBrandModel from '@/backend/brand'
import oCategoryModel from '@/backend/category'
import { type AvailableFilters } from '@/backend/filters'
import oProductVariantModel from '@/backend/product-variant'
import {
  type ProductSearchFilters,
  type ProductSearchItem,
  type ProductSearchResult
} from './Search.interfaces'

export class SearchModel {
  public async searchProducts(
    filters: ProductSearchFilters
  ): Promise<ProductSearchResult> {
    // Obtener resultados de b√∫squeda de variantes
    const { results, totalCount } =
      await oSearchRep.searchProductVariants(filters)

    // Mapear los resultados
    const mappedResults = VariantSearchResultsMapper(results)

    // Procesar cada variante como un producto individual
    const productSearchItems = await Promise.all(
      mappedResults.map(async (variantResult) => {
        // Obtener detalles completos de la variante
        const variantDetail = await oProductVariantModel.getProductVariant(
          variantResult.variantId
        )

        if (!variantDetail) {
          return null
        }

        // Obtener la marca
        const brand = await oBrandModel.getBrandById(variantResult.brandId)

        // Obtener las categor√≠as
        const categories = await oCategoryModel.getCategoriesByProductId(
          variantResult.productId
        )

        // Encontrar la imagen principal de la variante
        let mainImage: string | undefined

        if (
          variantDetail.variantImages &&
          variantDetail.variantImages.length > 0
        ) {
          const primaryImage = variantDetail.variantImages.find(
            (img) => img?.isPrimary
          )
          mainImage = primaryImage
            ? primaryImage.imageUrlNormal
            : variantDetail.variantImages[0]?.imageUrlNormal
        }

        // Crear ProductSearchItem usando el mapper
        const mappedItem = ProductSearchItemMapper(
          variantResult,
          variantDetail,
          brand?.name || '',
          categories?.map((cat) => ({
            id: cat.id,
            name: cat.name
          })) || [],
          mainImage
        )

        return mappedItem
      })
    )

    // Filtrar posibles nulos
    const filteredProductSearchItems = productSearchItems
      .filter((item): item is NonNullable<typeof item> => item !== null)
      .map((item) => ({
        ...item,
        minVariantPrice: item.minVariantPrice || item.basePrice || 0
      }))

    // Calcular informaci√≥n de paginaci√≥n
    const page = filters.page || 1
    const limit = filters.limit || 10
    const totalPages = Math.ceil(totalCount / limit)

    // Generar filtros con contadores basados en los productos encontrados
    const generatedFilters = await this.generateFiltersFromProducts(
      filteredProductSearchItems
    )

    return {
      products: filteredProductSearchItems,
      totalCount,
      page,
      totalPages,
      filters: generatedFilters
    }
  }

  public async searchProductVariants(filters: ProductSearchFilters) {
    return await this.searchProducts(filters)
  }

  public async getSearchSuggestions(
    query: string,
    limit: number = 10
  ): Promise<string[]> {
    return await oSearchRep.getSearchSuggestions(query, limit)
  }

  // M√©todo privado para generar filtros con contadores
  private async generateFiltersFromProducts(
    products: ProductSearchItem[]
  ): Promise<AvailableFilters> {
    // Obtener todos los atributos para mapear nombres
    const allAttributes = await oAttributeModel.getAttributes()
    const attributeNameMap = new Map<number, string>()
    allAttributes?.forEach((attr) => {
      attributeNameMap.set(attr.id, attr.name)
    })

    // Contadores para categor√≠as
    const categoryCount = new Map<number, { name: string, count: number }>()

    // Contadores para marcas
    const brandCount = new Map<number, { name: string, count: number }>()

    // Rango de precios
    let minPrice = Infinity
    let maxPrice = 0

    // Contadores para atributos
    const attributeCount = new Map<
      number,
      { name: string, options: Map<number, { value: string, count: number }> }
    >()

    products.forEach((product) => {
      // Contar categor√≠as
      if (product.categories) {
        product.categories.forEach((category) => {
          const existing = categoryCount.get(category.id)
          if (existing) {
            existing.count++
          } else {
            categoryCount.set(category.id, { name: category.name, count: 1 })
          }
        })
      }

      // Contar marcas
      if (product.brandId && product.brandName) {
        const existing = brandCount.get(product.brandId)
        if (existing) {
          existing.count++
        } else {
          brandCount.set(product.brandId, { name: product.brandName, count: 1 })
        }
      }

      // Calcular rango de precios
      const price = product.minVariantPrice || product.basePrice || 0
      if (price > 0) {
        minPrice = Math.min(minPrice, price)
        maxPrice = Math.max(maxPrice, price)
      }

      // Contar atributos √∫nicos por valor (evitar duplicados)
      const processedAttributeValues = new Set<string>()

      if (product.variants) {
        product.variants.forEach((variant) => {
          if (variant.variantAttributeOptions) {
            variant.variantAttributeOptions.forEach((variantAttr) => {
              if (variantAttr.attributeOption) {
                const option = variantAttr.attributeOption
                const attributeId = option.attributeId
                const uniqueKey = `${product.id}-${attributeId}-${option.value}`

                // Solo procesar si no hemos visto esta combinaci√≥n producto-atributo-valor
                if (!processedAttributeValues.has(uniqueKey)) {
                  processedAttributeValues.add(uniqueKey)

                  if (!attributeCount.has(attributeId)) {
                    // Usar el nombre real del atributo
                    const attributeName =
                      attributeNameMap.get(attributeId) ||
                      `Atributo ${attributeId}`
                    attributeCount.set(attributeId, {
                      name: attributeName,
                      options: new Map()
                    })
                  }

                  const attribute = attributeCount.get(attributeId)!

                  // Buscar si ya existe una opci√≥n con el mismo valor
                  let existingOptionEntry = null
                  for (const [
                    optionId,
                    optionData
                  ] of attribute.options.entries()) {
                    if (optionData.value === option.value) {
                      existingOptionEntry = [optionId, optionData]
                      break
                    }
                  }

                  if (existingOptionEntry) {
                    // Incrementar contador de la opci√≥n existente
                    ;(
                      existingOptionEntry[1] as { value: string, count: number }
                    ).count++
                  } else {
                    // Crear nueva opci√≥n
                    attribute.options.set(option.id, {
                      value: option.value,
                      count: 1
                    })
                  }
                }
              }
            })
          }
        })
      }
    })

    return {
      categories: Array.from(categoryCount.entries()).map(([id, data]) => ({
        id,
        name: data.name,
        count: data.count
      })),
      brands: Array.from(brandCount.entries()).map(([id, data]) => ({
        id,
        name: data.name,
        count: data.count
      })),
      priceRange: {
        min: minPrice === Infinity ? 0 : minPrice,
        max: maxPrice
      },
      attributes: Array.from(attributeCount.entries()).map(([id, data]) => ({
        id,
        name: data.name,
        displayType: 'pills' as const,
        options: Array.from(data.options.entries()).map(
          ([optionId, optionData]) => ({
            id: optionId,
            value: optionData.value,
            count: optionData.count
          })
        )
      }))
    }
  }
}

const searchModel = new SearchModel()
export default searchModel



üìÅ ARCHIVO: src/backend/search/Search.mapper.ts
------------------------------------------------------------------------------------
// others
import { type ProductVariantComplete } from '@/backend/product-variant'
import { type VariantSearchResultRaw } from '@/backend/search/Search.repository'

// me
import { type ProductSearchItem, type VariantSearchResult } from './Search.interfaces'

export const VariantSearchResultMapper = (
  data: VariantSearchResultRaw
): VariantSearchResult => {
  return {
    variantId: data.variant_id,
    productId: data.product_id,
    sku: data.sku,
    price: data.price,
    stock: data.stock,
    productName: data.product_name,
    productDescription: data.product_description,
    brandId: data.brand_id,
    basePrice: data.base_price
  }
}

export const VariantSearchResultsMapper = (
  data: VariantSearchResultRaw[]
): VariantSearchResult[] => {
  return data.map(VariantSearchResultMapper)
}

export const ProductSearchItemMapper = (
  variantResult: VariantSearchResult,
  variant: ProductVariantComplete,
  brandName: string,
  categories: Array<{ id: number, name: string }>,
  mainImage?: string
): ProductSearchItem => {
  return {
    id: variantResult.productId,
    name: variantResult.productName,
    description: variantResult.productDescription,
    brandId: variantResult.brandId,
    brandName,
    basePrice: variantResult.basePrice,
    minVariantPrice: variantResult.price,
    categories,
    variants: [variant],
    mainImage,
    variantId: variantResult.variantId,
    variantSku: variantResult.sku,
    variantPrice: variantResult.price,
    variantStock: variantResult.stock
  }
}



üìÅ ARCHIVO: src/backend/promotion-variant/PromotionVariant.model.ts
------------------------------------------------------------------------------------
import { type PromotionVariants as PromotionVariantRaw } from '@/types/database'
import { type PromotionVariants as PromotionVariant } from '@/types/domain'

// me
import promotionModel from '@/backend/promotion/Promotion.model'
import {
  type PromotionMetrics,
  type PromotionSummaryForVariant
} from './PromotionVariant.interfaces'
import {
  PromotionVariantMapper,
  PromotionVariantsMapper
} from './PromotionVariant.mapper'
import oPromotionVariantRep from './PromotionVariant.repository'

export class PromotionVariantModel {
  // ============================================================================
  // M√âTODOS B√ÅSICOS
  // ============================================================================

  public async getPromotionVariants(): Promise<PromotionVariant[] | undefined> {
    const promotionVariantsRaw =
      await oPromotionVariantRep.getPromotionVariants()
    return PromotionVariantsMapper(promotionVariantsRaw)
  }

  public async getPromotionVariantsByVariantId(
    variantId: number
  ): Promise<PromotionVariant[] | undefined> {
    const promotionVariantsRaw =
      await oPromotionVariantRep.getPromotionVariantsByVariantId(variantId)
    return PromotionVariantsMapper(promotionVariantsRaw)
  }

  public async getPromotionVariantsByPromotionId(
    promotionId: number
  ): Promise<PromotionVariant[] | undefined> {
    const promotionVariantsRaw =
      await oPromotionVariantRep.getPromotionVariantsByPromotionId(promotionId)
    return PromotionVariantsMapper(promotionVariantsRaw)
  }

  public async getPromotionVariant(
    promotionId: number,
    variantId: number
  ): Promise<PromotionVariant | undefined> {
    const promotionVariantRaw = await oPromotionVariantRep.getPromotionVariant(
      promotionId,
      variantId
    )
    if (!promotionVariantRaw) return undefined
    return PromotionVariantMapper(promotionVariantRaw)
  }

  public async hasPromotionForVariant(
    promotionId: number,
    variantId: number
  ): Promise<boolean> {
    const promotion = await this.getPromotionVariant(promotionId, variantId)
    return promotion !== undefined
  }

  // ============================================================================
  // BATCH LOADING
  // ============================================================================

  public async getPromotionVariantsByVariantIds(
    variantIds: number[]
  ): Promise<Map<number, PromotionVariant[]>> {
    const promotionVariantsRaw =
      await oPromotionVariantRep.getPromotionVariantsByVariantIds(variantIds)

    if (!promotionVariantsRaw) return new Map()

    const promotionsByVariantId = new Map<number, PromotionVariant[]>()

    for (const promotionRaw of promotionVariantsRaw) {
      const promotion = PromotionVariantMapper(promotionRaw)
      const variantId = promotion.variantId

      if (!promotionsByVariantId.has(variantId)) {
        promotionsByVariantId.set(variantId, [])
      }

      promotionsByVariantId.get(variantId)!.push(promotion)
    }

    return promotionsByVariantId
  }

  public async getPromotionVariantsByPromotionIds(
    promotionIds: number[]
  ): Promise<Map<number, PromotionVariant[]>> {
    const promotionVariantsRaw =
      await oPromotionVariantRep.getPromotionVariantsByPromotionIds(
        promotionIds
      )

    if (!promotionVariantsRaw) return new Map()

    const variantsByPromotionId = new Map<number, PromotionVariant[]>()

    for (const promotionRaw of promotionVariantsRaw) {
      const promotion = PromotionVariantMapper(promotionRaw)
      const promotionId = promotion.promotionId

      if (!variantsByPromotionId.has(promotionId)) {
        variantsByPromotionId.set(promotionId, [])
      }

      variantsByPromotionId.get(promotionId)!.push(promotion)
    }

    return variantsByPromotionId
  }

  // ============================================================================
  // L√ìGICA DE NEGOCIO
  // ============================================================================

  public async getPromotionsForVariant(
    variantId: number
  ): Promise<PromotionVariant[] | undefined> {
    const promotionsVariant =
      await this.getPromotionVariantsByVariantId(variantId)

    const promotions = await Promise.all(
      (promotionsVariant ?? []).map(async (promotionVariant) => {
        return {
          ...promotionVariant,
          createdAt: promotionVariant.createdAt,
          stockLimit: promotionVariant.stockLimit,
          promotionId: promotionVariant.promotionId,
          promotion: await promotionModel.getPromotionById(
            promotionVariant?.promotionId
          )
        }
      })
    )

    if (!promotions || promotions.length === 0) return undefined

    const promotionsActive: PromotionVariant[] = promotions.filter(
      (promotion) => promotion.promotion?.isActive
    )

    const promotionsWithStock: PromotionVariant[] = promotionsActive.filter(
      (promotion) => promotion.stockLimit > 0
    )

    const promotionsAvailable: PromotionVariant[] = promotionsWithStock.filter(
      (promotionVariant) => {
        // if (promotionVariant.promotion) return false
        if (promotionVariant.promotion) {
          // const now > Date(promotion.promotion?.startDate)
          const now = new Date()
          const startDate = new Date(promotionVariant.promotion.startDate)
          const endDate = new Date(promotionVariant.promotion.endDate)

          if (now > startDate && now < endDate) {
            return promotionVariant
          }
        }
      }
    )

    return promotionsAvailable
  }

  public async getBestPromotionForVariant(
    variantId: number
  ): Promise<PromotionVariant | undefined> {
    const promotions = await this.getPromotionVariantsByVariantId(variantId)

    if (!promotions || promotions.length === 0) return undefined

    const promotionsActive: PromotionVariant[] = promotions.filter(
      (promotion) => promotion.promotion?.isActive
    )

    const promotionsWithStock: PromotionVariant[] = promotionsActive.filter(
      (promotion) => promotion.stockLimit > 0
    )

    const promotionsAvailable: PromotionVariant[] = promotionsWithStock.filter(
      (promotionVariant) => {
        // if (promotionVariant.promotion) return false
        if (promotionVariant.promotion) {
          // const now > Date(promotion.promotion?.startDate)
          const now = new Date()
          const startDate = new Date(promotionVariant.promotion.startDate)
          const endDate = new Date(promotionVariant.promotion.endDate)

          if (now > startDate && now < endDate) {
            return promotionVariant
          }
        }
      }
    )

    if (promotionsAvailable.length === 0) return undefined

    return promotionsAvailable

    // return promotionsAvailable.reduce((best, current) => {
    //   if (!best.promotionPrice && current.promotionPrice) return current
    //   if (best.promotionPrice && !current.promotionPrice) return best
    //   if (!best.promotionPrice && !current.promotionPrice) return best

    //   return current.promotionPrice! < best.promotionPrice! ? current : best
    // })
  }

  public async getPromotionsWithStock(
    variantId: number
  ): Promise<PromotionVariant[] | undefined> {
    const promotions = await this.getPromotionVariantsByVariantId(variantId)

    if (!promotions) return undefined

    return promotions.filter(
      (promotion) => !promotion.stockLimit || promotion.stockLimit > 0
    )
  }

  private validatePromotionVariantData(
    data: Omit<PromotionVariantRaw, 'created_at'>
  ): void {
    if (
      data.promotion_price !== null &&
      data.promotion_price !== undefined &&
      data.promotion_price <= 0
    ) {
      throw new Error('Promotion price must be positive')
    }

    if (
      data.stock_limit !== null &&
      data.stock_limit !== undefined &&
      data.stock_limit < 0
    ) {
      throw new Error('Stock limit must be non-negative')
    }

    if (!data.promotion_id || data.promotion_id <= 0) {
      throw new Error('Valid promotion ID is required')
    }

    if (!data.variant_id || data.variant_id <= 0) {
      throw new Error('Valid variant ID is required')
    }
  }

  public async createPromotionVariant(
    promotionVariantData: Omit<PromotionVariantRaw, 'created_at'>
  ): Promise<PromotionVariant | undefined> {
    this.validatePromotionVariantData(promotionVariantData)

    const exists = await this.hasPromotionForVariant(
      promotionVariantData.promotion_id,
      promotionVariantData.variant_id
    )

    if (exists) {
      throw new Error('Promotion variant already exists for this combination')
    }

    const created =
      await oPromotionVariantRep.createPromotionVariant(promotionVariantData)
    if (!created) return undefined
    return PromotionVariantMapper(created)
  }

  public async updatePromotionVariant(
    promotionVariantData: Partial<
      Omit<PromotionVariantRaw, 'promotion_id' | 'variant_id' | 'created_at'>
    >,
    promotionId: number,
    variantId: number
  ): Promise<PromotionVariant | undefined> {
    const exists = await this.hasPromotionForVariant(promotionId, variantId)

    if (!exists) {
      throw new Error('Promotion variant not found')
    }

    if (promotionVariantData.promotion_price !== undefined) {
      if (
        promotionVariantData.promotion_price !== null &&
        promotionVariantData.promotion_price <= 0
      ) {
        throw new Error('Promotion price must be positive')
      }
    }

    if (promotionVariantData.stock_limit !== undefined) {
      if (
        promotionVariantData.stock_limit !== null &&
        promotionVariantData.stock_limit < 0
      ) {
        throw new Error('Stock limit must be non-negative')
      }
    }

    const updated = await oPromotionVariantRep.updatePromotionVariant(
      promotionVariantData,
      promotionId,
      variantId
    )

    if (!updated) return undefined
    return PromotionVariantMapper(updated)
  }

  public async updatePromotionStock(
    promotionId: number,
    variantId: number,
    newStock: number
  ): Promise<PromotionVariant | undefined> {
    if (newStock < 0) {
      throw new Error('Stock cannot be negative')
    }

    return await this.updatePromotionVariant(
      { stock_limit: newStock },
      promotionId,
      variantId
    )
  }

  public async decrementPromotionStock(
    promotionId: number,
    variantId: number,
    quantity: number = 1
  ): Promise<PromotionVariant | undefined> {
    const promotion = await this.getPromotionVariant(promotionId, variantId)

    if (!promotion) {
      throw new Error('Promotion variant not found')
    }

    if (!promotion.stockLimit) {
      return promotion
    }

    const newStock = promotion.stockLimit - quantity

    if (newStock < 0) {
      throw new Error('Insufficient stock for promotion')
    }

    return await this.updatePromotionStock(promotionId, variantId, newStock)
  }

  public async deletePromotionVariant(
    promotionId: number,
    variantId: number
  ): Promise<void> {
    const exists = await this.hasPromotionForVariant(promotionId, variantId)

    if (!exists) {
      throw new Error('Promotion variant not found')
    }

    await oPromotionVariantRep.deletePromotionVariant(
      promotionId,
      variantId
    )
  }

  public async deletePromotionVariantsByVariantId(
    variantId: number
  ): Promise<void> {
    await oPromotionVariantRep.deletePromotionVariantsByVariantId(
      variantId
    )
  }

  public async deletePromotionVariantsByPromotionId(
    promotionId: number
  ): Promise<void> {
    await oPromotionVariantRep.deletePromotionVariantsByPromotionId(
      promotionId
    )
  }

  // ============================================================================
  // M√âTRICAS Y RES√öMENES
  // ============================================================================

  public async getPromotionSummaryForVariant(
    variantId: number
  ): Promise<PromotionSummaryForVariant> {
    const [allPromotions, bestPromotion, availablePromotions] =
      await Promise.all([
        this.getPromotionVariantsByVariantId(variantId),
        this.getBestPromotionForVariant(variantId),
        this.getPromotionsWithStock(variantId)
      ])

    const totalPromotions = allPromotions?.length || 0
    const averageDiscountPercentage = 0

    return {
      totalPromotions,
      bestPromotion,
      availablePromotions,
      averageDiscountPercentage
    }
  }

  public async getPromotionMetrics(
    promotionId: number
  ): Promise<PromotionMetrics | undefined> {
    const promotionVariants =
      await this.getPromotionVariantsByPromotionId(promotionId)

    if (!promotionVariants || promotionVariants.length === 0) return undefined

    const totalVariants = promotionVariants.length
    const variantsWithStock = promotionVariants.filter(
      (pv) => !pv.stockLimit || pv.stockLimit > 0
    ).length

    const totalStockLimit = promotionVariants.reduce(
      (sum, pv) => sum + (pv.stockLimit || 0),
      0
    )

    const promotionPrices = promotionVariants
      .filter((pv) => pv.promotionPrice)
      .map((pv) => pv.promotionPrice!)

    const averagePromotionPrice =
      promotionPrices.length > 0
        ? promotionPrices.reduce((sum, price) => sum + price, 0) /
          promotionPrices.length
        : 0

    return {
      totalVariants,
      variantsWithStock,
      totalStockLimit,
      averagePromotionPrice: Number(averagePromotionPrice.toFixed(2))
    }
  }
}

const promotionVariantModel = new PromotionVariantModel()
export default promotionVariantModel



üìÅ ARCHIVO: src/backend/promotion-variant/PromotionVariant.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type PromotionVariants as PromotionVariantRaw } from '@/types/database'

export class PromotionVariantRepository {
  public async getPromotionVariants(): Promise<PromotionVariantRaw[] | null> {
    const promotionVariants = await executeQuery<PromotionVariantRaw[]>({
      query:
        'SELECT * FROM promotion_variants ORDER BY promotion_id, variant_id ASC'
    })

    if (promotionVariants.length === 0) return null
    return promotionVariants
  }

  public async getPromotionVariantsByVariantId(
    variantId: number
  ): Promise<PromotionVariantRaw[] | null> {
    const promotionVariants = await executeQuery<PromotionVariantRaw[]>({
      query: 'SELECT * FROM promotion_variants WHERE variant_id = ?',
      values: [variantId]
    })

    if (promotionVariants.length === 0) return null
    return promotionVariants
  }

  public async getPromotionVariantsByPromotionId(
    promotionId: number
  ): Promise<PromotionVariantRaw[] | null> {
    const promotionVariants = await executeQuery<PromotionVariantRaw[]>({
      query:
        'SELECT * FROM promotion_variants WHERE promotion_id = ? ORDER BY variant_id ASC',
      values: [promotionId]
    })

    if (promotionVariants.length === 0) return null
    return promotionVariants
  }

  public async getPromotionVariant(
    promotionId: number,
    variantId: number
  ): Promise<PromotionVariantRaw | null> {
    const promotionVariants = await executeQuery<PromotionVariantRaw[]>({
      query:
        'SELECT * FROM promotion_variants WHERE promotion_id = ? AND variant_id = ?',
      values: [promotionId, variantId]
    })

    if (promotionVariants.length === 0) return null
    return promotionVariants[0]
  }

  public async getPromotionVariantsByVariantIds(
    variantIds: number[]
  ): Promise<PromotionVariantRaw[] | null> {
    if (variantIds.length === 0) return null

    const placeholders = variantIds.map(() => '?').join(',')
    const promotionVariants = await executeQuery<PromotionVariantRaw[]>({
      query: `SELECT * FROM promotion_variants WHERE variant_id IN (${placeholders}) ORDER BY variant_id, promotion_id ASC`,
      values: variantIds
    })

    if (promotionVariants.length === 0) return null
    return promotionVariants
  }

  public async getPromotionVariantsByPromotionIds(
    promotionIds: number[]
  ): Promise<PromotionVariantRaw[] | null> {
    if (promotionIds.length === 0) return null

    const placeholders = promotionIds.map(() => '?').join(',')
    const promotionVariants = await executeQuery<PromotionVariantRaw[]>({
      query: `SELECT * FROM promotion_variants WHERE promotion_id IN (${placeholders}) ORDER BY promotion_id, variant_id ASC`,
      values: promotionIds
    })

    if (promotionVariants.length === 0) return null
    return promotionVariants
  }

  public async createPromotionVariant(
    promotionVariant: Omit<PromotionVariantRaw, 'created_at'>
  ): Promise<PromotionVariantRaw | null> {
    await executeQuery({
      query: 'INSERT INTO promotion_variants SET ?',
      values: [promotionVariant]
    })

    return await this.getPromotionVariant(
      promotionVariant.promotion_id,
      promotionVariant.variant_id
    )
  }

  public async updatePromotionVariant(
    promotionVariantData: Partial<
      Omit<PromotionVariantRaw, 'promotion_id' | 'variant_id' | 'created_at'>
    >,
    promotionId: number,
    variantId: number
  ): Promise<PromotionVariantRaw | null> {
    await executeQuery({
      query:
        'UPDATE promotion_variants SET ? WHERE promotion_id = ? AND variant_id = ?',
      values: [promotionVariantData, promotionId, variantId]
    })

    return await this.getPromotionVariant(promotionId, variantId)
  }

  public async deletePromotionVariant(
    promotionId: number,
    variantId: number
  ): Promise<void> {
    await executeQuery({
      query:
        'DELETE FROM promotion_variants WHERE promotion_id = ? AND variant_id = ?',
      values: [promotionId, variantId]
    })
  }

  public async deletePromotionVariantsByVariantId(
    variantId: number
  ): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM promotion_variants WHERE variant_id = ?',
      values: [variantId]
    })
  }

  public async deletePromotionVariantsByPromotionId(
    promotionId: number
  ): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM promotion_variants WHERE promotion_id = ?',
      values: [promotionId]
    })
  }
}

const promotionVariantRepository = new PromotionVariantRepository()
export default promotionVariantRepository



üìÅ ARCHIVO: src/backend/promotion-variant/PromotionVariant.mapper.ts
------------------------------------------------------------------------------------
import { type PromotionVariants as PromotionVariantRaw } from '@/types/database'
import { type PromotionVariants as PromotionVariant } from '@/types/domain'

export const PromotionVariantMapper = (
  data: PromotionVariantRaw
): PromotionVariant => {
  return {
    promotionId: data.promotion_id,
    variantId: data.variant_id,
    promotionPrice: data.promotion_price ?? undefined,
    stockLimit: data.stock_limit ?? undefined,
    createdAt: data.created_at,
    productVariants: undefined, // Se llena en el modelo con l√≥gica de negocio,
    promotion: undefined // Se llena en el modelo con l√≥gica de negocio
  }
}

export const PromotionVariantsMapper = (
  data: PromotionVariantRaw[] | null
): PromotionVariant[] | undefined => {
  if (data === null) return undefined
  return data.map(PromotionVariantMapper)
}



üìÅ ARCHIVO: src/backend/promotion-variant/index.ts
------------------------------------------------------------------------------------
export * from './PromotionVariant.interfaces'
export * from './PromotionVariant.mapper'
export { default } from './PromotionVariant.model'
export * from './PromotionVariant.repository'



üìÅ ARCHIVO: src/backend/promotion-variant/PromotionVariant.interfaces.ts
------------------------------------------------------------------------------------
import { type PromotionVariants as PromotionVariant } from '@/types/domain'

export interface PromotionSummaryForVariant {
  totalPromotions: number
  bestPromotion: PromotionVariant | undefined
  availablePromotions: PromotionVariant[] | undefined
  averageDiscountPercentage: number
}

export interface PromotionMetrics {
  totalVariants: number
  variantsWithStock: number
  totalStockLimit: number
  averagePromotionPrice: number
}



üìÅ ARCHIVO: src/backend/variant-rating/VariantRating.interfaces.ts
------------------------------------------------------------------------------------
import { type VariantRatings as VariantRating } from '@/types/domain'

export interface VariantRatingSummary {
  variantId: number
  totalRatings: number
  averageRating: number
  fiveStar: number
  fourStar: number
  threeStar: number
  twoStar: number
  oneStar: number
  verifiedPurchases: number
}

export interface VariantRatingWithCustomer extends VariantRating {
  customerName: string
  customerPhoto?: string
}

export interface VariantRatingSearchResult {
  ratings: VariantRatingWithCustomer[]
  totalCount: number
  page: number
  totalPages: number
  summary: VariantRatingSummary
}



üìÅ ARCHIVO: src/backend/variant-rating/VariantRating.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type VariantRatings as VariantRatingRaw } from '@/types/database'

export class VariantRatingRepository {
  public async getVariantRatings(): Promise<VariantRatingRaw[] | null> {
    const ratings = await executeQuery<VariantRatingRaw[]>({
      query: 'SELECT * FROM variant_ratings ORDER BY created_at DESC'
    })

    if (ratings.length === 0) return null
    return ratings
  }

  public async getVariantRatingById(
    id: number
  ): Promise<VariantRatingRaw | null> {
    const ratings = await executeQuery<VariantRatingRaw[]>({
      query: 'SELECT * FROM variant_ratings WHERE id = ?',
      values: [id]
    })

    if (ratings.length === 0) return null
    return ratings[0]
  }

  public async getVariantRatingsByVariantId(
    variantId: number
  ): Promise<VariantRatingRaw[] | null> {
    const ratings = await executeQuery<VariantRatingRaw[]>({
      query:
        'SELECT * FROM variant_ratings WHERE variant_id = ? ORDER BY created_at DESC',
      values: [variantId]
    })

    if (ratings.length === 0) return null
    return ratings
  }

  public async getVariantRatingsByCustomerId(
    customerId: number
  ): Promise<VariantRatingRaw[] | null> {
    const ratings = await executeQuery<VariantRatingRaw[]>({
      query:
        'SELECT * FROM variant_ratings WHERE customer_id = ? ORDER BY created_at DESC',
      values: [customerId]
    })

    if (ratings.length === 0) return null
    return ratings
  }

  public async getVerifiedVariantRatingsByVariantId(
    variantId: number
  ): Promise<VariantRatingRaw[] | null> {
    const ratings = await executeQuery<VariantRatingRaw[]>({
      query:
        'SELECT * FROM variant_ratings WHERE variant_id = ? AND verified_purchase = 1 ORDER BY created_at DESC',
      values: [variantId]
    })

    if (ratings.length === 0) return null
    return ratings
  }

  public async getVariantRatingsByVariantIds(
    variantIds: number[]
  ): Promise<VariantRatingRaw[] | null> {
    if (variantIds.length === 0) return null

    const placeholders = variantIds.map(() => '?').join(',')
    const ratings = await executeQuery<VariantRatingRaw[]>({
      query: `
        SELECT * FROM variant_ratings 
        WHERE variant_id IN (${placeholders}) 
        ORDER BY variant_id, created_at DESC
      `,
      values: variantIds
    })

    if (ratings.length === 0) return null
    return ratings
  }

  public async getVariantRatingByCustomerAndVariant(
    customerId: number,
    variantId: number
  ): Promise<VariantRatingRaw | null> {
    const ratings = await executeQuery<VariantRatingRaw[]>({
      query:
        'SELECT * FROM variant_ratings WHERE customer_id = ? AND variant_id = ?',
      values: [customerId, variantId]
    })

    if (ratings.length === 0) return null
    return ratings[0]
  }

  public async getVariantRatingStats(variantId: number): Promise<{
    averageRating: number
    totalRatings: number
    verifiedRatings: number
    ratingDistribution: Array<{ rating: number, count: number }>
  } | null> {
    const statsResult = await executeQuery<
      Array<{
        average_rating: number | null
        total_ratings: number
        verified_ratings: number
      }>
    >({
      query: `
        SELECT 
          AVG(rating) as average_rating,
          COUNT(*) as total_ratings,
          SUM(CASE WHEN verified_purchase = 1 THEN 1 ELSE 0 END) as verified_ratings
        FROM variant_ratings 
        WHERE variant_id = ?
      `,
      values: [variantId]
    })

    if (statsResult[0].total_ratings === 0) return null

    const distributionResult = await executeQuery<
      Array<{
        rating: number
        count: number
      }>
    >({
      query: `
        SELECT 
          rating,
          COUNT(*) as count
        FROM variant_ratings 
        WHERE variant_id = ?
        GROUP BY rating
        ORDER BY rating DESC
      `,
      values: [variantId]
    })

    return {
      averageRating: Number(statsResult[0].average_rating?.toFixed(2)) || 0,
      totalRatings: statsResult[0].total_ratings,
      verifiedRatings: statsResult[0].verified_ratings,
      ratingDistribution: distributionResult
    }
  }

  public async createVariantRating(
    rating: Omit<VariantRatingRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<VariantRatingRaw | null> {
    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO variant_ratings SET ?',
      values: [rating]
    })

    return await this.getVariantRatingById(result.insertId)
  }

  public async updateVariantRating(
    ratingData: Partial<
      Omit<
        VariantRatingRaw,
        'id' | 'customer_id' | 'variant_id' | 'created_at' | 'updated_at'
      >
    >,
    id: number
  ): Promise<VariantRatingRaw | null> {
    await executeQuery({
      query: 'UPDATE variant_ratings SET ?, updated_at = NOW() WHERE id = ?',
      values: [ratingData, id]
    })

    return await this.getVariantRatingById(id)
  }

  public async deleteVariantRating(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM variant_ratings WHERE id = ?',
      values: [id]
    })
  }

  public async deleteVariantRatingsByVariantId(
    variantId: number
  ): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM variant_ratings WHERE variant_id = ?',
      values: [variantId]
    })
  }

  public async deleteVariantRatingsByCustomerId(
    customerId: number
  ): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM variant_ratings WHERE customer_id = ?',
      values: [customerId]
    })
  }

  public async countVariantRatings(variantId: number): Promise<number> {
    const result = await executeQuery<Array<{ count: number }>>({
      query:
        'SELECT COUNT(*) as count FROM variant_ratings WHERE variant_id = ?',
      values: [variantId]
    })

    return result[0].count
  }

  public async checkDuplicateRating(
    customerId: number,
    variantId: number
  ): Promise<boolean> {
    const result = await executeQuery<Array<{ count: number }>>({
      query:
        'SELECT COUNT(*) as count FROM variant_ratings WHERE customer_id = ? AND variant_id = ?',
      values: [customerId, variantId]
    })

    return result[0].count > 0
  }
}

const variantRatingRepository = new VariantRatingRepository()
export default variantRatingRepository



üìÅ ARCHIVO: src/backend/variant-rating/VariantRating.mapper.ts
------------------------------------------------------------------------------------
import { type VariantRatings as VariantRatingRaw } from '@/types/database'
import { type VariantRatings as VariantRating } from '@/types/domain'

export const VariantRatingMapper = (data: VariantRatingRaw): VariantRating => {
  return {
    id: data.id,
    variantId: data.variant_id,
    customerId: data.customer_id,
    rating: data.rating,
    title: data.title ?? undefined,
    review: data.review ?? undefined,
    verifiedPurchase: data.verified_purchase,
    createdAt: data.created_at,
    updatedAt: data.updated_at,
    customer: undefined, // Se llena en el modelo con l√≥gica de negocio
    productVariants: undefined, // Se llena en el modelo con l√≥gica de negocio
    ratingImages: undefined // Se llena en el modelo con l√≥gica de negocio
  }
}

export const VariantRatingsMapper = (
  data: VariantRatingRaw[] | null
): VariantRating[] | undefined => {
  if (data === null) return undefined
  return data.map(VariantRatingMapper)
}



üìÅ ARCHIVO: src/backend/variant-rating/VariantRating.model.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type VariantRatings as VariantRatingRaw } from '@/types/database'
import { type VariantRatings as VariantRating } from '@/types/domain'

// me
import {
  type VariantRatingSearchResult,
  type VariantRatingSummary,
  type VariantRatingWithCustomer
} from './VariantRating.interfaces'
import {
  VariantRatingMapper,
  VariantRatingsMapper
} from './VariantRating.mapper'
import oVariantRatingRep from './VariantRating.repository'

export class VariantRatingModel {
  // ============================================================================
  // M√âTODOS B√ÅSICOS
  // ============================================================================

  public async getVariantRatings(): Promise<VariantRating[] | undefined> {
    const ratingsRaw = await oVariantRatingRep.getVariantRatings()
    return VariantRatingsMapper(ratingsRaw)
  }

  public async getVariantRatingById(
    id: number
  ): Promise<VariantRating | undefined> {
    const ratingRaw = await oVariantRatingRep.getVariantRatingById(id)
    if (!ratingRaw) return undefined
    return VariantRatingMapper(ratingRaw)
  }

  public async getVariantRatingsByVariantId(
    variantId: number
  ): Promise<VariantRating[] | undefined> {
    const ratingsRaw =
      await oVariantRatingRep.getVariantRatingsByVariantId(variantId)
    return VariantRatingsMapper(ratingsRaw)
  }

  public async getVariantRatingsByCustomerId(
    customerId: number
  ): Promise<VariantRating[] | undefined> {
    const ratingsRaw =
      await oVariantRatingRep.getVariantRatingsByCustomerId(customerId)
    return VariantRatingsMapper(ratingsRaw)
  }

  public async createVariantRating(
    ratingData: Omit<VariantRatingRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<VariantRating | undefined> {
    const created = await oVariantRatingRep.createVariantRating(ratingData)
    if (!created) return undefined
    return VariantRatingMapper(created)
  }

  public async updateVariantRating(
    ratingData: Partial<
      Omit<VariantRatingRaw, 'id' | 'created_at' | 'updated_at'>
    >,
    id: number
  ): Promise<VariantRating | undefined> {
    const updated = await oVariantRatingRep.updateVariantRating(ratingData, id)
    if (!updated) return undefined
    return VariantRatingMapper(updated)
  }

  public async deleteVariantRating(id: number): Promise<void> {
    await oVariantRatingRep.deleteVariantRating(id)
  }

  // ============================================================================
  // M√âTODOS COMPLEJOS CON JOINS
  // ============================================================================

  public async getRatingsByVariantId(
    variantId: number,
    page: number = 1,
    limit: number = 10
  ): Promise<VariantRatingSearchResult> {
    const offset = (page - 1) * limit

    const ratings = await executeQuery<
      Array<VariantRatingRaw & {
        customer_name: string
        customer_photo: string | null
      }>
    >({
      query: `
        SELECT 
          vr.*, 
          c.name as customer_name,
          c.photo as customer_photo
        FROM 
          variant_ratings vr
        JOIN
          customers c ON vr.customer_id = c.id
        WHERE 
          vr.variant_id = ?
        ORDER BY 
          vr.created_at DESC
        LIMIT ? OFFSET ?
      `,
      values: [variantId, limit, offset]
    })

    const countResult = await executeQuery<[{ total: number }]>({
      query:
        'SELECT COUNT(*) as total FROM variant_ratings WHERE variant_id = ?',
      values: [variantId]
    })
    const totalCount = countResult[0]?.total || 0
    const totalPages = Math.ceil(totalCount / limit)

    const summary = await this.getVariantRatingSummary(variantId)

    const ratingDTOs: VariantRatingWithCustomer[] = ratings.map((rating) => ({
      ...VariantRatingMapper(rating),
      customerName: rating.customer_name,
      customerPhoto: rating.customer_photo || undefined
    }))

    return {
      ratings: ratingDTOs,
      totalCount,
      page,
      totalPages,
      summary
    }
  }

  public async getVariantRatingSummary(
    variantId: number
  ): Promise<VariantRatingSummary> {
    const summary = await executeQuery<
      Array<{
        variant_id: number
        total_ratings: number
        average_rating: number
        five_star: number
        four_star: number
        three_star: number
        two_star: number
        one_star: number
        verified_purchases: number
      }>
    >({
      query: 'SELECT * FROM variant_rating_summary WHERE variant_id = ?',
      values: [variantId]
    })

    if (summary.length === 0) {
      return {
        variantId,
        totalRatings: 0,
        averageRating: 0,
        fiveStar: 0,
        fourStar: 0,
        threeStar: 0,
        twoStar: 0,
        oneStar: 0,
        verifiedPurchases: 0
      }
    }

    const data = summary[0]
    return {
      variantId,
      totalRatings: Number(data.total_ratings),
      averageRating: Number(data.average_rating),
      fiveStar: Number(data.five_star),
      fourStar: Number(data.four_star),
      threeStar: Number(data.three_star),
      twoStar: Number(data.two_star),
      oneStar: Number(data.one_star),
      verifiedPurchases: Number(data.verified_purchases)
    }
  }

  // ============================================================================
  // M√âTODOS DE L√ìGICA DE NEGOCIO
  // ============================================================================

  public async createRating(
    variantId: number,
    customerId: number,
    rating: number,
    review?: string,
    title?: string,
    verifiedPurchase: boolean = false
  ): Promise<VariantRating | undefined> {
    if (rating < 1 || rating > 5) {
      throw new Error('Rating must be between 1 and 5')
    }

    const ratingData: Omit<
      VariantRatingRaw,
      'id' | 'created_at' | 'updated_at'
    > = {
      variant_id: variantId,
      customer_id: customerId,
      rating,
      review: review || null,
      title: title || null,
      verified_purchase: verifiedPurchase ? 1 : 0
    }

    return await this.createVariantRating(ratingData)
  }

  public async hasCustomerRatedVariant(
    customerId: number,
    variantId: number
  ): Promise<boolean> {
    return await oVariantRatingRep.checkDuplicateRating(customerId, variantId)
  }

  public async getAverageRatingForVariant(variantId: number): Promise<number> {
    const stats = await oVariantRatingRep.getVariantRatingStats(variantId)
    return stats?.averageRating || 0
  }

  public async getTotalRatingsForVariant(variantId: number): Promise<number> {
    return await oVariantRatingRep.countVariantRatings(variantId)
  }

  public async getVerifiedPurchaseRatings(
    variantId: number
  ): Promise<VariantRating[] | undefined> {
    const ratingsRaw =
      await oVariantRatingRep.getVerifiedVariantRatingsByVariantId(variantId)
    return VariantRatingsMapper(ratingsRaw)
  }

  // ============================================================================
  // M√âTODOS PARA BATCH LOADING
  // ============================================================================

  public async getVariantRatingsByVariantIds(
    variantIds: number[]
  ): Promise<Map<number, VariantRating[]>> {
    const ratingsRaw =
      await oVariantRatingRep.getVariantRatingsByVariantIds(variantIds)

    if (!ratingsRaw) return new Map()

    const ratingsByVariantId = new Map<number, VariantRating[]>()

    for (const ratingRaw of ratingsRaw) {
      const rating = VariantRatingMapper(ratingRaw)
      const variantId = rating.variantId

      if (!ratingsByVariantId.has(variantId)) {
        ratingsByVariantId.set(variantId, [])
      }

      ratingsByVariantId.get(variantId)!.push(rating)
    }

    return ratingsByVariantId
  }

  public async getVariantRatingSummariesByVariantIds(
    variantIds: number[]
  ): Promise<Map<number, VariantRatingSummary>> {
    if (variantIds.length === 0) return new Map()

    const summariesMap = new Map<number, VariantRatingSummary>()

    for (const variantId of variantIds) {
      const summary = await this.getVariantRatingSummary(variantId)
      summariesMap.set(variantId, summary)
    }

    return summariesMap
  }

  // ============================================================================
  // ALIAS PARA COMPATIBILIDAD
  // ============================================================================

  public async getRatingById(id: number) {
    return await this.getVariantRatingById(id)
  }

  public async deleteRating(id: number) {
    await this.deleteVariantRating(id)
  }
}

const variantRatingModel = new VariantRatingModel()
export default variantRatingModel



üìÅ ARCHIVO: src/backend/variant-rating/index.ts
------------------------------------------------------------------------------------
export * from './VariantRating.interfaces'
export * from './VariantRating.mapper'
export { default } from './VariantRating.model'
export * from './VariantRating.repository'



üìÅ ARCHIVO: src/backend/order-tracking/OrderTracking.mapper.ts
------------------------------------------------------------------------------------
import { type OrderTracking as OrderTrackingRaw } from '@/types/database'
import { type OrderTracking } from '@/types/domain'

// Mapper de raw (database) a domain
export const OrderTrackingMapper = (
  orderTrackingRaw: OrderTrackingRaw
): OrderTracking => {
  return {
    id: orderTrackingRaw.id,
    orderId: orderTrackingRaw.order_id,
    trackingNumber: orderTrackingRaw.tracking_number || undefined,
    courierCompany: orderTrackingRaw.courier_company || undefined,
    status: orderTrackingRaw.status,
    currentLocation: orderTrackingRaw.current_location || undefined,
    shippedAt: orderTrackingRaw.shipped_at || undefined,
    deliveredAt: orderTrackingRaw.delivered_at || undefined,
    deliveredTo: orderTrackingRaw.delivered_to || undefined,
    deliveryNotes: orderTrackingRaw.delivery_notes || undefined,
    createdAt: orderTrackingRaw.created_at,
    updatedAt: orderTrackingRaw.updated_at
  }
}

// Mapper para arrays
export const OrderTrackingsMapper = (
  orderTrackingsRaw: OrderTrackingRaw[] | null
): OrderTracking[] | null => {
  if (!orderTrackingsRaw) return null
  return orderTrackingsRaw.map(OrderTrackingMapper)
}

// Mapper de domain a raw (database) - para crear/actualizar
export const OrderTrackingToRawMapper = (
  orderTracking: Omit<OrderTracking, 'id' | 'createdAt' | 'updatedAt'>
): Omit<OrderTrackingRaw, 'id' | 'created_at' | 'updated_at'> => {
  return {
    order_id: orderTracking.orderId,
    tracking_number: orderTracking.trackingNumber || null,
    courier_company: orderTracking.courierCompany || null,
    status: orderTracking.status,
    current_location: orderTracking.currentLocation || null,
    shipped_at: orderTracking.shippedAt || null,
    delivered_at: orderTracking.deliveredAt || null,
    delivered_to: orderTracking.deliveredTo || null,
    delivery_notes: orderTracking.deliveryNotes || null
  }
}



üìÅ ARCHIVO: src/backend/order-tracking/index.ts
------------------------------------------------------------------------------------
export * from './OrderTracking.mapper'
export { default } from './OrderTracking.model'
export * from './OrderTracking.repository'



üìÅ ARCHIVO: src/backend/order-tracking/OrderTracking.model.ts
------------------------------------------------------------------------------------
import { type OrderTracking } from '@/types/domain'

import {
  OrderTrackingMapper,
  OrderTrackingsMapper
} from './OrderTracking.mapper'
import oOrderTrackingRep from './OrderTracking.repository'

export class OrderTrackingModel {
  public async getOrderTrackings(): Promise<OrderTracking[] | null> {
    const orderTrackingsRaw = await oOrderTrackingRep.getOrderTrackings()
    return OrderTrackingsMapper(orderTrackingsRaw)
  }

  public async getOrderTrackingById(id: number): Promise<OrderTracking | null> {
    const orderTrackingRaw = await oOrderTrackingRep.getOrderTrackingById(id)
    if (!orderTrackingRaw) return null
    return OrderTrackingMapper(orderTrackingRaw)
  }

  public async getOrderTrackingsByOrderId(
    orderId: number
  ): Promise<OrderTracking[] | null> {
    const orderTrackingsRaw =
      await oOrderTrackingRep.getOrderTrackingsByOrderId(orderId)
    return OrderTrackingsMapper(orderTrackingsRaw)
  }

  public async getOrderTrackingByTrackingNumber(
    trackingNumber: string
  ): Promise<OrderTracking | null> {
    const orderTrackingRaw =
      await oOrderTrackingRep.getOrderTrackingByTrackingNumber(trackingNumber)
    if (!orderTrackingRaw) return null
    return OrderTrackingMapper(orderTrackingRaw)
  }

  public async getOrderTrackingsByStatus(
    status: string
  ): Promise<OrderTracking[] | null> {
    const orderTrackingsRaw =
      await oOrderTrackingRep.getOrderTrackingsByStatus(status)
    return OrderTrackingsMapper(orderTrackingsRaw)
  }

  public async getOrderTrackingsByCourierCompany(
    courierCompany: string
  ): Promise<OrderTracking[] | null> {
    const orderTrackingsRaw =
      await oOrderTrackingRep.getOrderTrackingsByCourierCompany(courierCompany)
    return OrderTrackingsMapper(orderTrackingsRaw)
  }

  public async createOrderTracking(
    orderTrackingData: Omit<OrderTracking, 'id' | 'createdAt' | 'updatedAt'>
  ): Promise<OrderTracking | null> {
    // Filtrar campos undefined para evitar errores de tipo
    const createData: any = {
      orderId: orderTrackingData.orderId,
      status: orderTrackingData.status
    }

    if (orderTrackingData.trackingNumber !== undefined) {
      createData.trackingNumber = orderTrackingData.trackingNumber
    }
    if (orderTrackingData.courierCompany !== undefined) {
      createData.courierCompany = orderTrackingData.courierCompany
    }
    if (orderTrackingData.currentLocation !== undefined) {
      createData.currentLocation = orderTrackingData.currentLocation
    }
    if (orderTrackingData.shippedAt !== undefined) {
      createData.shippedAt = orderTrackingData.shippedAt
    }
    if (orderTrackingData.deliveredAt !== undefined) {
      createData.deliveredAt = orderTrackingData.deliveredAt
    }
    if (orderTrackingData.deliveredTo !== undefined) {
      createData.deliveredTo = orderTrackingData.deliveredTo
    }
    if (orderTrackingData.deliveryNotes !== undefined) {
      createData.deliveryNotes = orderTrackingData.deliveryNotes
    }

    const created = await oOrderTrackingRep.createOrderTracking(createData)
    if (!created) return null
    return OrderTrackingMapper(created)
  }

  public async updateOrderTracking(
    orderTrackingData: Partial<
      Omit<OrderTracking, 'id' | 'createdAt' | 'updatedAt'>
    >,
    id: number
  ): Promise<OrderTracking | null> {
    // Filtrar campos undefined para evitar errores de tipo
    const updateData: any = {}

    if (orderTrackingData.trackingNumber !== undefined) {
      updateData.trackingNumber = orderTrackingData.trackingNumber
    }
    if (orderTrackingData.courierCompany !== undefined) {
      updateData.courierCompany = orderTrackingData.courierCompany
    }
    if (orderTrackingData.status !== undefined) {
      updateData.status = orderTrackingData.status
    }
    if (orderTrackingData.currentLocation !== undefined) {
      updateData.currentLocation = orderTrackingData.currentLocation
    }
    if (orderTrackingData.shippedAt !== undefined) {
      updateData.shippedAt = orderTrackingData.shippedAt
    }
    if (orderTrackingData.deliveredAt !== undefined) {
      updateData.deliveredAt = orderTrackingData.deliveredAt
    }
    if (orderTrackingData.deliveredTo !== undefined) {
      updateData.deliveredTo = orderTrackingData.deliveredTo
    }
    if (orderTrackingData.deliveryNotes !== undefined) {
      updateData.deliveryNotes = orderTrackingData.deliveryNotes
    }

    const updated = await oOrderTrackingRep.updateOrderTracking(id, updateData)
    if (!updated) return null
    return OrderTrackingMapper(updated)
  }

  public async updateTrackingStatus(
    id: number,
    status: string,
    currentLocation?: string,
    deliveryNotes?: string
  ): Promise<OrderTracking | null> {
    const updated = await oOrderTrackingRep.updateTrackingStatus(
      id,
      status,
      currentLocation,
      deliveryNotes
    )
    if (!updated) return null
    return OrderTrackingMapper(updated)
  }

  public async markAsShipped(
    id: number,
    shippedAt?: Date
  ): Promise<OrderTracking | null> {
    const updated = await oOrderTrackingRep.markAsShipped(id, shippedAt)
    if (!updated) return null
    return OrderTrackingMapper(updated)
  }

  public async markAsDelivered(
    id: number,
    deliveredAt?: Date,
    deliveredTo?: string,
    deliveryNotes?: string
  ): Promise<OrderTracking | null> {
    const updated = await oOrderTrackingRep.markAsDelivered(
      id,
      deliveredAt,
      deliveredTo,
      deliveryNotes
    )
    if (!updated) return null
    return OrderTrackingMapper(updated)
  }

  public async deleteOrderTracking(id: number): Promise<void> {
    await oOrderTrackingRep.deleteOrderTracking(id)
  }

  public async deleteOrderTrackingsByOrderId(orderId: number): Promise<void> {
    await oOrderTrackingRep.deleteOrderTrackingsByOrderId(orderId)
  }

  // M√©todos utilitarios
  public async getLatestTrackingByOrderId(
    orderId: number
  ): Promise<OrderTracking | null> {
    const orderTrackingRaw =
      await oOrderTrackingRep.getLatestTrackingByOrderId(orderId)
    if (!orderTrackingRaw) return null
    return OrderTrackingMapper(orderTrackingRaw)
  }

  public async getTrackingHistory(
    orderId: number
  ): Promise<OrderTracking[] | null> {
    const orderTrackingsRaw =
      await oOrderTrackingRep.getTrackingHistory(orderId)
    return OrderTrackingsMapper(orderTrackingsRaw)
  }
}

const orderTrackingModel = new OrderTrackingModel()
export default orderTrackingModel



üìÅ ARCHIVO: src/backend/order-tracking/OrderTracking.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type OrderTracking as OrderTrackingRaw } from '@/types/database'

export class OrderTrackingRepository {
  public async getOrderTrackings(): Promise<OrderTrackingRaw[] | null> {
    const orderTrackings = await executeQuery<OrderTrackingRaw[]>({
      query: 'SELECT * FROM order_tracking ORDER BY created_at DESC'
    })

    if (orderTrackings.length === 0) return null
    return orderTrackings
  }

  public async getOrderTrackingById(
    id: number
  ): Promise<OrderTrackingRaw | null> {
    const orderTrackings = await executeQuery<OrderTrackingRaw[]>({
      query: 'SELECT * FROM order_tracking WHERE id = ?',
      values: [id]
    })

    if (orderTrackings.length === 0) return null
    return orderTrackings[0]
  }

  public async getOrderTrackingsByOrderId(
    orderId: number
  ): Promise<OrderTrackingRaw[] | null> {
    const orderTrackings = await executeQuery<OrderTrackingRaw[]>({
      query: `
        SELECT * FROM order_tracking 
        WHERE order_id = ? 
        ORDER BY created_at DESC
      `,
      values: [orderId]
    })

    if (orderTrackings.length === 0) return null
    return orderTrackings
  }

  public async getOrderTrackingByTrackingNumber(
    trackingNumber: string
  ): Promise<OrderTrackingRaw | null> {
    const orderTrackings = await executeQuery<OrderTrackingRaw[]>({
      query: 'SELECT * FROM order_tracking WHERE tracking_number = ?',
      values: [trackingNumber]
    })

    if (orderTrackings.length === 0) return null
    return orderTrackings[0]
  }

  public async getOrderTrackingsByStatus(
    status: string
  ): Promise<OrderTrackingRaw[] | null> {
    const orderTrackings = await executeQuery<OrderTrackingRaw[]>({
      query: `
        SELECT * FROM order_tracking 
        WHERE status = ? 
        ORDER BY created_at DESC
      `,
      values: [status]
    })

    if (orderTrackings.length === 0) return null
    return orderTrackings
  }

  public async getOrderTrackingsByCourierCompany(
    courierCompany: string
  ): Promise<OrderTrackingRaw[] | null> {
    const orderTrackings = await executeQuery<OrderTrackingRaw[]>({
      query: `
        SELECT * FROM order_tracking 
        WHERE courier_company = ? 
        ORDER BY created_at DESC
      `,
      values: [courierCompany]
    })

    if (orderTrackings.length === 0) return null
    return orderTrackings
  }

  public async createOrderTracking(data: {
    orderId: number
    trackingNumber?: string
    courierCompany?: string
    status: string
    currentLocation?: string
    shippedAt?: Date
    deliveredAt?: Date
    deliveredTo?: string
    deliveryNotes?: string
  }): Promise<OrderTrackingRaw | null> {
    const result = await executeQuery<{ insertId: number }>({
      query: `
        INSERT INTO order_tracking (
          order_id, tracking_number, courier_company, status, 
          current_location, shipped_at, delivered_at, delivered_to, delivery_notes
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `,
      values: [
        data.orderId,
        data.trackingNumber || null,
        data.courierCompany || null,
        data.status,
        data.currentLocation || null,
        data.shippedAt || null,
        data.deliveredAt || null,
        data.deliveredTo || null,
        data.deliveryNotes || null
      ]
    })

    return await this.getOrderTrackingById(result.insertId)
  }

  public async updateOrderTracking(
    id: number,
    data: {
      trackingNumber?: string
      courierCompany?: string
      status?: string
      currentLocation?: string
      shippedAt?: Date
      deliveredAt?: Date
      deliveredTo?: string
      deliveryNotes?: string
    }
  ): Promise<OrderTrackingRaw | null> {
    const fields: string[] = []
    const values: any[] = []

    if (data.trackingNumber !== undefined) {
      fields.push('tracking_number = ?')
      values.push(data.trackingNumber)
    }
    if (data.courierCompany !== undefined) {
      fields.push('courier_company = ?')
      values.push(data.courierCompany)
    }
    if (data.status !== undefined) {
      fields.push('status = ?')
      values.push(data.status)
    }
    if (data.currentLocation !== undefined) {
      fields.push('current_location = ?')
      values.push(data.currentLocation)
    }
    if (data.shippedAt !== undefined) {
      fields.push('shipped_at = ?')
      values.push(data.shippedAt)
    }
    if (data.deliveredAt !== undefined) {
      fields.push('delivered_at = ?')
      values.push(data.deliveredAt)
    }
    if (data.deliveredTo !== undefined) {
      fields.push('delivered_to = ?')
      values.push(data.deliveredTo)
    }
    if (data.deliveryNotes !== undefined) {
      fields.push('delivery_notes = ?')
      values.push(data.deliveryNotes)
    }

    if (fields.length === 0) {
      return await this.getOrderTrackingById(id)
    }

    values.push(id)

    await executeQuery({
      query: `UPDATE order_tracking SET ${fields.join(', ')} WHERE id = ?`,
      values
    })

    return await this.getOrderTrackingById(id)
  }

  public async updateTrackingStatus(
    id: number,
    status: string,
    currentLocation?: string,
    deliveryNotes?: string
  ): Promise<OrderTrackingRaw | null> {
    const fields = ['status = ?']
    const values = [status]

    if (currentLocation !== undefined) {
      fields.push('current_location = ?')
      values.push(currentLocation)
    }
    if (deliveryNotes !== undefined) {
      fields.push('delivery_notes = ?')
      values.push(deliveryNotes)
    }

    values.push(id)

    await executeQuery({
      query: `UPDATE order_tracking SET ${fields.join(', ')} WHERE id = ?`,
      values
    })

    return await this.getOrderTrackingById(id)
  }

  public async markAsShipped(
    id: number,
    shippedAt?: Date
  ): Promise<OrderTrackingRaw | null> {
    await executeQuery({
      query: `
        UPDATE order_tracking 
        SET status = 'shipped', shipped_at = COALESCE(?, NOW()) 
        WHERE id = ?
      `,
      values: [shippedAt, id]
    })

    return await this.getOrderTrackingById(id)
  }

  public async markAsDelivered(
    id: number,
    deliveredAt?: Date,
    deliveredTo?: string,
    deliveryNotes?: string
  ): Promise<OrderTrackingRaw | null> {
    await executeQuery({
      query: `
        UPDATE order_tracking 
        SET status = 'delivered', 
            delivered_at = COALESCE(?, NOW()),
            delivered_to = COALESCE(?, delivered_to),
            delivery_notes = COALESCE(?, delivery_notes)
        WHERE id = ?
      `,
      values: [deliveredAt, deliveredTo, deliveryNotes, id]
    })

    return await this.getOrderTrackingById(id)
  }

  public async deleteOrderTracking(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM order_tracking WHERE id = ?',
      values: [id]
    })
  }

  public async deleteOrderTrackingsByOrderId(orderId: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM order_tracking WHERE order_id = ?',
      values: [orderId]
    })
  }

  // M√©todos utilitarios
  public async getLatestTrackingByOrderId(
    orderId: number
  ): Promise<OrderTrackingRaw | null> {
    const orderTrackings = await executeQuery<OrderTrackingRaw[]>({
      query: `
        SELECT * FROM order_tracking 
        WHERE order_id = ? 
        ORDER BY created_at DESC 
        LIMIT 1
      `,
      values: [orderId]
    })

    if (orderTrackings.length === 0) return null
    return orderTrackings[0]
  }

  public async getTrackingHistory(
    orderId: number
  ): Promise<OrderTrackingRaw[] | null> {
    const orderTrackings = await executeQuery<OrderTrackingRaw[]>({
      query: `
        SELECT * FROM order_tracking 
        WHERE order_id = ? 
        ORDER BY created_at ASC
      `,
      values: [orderId]
    })

    if (orderTrackings.length === 0) return null
    return orderTrackings
  }
}

const orderTrackingRepository = new OrderTrackingRepository()
export default orderTrackingRepository



üìÅ ARCHIVO: src/backend/variant-attribute-option/VariantAttributeOption.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import {
  type AttributeOptions,
  type Attributes,
  type VariantAttributeOptions as VariantAttributeOptionRaw
} from '@/types/database'

export interface VariantAttributeOptionWithDetailsRaw
  extends VariantAttributeOptionRaw {
  attribute_option_value: AttributeOptions['value']
  additional_cost: AttributeOptions['additional_cost']
  attribute_id: AttributeOptions['attribute_id']
  attribute_name: Attributes['name']
  attribute_display_type: Attributes['display_type']
}

export class VariantAttributeOptionRepository {
  public async getVariantAttributeOptionsByVariantId(
    variantId: number
  ): Promise<VariantAttributeOptionRaw[] | null> {
    const options = await executeQuery<VariantAttributeOptionRaw[]>({
      query: 'SELECT * FROM variant_attribute_options WHERE variant_id = ?',
      values: [variantId]
    })

    if (options.length === 0) return null
    return options
  }

  public async getVariantAttributeOptionsWithDetailsById(
    variantId: number
  ): Promise<VariantAttributeOptionWithDetailsRaw[] | null> {
    const options = await executeQuery<VariantAttributeOptionWithDetailsRaw[]>({
      query: `
        SELECT 
          vao.variant_id,
          vao.attribute_option_id,
          ao.value as attribute_option_value,
          ao.additional_cost,
          ao.attribute_id,
          a.name as attribute_name,
          a.display_type as attribute_display_type
        FROM variant_attribute_options vao
        JOIN attribute_options ao ON vao.attribute_option_id = ao.id
        JOIN attributes a ON ao.attribute_id = a.id
        WHERE vao.variant_id = ?
        ORDER BY a.id, ao.id
      `,
      values: [variantId]
    })

    if (options.length === 0) return null
    return options
  }

  public async getVariantAttributeOptionsByAttributeOptionId(
    attributeOptionId: number
  ): Promise<VariantAttributeOptionRaw[] | null> {
    const options = await executeQuery<VariantAttributeOptionRaw[]>({
      query:
        'SELECT * FROM variant_attribute_options WHERE attribute_option_id = ?',
      values: [attributeOptionId]
    })

    if (options.length === 0) return null
    return options
  }

  public async getVariantAttributeOptionsByVariantIds(
    variantIds: number[]
  ): Promise<VariantAttributeOptionRaw[] | null> {
    if (variantIds.length === 0) return null

    const placeholders = variantIds.map(() => '?').join(',')
    const options = await executeQuery<VariantAttributeOptionRaw[]>({
      query: `SELECT * FROM variant_attribute_options WHERE variant_id IN (${placeholders})`,
      values: variantIds
    })

    if (options.length === 0) return null
    return options
  }

  public async getVariantAttributeOptionsByAttributeOptionIds(
    attributeOptionIds: number[]
  ): Promise<VariantAttributeOptionRaw[] | null> {
    if (attributeOptionIds.length === 0) return null

    const placeholders = attributeOptionIds.map(() => '?').join(',')
    const options = await executeQuery<VariantAttributeOptionRaw[]>({
      query: `SELECT * FROM variant_attribute_options WHERE attribute_option_id IN (${placeholders})`,
      values: attributeOptionIds
    })

    if (options.length === 0) return null
    return options
  }

  public async createVariantAttributeOption(
    option: VariantAttributeOptionRaw
  ): Promise<VariantAttributeOptionRaw | null> {
    await executeQuery({
      query: 'INSERT INTO variant_attribute_options SET ?',
      values: [option]
    })

    // Como es una tabla de uni√≥n, retornamos el objeto insertado
    return option
  }

  public async deleteVariantAttributeOption(
    variantId: number,
    attributeOptionId: number
  ): Promise<void> {
    await executeQuery({
      query:
        'DELETE FROM variant_attribute_options WHERE variant_id = ? AND attribute_option_id = ?',
      values: [variantId, attributeOptionId]
    })
  }

  public async deleteVariantAttributeOptionsByVariantId(
    variantId: number
  ): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM variant_attribute_options WHERE variant_id = ?',
      values: [variantId]
    })
  }

  public async deleteVariantAttributeOptionsByAttributeOptionId(
    attributeOptionId: number
  ): Promise<void> {
    await executeQuery({
      query:
        'DELETE FROM variant_attribute_options WHERE attribute_option_id = ?',
      values: [attributeOptionId]
    })
  }
}

const variantAttributeOptionRepository = new VariantAttributeOptionRepository()
export default variantAttributeOptionRepository



üìÅ ARCHIVO: src/backend/variant-attribute-option/VariantAttributeOption.mapper.ts
------------------------------------------------------------------------------------
import { type VariantAttributeOptionWithDetailsRaw } from '@/backend/variant-attribute-option'
import { type VariantAttributeOptions as VariantAttributeOptionRaw } from '@/types/database'
import { type VariantAttributeOptions as VariantAttributeOption } from '@/types/domain'

export const VariantAttributeOptionMapper = (
  data: VariantAttributeOptionRaw
): VariantAttributeOption => {
  return {
    variantId: data.variant_id,
    attributeOptionId: data.attribute_option_id,
    attributeOption: undefined, // Se llena en el modelo con l√≥gica de negocio
    productVariants: undefined // Se llena en el modelo con l√≥gica de negocio
  }
}

export const VariantAttributeOptionsMapper = (
  data: VariantAttributeOptionRaw[] | null
): VariantAttributeOption[] | undefined => {
  if (data === null) return undefined
  return data.map(VariantAttributeOptionMapper)
}

export const VariantAttributeOptionsWithDetailMapper = (
  data: VariantAttributeOptionWithDetailsRaw[]
): VariantAttributeOption[] => {
  return data.map((item) => ({
    attributeOptionId: item.attribute_option_id,
    variantId: item.variant_id,
    attributeOption: {
      attributeId: item.attribute_id,
      id: item.attribute_option_id,
      value: item.attribute_option_value,
      additionalCost: item.additional_cost,
      attribute: {
        displayType: item.attribute_display_type,
        id: item.attribute_id,
        name: item.attribute_name
      }
    }
  }))
}



üìÅ ARCHIVO: src/backend/variant-attribute-option/VariantAttributeOption.model.ts
------------------------------------------------------------------------------------
import { type VariantAttributeOptions as VariantAttributeOptionRaw } from '@/types/database'
import {
  type VariantAttributeOptions as VariantAttributeOption,
  type VariantAttributeOptions
} from '@/types/domain'

// me
import {
  VariantAttributeOptionMapper,
  VariantAttributeOptionsMapper,
  VariantAttributeOptionsWithDetailMapper
} from './VariantAttributeOption.mapper'
import oVariantAttributeOptionRep from './VariantAttributeOption.repository'

export class VariantAttributeOptionModel {
  public async getVariantAttributeOptionsByVariantId(
    variantId: number
  ): Promise<VariantAttributeOption[] | undefined> {
    const optionsRaw =
      await oVariantAttributeOptionRep.getVariantAttributeOptionsByVariantId(
        variantId
      )
    return VariantAttributeOptionsMapper(optionsRaw)
  }

  public async getVariantAttributeOptionsByAttributeOptionId(
    attributeOptionId: number
  ): Promise<VariantAttributeOption[] | undefined> {
    const optionsRaw =
      await oVariantAttributeOptionRep.getVariantAttributeOptionsByAttributeOptionId(
        attributeOptionId
      )
    return VariantAttributeOptionsMapper(optionsRaw)
  }

  public async getVariantAttributeOptionsByVariantIds(
    variantIds: number[]
  ): Promise<Map<number, VariantAttributeOption[]>> {
    const optionsRaw =
      await oVariantAttributeOptionRep.getVariantAttributeOptionsByVariantIds(
        variantIds
      )

    if (!optionsRaw) return new Map()

    // Agrupar options por variant_id
    const optionsByVariantId = new Map<number, VariantAttributeOption[]>()

    for (const optionRaw of optionsRaw) {
      const option = VariantAttributeOptionMapper(optionRaw)
      const variantId = option.variantId

      if (!optionsByVariantId.has(variantId)) {
        optionsByVariantId.set(variantId, [])
      }

      optionsByVariantId.get(variantId)!.push(option)
    }

    return optionsByVariantId
  }

  public async getVariantAttributeOptionsByAttributeOptionIds(
    attributeOptionIds: number[]
  ): Promise<Map<number, VariantAttributeOption[]>> {
    const optionsRaw =
      await oVariantAttributeOptionRep.getVariantAttributeOptionsByAttributeOptionIds(
        attributeOptionIds
      )

    if (!optionsRaw) return new Map()

    // Agrupar options por attribute_option_id
    const optionsByAttributeOptionId = new Map<
      number,
      VariantAttributeOption[]
    >()

    for (const optionRaw of optionsRaw) {
      const option = VariantAttributeOptionMapper(optionRaw)
      const attributeOptionId = option.attributeOptionId

      if (!optionsByAttributeOptionId.has(attributeOptionId)) {
        optionsByAttributeOptionId.set(attributeOptionId, [])
      }

      optionsByAttributeOptionId.get(attributeOptionId)!.push(option)
    }

    return optionsByAttributeOptionId
  }

  public async createVariantAttributeOption(
    optionData: VariantAttributeOptionRaw
  ): Promise<VariantAttributeOption | undefined> {
    const created =
      await oVariantAttributeOptionRep.createVariantAttributeOption(optionData)
    if (!created) return undefined
    return VariantAttributeOptionMapper(created)
  }

  public async deleteVariantAttributeOption(
    variantId: number,
    attributeOptionId: number
  ): Promise<void> {
    await oVariantAttributeOptionRep.deleteVariantAttributeOption(
      variantId,
      attributeOptionId
    )
  }

  public async deleteVariantAttributeOptionsByVariantId(
    variantId: number
  ): Promise<void> {
    await oVariantAttributeOptionRep.deleteVariantAttributeOptionsByVariantId(
      variantId
    )
  }

  public async deleteVariantAttributeOptionsByAttributeOptionId(
    attributeOptionId: number
  ): Promise<void> {
    await oVariantAttributeOptionRep.deleteVariantAttributeOptionsByAttributeOptionId(
      attributeOptionId
    )
  }

  public async getVariantAttributeOptionsWithDetailsById(
    variantId: number
  ): Promise<VariantAttributeOptions[] | undefined> {
    const attributeOptionsFlatRaw =
      await oVariantAttributeOptionRep.getVariantAttributeOptionsWithDetailsById(
        variantId
      )

    if (attributeOptionsFlatRaw === null) return undefined
    const options = VariantAttributeOptionsWithDetailMapper(
      attributeOptionsFlatRaw
    )

    return options
  }

  public async addAttributeOptionToVariant(
    variantId: number,
    attributeOptionId: number
  ): Promise<VariantAttributeOption | undefined> {
    const optionData: VariantAttributeOptionRaw = {
      variant_id: variantId,
      attribute_option_id: attributeOptionId
    }
    return await this.createVariantAttributeOption(optionData)
  }

  public async removeAttributeOptionFromVariant(
    variantId: number,
    attributeOptionId: number
  ): Promise<void> {
    await this.deleteVariantAttributeOption(variantId, attributeOptionId)
  }
}

const variantAttributeOptionModel = new VariantAttributeOptionModel()
export default variantAttributeOptionModel



üìÅ ARCHIVO: src/backend/variant-attribute-option/index.ts
------------------------------------------------------------------------------------
export * from './VariantAttributeOption.mapper'
export { default } from './VariantAttributeOption.model'
export * from './VariantAttributeOption.repository'



üìÅ ARCHIVO: src/backend/variant-attribute-option/VariantAttributeOption.interfaces.ts
------------------------------------------------------------------------------------
import { type AttributesDisplayType } from '@/types/domain'

export interface VariantAttributeOptionWithDetails {
  attributeOptionValue: string
  additionalCost: number
  attributeId: number
  attributeName: string
  attributeDisplayType: AttributesDisplayType
  variantId: number
  attributeOptionId: number
}



üìÅ ARCHIVO: src/backend/payment-method/PaymentMethod.repository.ts
------------------------------------------------------------------------------------
// üìÑ PaymentMethod.repository.ts
import { executeQuery } from '@/lib/db'
import { type PaymentMethods as PaymentMethodRaw } from '@/types/database'

interface PaymentMethodWithStats extends PaymentMethodRaw {
  total_transactions?: number
  total_amount?: number
  last_used?: Date
}

export class PaymentMethodRepository {
  public async getPaymentMethods(): Promise<PaymentMethodRaw[] | null> {
    const methods = await executeQuery<PaymentMethodRaw[]>({
      query: `
        SELECT * FROM payment_methods 
        WHERE is_active = 1 
        ORDER BY display_order ASC, name ASC
      `
    })

    if (methods.length === 0) return null
    return methods
  }

  public async getAllPaymentMethods(): Promise<PaymentMethodRaw[] | null> {
    const methods = await executeQuery<PaymentMethodRaw[]>({
      query: `
        SELECT * FROM payment_methods 
        ORDER BY display_order ASC, name ASC
      `
    })

    if (methods.length === 0) return null
    return methods
  }

  public async getPaymentMethodById(
    id: number
  ): Promise<PaymentMethodRaw | null> {
    const methods = await executeQuery<PaymentMethodRaw[]>({
      query: 'SELECT * FROM payment_methods WHERE id = ?',
      values: [id]
    })

    if (methods.length === 0) return null
    return methods[0]
  }

  public async getPaymentMethodByCode(
    code: string
  ): Promise<PaymentMethodRaw | null> {
    const methods = await executeQuery<PaymentMethodRaw[]>({
      query: 'SELECT * FROM payment_methods WHERE code = ? AND is_active = 1',
      values: [code]
    })

    if (methods.length === 0) return null
    return methods[0]
  }

  public async getPaymentMethodsForAmount(
    amount: number
  ): Promise<PaymentMethodRaw[] | null> {
    const methods = await executeQuery<PaymentMethodRaw[]>({
      query: `
        SELECT * FROM payment_methods 
        WHERE is_active = 1 
        AND (min_amount IS NULL OR min_amount <= ?)
        AND (max_amount IS NULL OR max_amount >= ?)
        ORDER BY display_order ASC, name ASC
      `,
      values: [amount, amount]
    })

    if (methods.length === 0) return null
    return methods
  }

  public async getPaymentMethodsWithStats(): Promise<
    PaymentMethodWithStats[] | null
  > {
    const methods = await executeQuery<PaymentMethodWithStats[]>({
      query: `
        SELECT 
          pm.*,
          COUNT(pt.id) as total_transactions,
          COALESCE(SUM(pt.amount), 0) as total_amount,
          MAX(pt.created_at) as last_used
        FROM payment_methods pm
        LEFT JOIN payment_transactions pt ON pm.id = pt.payment_method_id 
          AND pt.status = 'completed'
        WHERE pm.is_active = 1
        GROUP BY pm.id
        ORDER BY pm.display_order ASC, pm.name ASC
      `
    })

    if (methods.length === 0) return null
    return methods
  }

  public async createPaymentMethod(
    method: Omit<PaymentMethodRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<PaymentMethodRaw | null> {
    const methodData = {
      ...method,
      created_at: new Date(),
      updated_at: new Date()
    }

    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO payment_methods SET ?',
      values: [methodData]
    })

    return await this.getPaymentMethodById(result.insertId)
  }

  public async updatePaymentMethod(
    methodData: Partial<Omit<PaymentMethodRaw, 'id' | 'created_at'>>,
    id: number
  ): Promise<PaymentMethodRaw | null> {
    const updateData = {
      ...methodData,
      updated_at: new Date()
    }

    await executeQuery({
      query: 'UPDATE payment_methods SET ? WHERE id = ?',
      values: [updateData, id]
    })

    return await this.getPaymentMethodById(id)
  }

  public async deletePaymentMethod(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM payment_methods WHERE id = ?',
      values: [id]
    })
  }

  public async activatePaymentMethod(id: number): Promise<void> {
    await executeQuery({
      query:
        'UPDATE payment_methods SET is_active = 1, updated_at = ? WHERE id = ?',
      values: [new Date(), id]
    })
  }

  public async deactivatePaymentMethod(id: number): Promise<void> {
    await executeQuery({
      query:
        'UPDATE payment_methods SET is_active = 0, updated_at = ? WHERE id = ?',
      values: [new Date(), id]
    })
  }

  public async updateDisplayOrder(
    id: number,
    displayOrder: number
  ): Promise<void> {
    await executeQuery({
      query:
        'UPDATE payment_methods SET display_order = ?, updated_at = ? WHERE id = ?',
      values: [displayOrder, new Date(), id]
    })
  }

  public async updateSettings(id: number, settings: any): Promise<void> {
    await executeQuery({
      query:
        'UPDATE payment_methods SET settings = ?, updated_at = ? WHERE id = ?',
      values: [JSON.stringify(settings), new Date(), id]
    })
  }
}

const paymentMethodRepository = new PaymentMethodRepository()
export default paymentMethodRepository



üìÅ ARCHIVO: src/backend/payment-method/PaymentMethod.mapper.ts
------------------------------------------------------------------------------------
// üìÑ PaymentMethod.mapper.ts
import { type PaymentMethods as PaymentMethodRaw } from '@/types/database'
import { type PaymentMethods as PaymentMethod } from '@/types/domain'

export const PaymentMethodMapper = (data: PaymentMethodRaw): PaymentMethod => {
  return {
    id: data.id,
    name: data.name,
    code: data.code,
    description: data.description,
    iconUrl: data.icon_url,
    isActive: data.is_active,
    minAmount: Number(data.min_amount),
    maxAmount: Number(data.max_amount),
    processingFeeType: data.processing_fee_type,
    processingFeeValue: Number(data.processing_fee_value),
    requiresVerification: data.requires_verification,
    settings: data.settings,
    displayOrder: Number(data.display_order),
    createdAt: data.created_at,
    updatedAt: data.updated_at
  }
}

export const PaymentMethodsMapper = (
  data: PaymentMethodRaw[] | null
): PaymentMethod[] | undefined => {
  if (data === null) return undefined
  return data.map(PaymentMethodMapper)
}



üìÅ ARCHIVO: src/backend/payment-method/index.ts
------------------------------------------------------------------------------------
export * from './PaymentMethod.interfaces'
export * from './PaymentMethod.mapper'
export { default } from './PaymentMethod.model'
export * from './PaymentMethod.repository'



üìÅ ARCHIVO: src/backend/payment-method/PaymentMethod.interfaces.ts
------------------------------------------------------------------------------------
// üìÑ PaymentMethod.interfaces.ts
import { type PaymentMethods as PaymentMethod } from '@/types/domain'

export interface PaymentMethodExtended extends PaymentMethod {
  totalTransactions?: number
  totalAmount?: number
  lastUsed?: Date
}

export interface PaymentCalculation {
  methodId: number
  baseAmount: number
  processingFee: number
  finalAmount: number
  feeType: 'fixed' | 'percentage'
  isValid: boolean
  reason?: string
}

export interface PaymentMethodFilter {
  isActive?: boolean
  minAmount?: number
  maxAmount?: number
  orderValue?: number
}



üìÅ ARCHIVO: src/backend/payment-method/PaymentMethod.model.ts
------------------------------------------------------------------------------------
// üìÑ PaymentMethod.model.ts
import { type PaymentMethods as PaymentMethodRaw } from '@/types/database'
import { type PaymentMethods as PaymentMethod } from '@/types/domain'

import {
  type PaymentCalculation,
  type PaymentMethodExtended,
  type PaymentMethodFilter
} from './PaymentMethod.interfaces'
import {
  PaymentMethodMapper,
  PaymentMethodsMapper
} from './PaymentMethod.mapper'
import oPaymentMethodRep from './PaymentMethod.repository'

export class PaymentMethodModel {
  public async getPaymentMethods(): Promise<PaymentMethod[] | undefined> {
    const methodsRaw = await oPaymentMethodRep.getPaymentMethods()
    return PaymentMethodsMapper(methodsRaw)
  }

  public async getAllPaymentMethods(): Promise<PaymentMethod[] | undefined> {
    const methodsRaw = await oPaymentMethodRep.getAllPaymentMethods()
    return PaymentMethodsMapper(methodsRaw)
  }

  public async getPaymentMethodById(
    id: number
  ): Promise<PaymentMethod | undefined> {
    const methodRaw = await oPaymentMethodRep.getPaymentMethodById(id)
    if (!methodRaw) return undefined
    return PaymentMethodMapper(methodRaw)
  }

  public async getPaymentMethodByCode(
    code: string
  ): Promise<PaymentMethod | undefined> {
    const methodRaw = await oPaymentMethodRep.getPaymentMethodByCode(code)
    if (!methodRaw) return undefined
    return PaymentMethodMapper(methodRaw)
  }

  public async getPaymentMethodsForAmount(
    amount: number
  ): Promise<PaymentMethod[] | undefined> {
    const methodsRaw =
      await oPaymentMethodRep.getPaymentMethodsForAmount(amount)
    return PaymentMethodsMapper(methodsRaw)
  }

  public async getPaymentMethodsWithStats(): Promise<
    PaymentMethodExtended[] | undefined
  > {
    const methodsRaw = await oPaymentMethodRep.getPaymentMethodsWithStats()
    if (!methodsRaw) return undefined

    return methodsRaw.map((method) => ({
      ...PaymentMethodMapper(method),
      totalTransactions: method.total_transactions,
      totalAmount: method.total_amount,
      lastUsed: method.last_used
    }))
  }

  public async getFilteredPaymentMethods(
    filter: PaymentMethodFilter = {}
  ): Promise<PaymentMethod[] | undefined> {
    let methods = await this.getPaymentMethods()
    if (!methods) return undefined

    // Aplicar filtros
    if (filter.isActive !== undefined) {
      methods = methods.filter(
        (method) => (method.isActive === 1) === filter.isActive
      )
    }

    if (filter.orderValue !== undefined) {
      methods = methods.filter((method) => {
        const min = method.minAmount
        const max = method.maxAmount
        const value = filter.orderValue!

        const validMin = min === null || min === undefined || value >= min
        const validMax = max === null || max === undefined || value <= max

        return validMin && validMax
      })
    }

    if (filter.minAmount !== undefined) {
      methods = methods.filter(
        (method) =>
          method.minAmount === null ||
          method.minAmount === undefined ||
          method.minAmount <= filter.minAmount!
      )
    }

    if (filter.maxAmount !== undefined) {
      methods = methods.filter(
        (method) =>
          method.maxAmount === null ||
          method.maxAmount === undefined ||
          method.maxAmount >= filter.maxAmount!
      )
    }

    return methods
  }

  public async createPaymentMethod(
    methodData: Omit<PaymentMethodRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<PaymentMethod | undefined> {
    const created = await oPaymentMethodRep.createPaymentMethod(methodData)
    if (!created) return undefined
    return PaymentMethodMapper(created)
  }

  public async updatePaymentMethod(
    methodData: Partial<Omit<PaymentMethodRaw, 'id' | 'created_at'>>,
    id: number
  ): Promise<PaymentMethod | undefined> {
    const updated = await oPaymentMethodRep.updatePaymentMethod(methodData, id)
    if (!updated) return undefined
    return PaymentMethodMapper(updated)
  }

  public async deletePaymentMethod(id: number): Promise<void> {
    await oPaymentMethodRep.deletePaymentMethod(id)
  }

  public async activatePaymentMethod(id: number): Promise<void> {
    await oPaymentMethodRep.activatePaymentMethod(id)
  }

  public async deactivatePaymentMethod(id: number): Promise<void> {
    await oPaymentMethodRep.deactivatePaymentMethod(id)
  }

  public async updateDisplayOrder(
    id: number,
    displayOrder: number
  ): Promise<void> {
    await oPaymentMethodRep.updateDisplayOrder(id, displayOrder)
  }

  public async updateSettings(id: number, settings: any): Promise<void> {
    await oPaymentMethodRep.updateSettings(id, settings)
  }

  // M√©todo para calcular comisiones y validar un m√©todo de pago
  public calculatePaymentFee(
    method: PaymentMethod,
    amount: number
  ): PaymentCalculation {
    // Validar l√≠mites de monto

    const isValidAmount = this.isValidAmountForMethod(method, amount)

    let processingFee = 0

    if (method.processingFeeValue && method.processingFeeValue > 0) {
      if (method.processingFeeType === 'percentage') {
        processingFee = (amount * method.processingFeeValue) / 100
      } else {
        processingFee = method.processingFeeValue
      }
    }

    return {
      methodId: method.id,
      baseAmount: amount,
      processingFee,
      finalAmount: amount + processingFee,
      feeType: method.processingFeeType || 'fixed',
      isValid: isValidAmount.isValid,
      reason: isValidAmount.reason
    }
  }

  // M√©todo para validar si un monto es v√°lido para un m√©todo
  public isValidAmountForMethod(
    method: PaymentMethod,
    amount: number
  ): { isValid: boolean, reason?: string } {
    if (method.minAmount && amount < method.minAmount) {
      return {
        isValid: false,
        reason: `Monto m√≠nimo: S/ ${method.minAmount}`
      }
    }

    if (method.maxAmount && amount > method.maxAmount) {
      return {
        isValid: false,
        reason: `Monto m√°ximo: S/ ${method.maxAmount}`
      }
    }

    return { isValid: true }
  }

  // M√©todo para obtener m√©todos de pago v√°lidos para un monto
  public async getValidPaymentMethodsForAmount(
    amount: number
  ): Promise<PaymentCalculation[] | undefined> {
    const methods = await this.getPaymentMethods()
    if (!methods) return undefined

    const validMethods: PaymentCalculation[] = []

    for (const method of methods) {
      const calculation = this.calculatePaymentFee(method, Number(amount))
      if (calculation.isValid) {
        validMethods.push(calculation)
      }
    }

    return validMethods.length > 0 ? validMethods : undefined
  }

  // M√©todo para verificar si un m√©todo requiere verificaci√≥n adicional
  public requiresVerification(method: PaymentMethod): boolean {
    return method.requiresVerification === 1
  }

  // M√©todo para obtener configuraciones espec√≠ficas de un m√©todo
  public getMethodSettings(method: PaymentMethod): any {
    if (!method.settings) return {}

    try {
      return typeof method.settings === 'string'
        ? JSON.parse(method.settings)
        : method.settings
    } catch {
      return {}
    }
  }
}

const paymentMethodModel = new PaymentMethodModel()
export default paymentMethodModel



üìÅ ARCHIVO: src/backend/order-item/OrderItem.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type OrderItems as OrderItemsRaw } from '@/types/database'

export class OrderItemsRepository {
  public async getOrderItems(): Promise<OrderItemsRaw[] | null> {
    const items = await executeQuery<OrderItemsRaw[]>({
      query: 'SELECT * FROM order_items ORDER BY id'
    })

    if (items.length === 0) return null
    return items
  }

  public async getOrderItemById(id: number): Promise<OrderItemsRaw | null> {
    const items = await executeQuery<OrderItemsRaw[]>({
      query: 'SELECT * FROM order_items WHERE id = ?',
      values: [id]
    })

    if (items.length === 0) return null
    return items[0]
  }

  public async getOrderItemsByOrderId(
    orderId: number
  ): Promise<OrderItemsRaw[] | null> {
    const items = await executeQuery<OrderItemsRaw[]>({
      query: 'SELECT * FROM order_items WHERE order_id = ?',
      values: [orderId]
    })

    if (items.length === 0) return null
    return items
  }

  public async getOrderItemsByVariantId(
    variantId: number
  ): Promise<OrderItemsRaw[] | null> {
    const items = await executeQuery<OrderItemsRaw[]>({
      query: 'SELECT * FROM order_items WHERE variant_id = ?',
      values: [variantId]
    })

    if (items.length === 0) return null
    return items
  }

  public async createOrderItem(
    orderItem: Omit<OrderItemsRaw, 'id'>
  ): Promise<OrderItemsRaw | null> {
    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO order_items SET ?',
      values: [orderItem]
    })

    return await this.getOrderItemById(result.insertId)
  }

  public async createOrderItems(
    orderItems: Array<Omit<OrderItemsRaw, 'id'>>
  ): Promise<OrderItemsRaw[] | null> {
    const createdItems: OrderItemsRaw[] = []

    for (const item of orderItems) {
      const created = await this.createOrderItem(item)
      if (created) createdItems.push(created)
    }

    return createdItems.length > 0 ? createdItems : null
  }

  public async updateOrderItem(
    itemData: Partial<Omit<OrderItemsRaw, 'id'>>,
    id: number
  ): Promise<OrderItemsRaw | null> {
    await executeQuery({
      query: 'UPDATE order_items SET ? WHERE id = ?',
      values: [itemData, id]
    })

    return await this.getOrderItemById(id)
  }

  public async deleteOrderItem(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM order_items WHERE id = ?',
      values: [id]
    })
  }

  public async deleteOrderItemsByOrderId(orderId: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM order_items WHERE order_id = ?',
      values: [orderId]
    })
  }

  // M√©todos utilitarios
  public async getTotalByOrderId(orderId: number): Promise<number> {
    const result = await executeQuery<Array<{ total: number }>>({
      query:
        'SELECT COALESCE(SUM(total_price), 0) as total FROM order_items WHERE order_id = ?',
      values: [orderId]
    })

    return result[0]?.total || 0
  }

  public async getItemCountByOrderId(orderId: number): Promise<number> {
    const result = await executeQuery<Array<{ count: number }>>({
      query: 'SELECT COUNT(*) as count FROM order_items WHERE order_id = ?',
      values: [orderId]
    })

    return result[0]?.count || 0
  }

  public async getQuantityTotalByOrderId(orderId: number): Promise<number> {
    const result = await executeQuery<Array<{ total: number }>>({
      query:
        'SELECT COALESCE(SUM(quantity), 0) as total FROM order_items WHERE order_id = ?',
      values: [orderId]
    })

    return result[0]?.total || 0
  }
}

const orderItemsRepository = new OrderItemsRepository()
export default orderItemsRepository



üìÅ ARCHIVO: src/backend/order-item/OrderItem.model.ts
------------------------------------------------------------------------------------
import { type OrderItems as OrderItem } from '@/types/domain'

import {
  OrderItemMapper,
  OrderItemsMapper,
  OrderItemToRawMapper
} from './OrderItem.mapper'
import oOrderItemsRep from './OrderItem.repository'

export class OrderItemsModel {
  public async getOrderItems(): Promise<OrderItem[] | undefined> {
    const orderItemsRaw = await oOrderItemsRep.getOrderItems()
    return OrderItemsMapper(orderItemsRaw)
  }

  public async getOrderItemById(id: number): Promise<OrderItem | undefined> {
    const orderItemRaw = await oOrderItemsRep.getOrderItemById(id)
    if (!orderItemRaw) return undefined
    return OrderItemMapper(orderItemRaw)
  }

  public async getOrderItemsByOrderId(
    orderId: number
  ): Promise<OrderItem[] | undefined> {
    const orderItemsRaw = await oOrderItemsRep.getOrderItemsByOrderId(orderId)
    return OrderItemsMapper(orderItemsRaw)
  }

  public async getOrderItemsByVariantId(
    variantId: number
  ): Promise<OrderItem[] | undefined> {
    const orderItemsRaw =
      await oOrderItemsRep.getOrderItemsByVariantId(variantId)
    return OrderItemsMapper(orderItemsRaw)
  }

  public async createOrderItem(
    orderItemData: Omit<OrderItem, 'id'>
  ): Promise<OrderItem | undefined> {
    const orderItemRaw = OrderItemToRawMapper(orderItemData)
    const created = await oOrderItemsRep.createOrderItem(orderItemRaw)
    if (!created) return undefined
    return OrderItemMapper(created)
  }

  public async createOrderItems(
    orderItemsData: Array<Omit<OrderItem, 'id'>>
  ): Promise<OrderItem[] | undefined> {
    const orderItemsRaw = orderItemsData.map(OrderItemToRawMapper)
    const created = await oOrderItemsRep.createOrderItems(orderItemsRaw)
    return OrderItemsMapper(created)
  }

  public async updateOrderItem(
    orderItemData: Partial<Omit<OrderItem, 'id'>>,
    id: number
  ): Promise<OrderItem | undefined> {
    // Convertir solo los campos que se van a actualizar
    const updateRaw: any = {}

    if (orderItemData.orderId !== undefined) { updateRaw.order_id = orderItemData.orderId }
    if (orderItemData.variantId !== undefined) { updateRaw.variant_id = orderItemData.variantId }
    if (orderItemData.productName !== undefined) { updateRaw.product_name = orderItemData.productName }
    if (orderItemData.variantSku !== undefined) { updateRaw.variant_sku = orderItemData.variantSku }
    if (orderItemData.variantAttributes !== undefined) {
      updateRaw.variant_attributes = orderItemData.variantAttributes
        ? JSON.stringify(orderItemData.variantAttributes)
        : null
    }
    if (orderItemData.quantity !== undefined) { updateRaw.quantity = orderItemData.quantity }
    if (orderItemData.unitPrice !== undefined) { updateRaw.unit_price = orderItemData.unitPrice }
    if (orderItemData.totalPrice !== undefined) { updateRaw.total_price = orderItemData.totalPrice }
    if (orderItemData.discountAmount !== undefined) { updateRaw.discount_amount = orderItemData.discountAmount }

    const updated = await oOrderItemsRep.updateOrderItem(updateRaw, id)
    if (!updated) return undefined
    return OrderItemMapper(updated)
  }

  public async deleteOrderItem(id: number): Promise<void> {
    await oOrderItemsRep.deleteOrderItem(id)
  }

  public async deleteOrderItemsByOrderId(orderId: number): Promise<void> {
    await oOrderItemsRep.deleteOrderItemsByOrderId(orderId)
  }

  // M√©todos utilitarios
  public async getTotalByOrderId(orderId: number): Promise<number> {
    return await oOrderItemsRep.getTotalByOrderId(orderId)
  }

  public async getItemCountByOrderId(orderId: number): Promise<number> {
    return await oOrderItemsRep.getItemCountByOrderId(orderId)
  }

  public async getQuantityTotalByOrderId(orderId: number): Promise<number> {
    return await oOrderItemsRep.getQuantityTotalByOrderId(orderId)
  }
}

const orderItemsModel = new OrderItemsModel()
export default orderItemsModel



üìÅ ARCHIVO: src/backend/order-item/OrderItem.mapper.ts
------------------------------------------------------------------------------------
import { type OrderItems as OrderItemsRaw } from '@/types/database'
import { type OrderItems as OrderItem } from '@/types/domain'

export const OrderItemMapper = (orderItemRaw: OrderItemsRaw): OrderItem => {
  return {
    id: orderItemRaw.id,
    orderId: orderItemRaw.order_id,
    variantId: orderItemRaw.variant_id,

    // Informaci√≥n del producto
    productName: orderItemRaw.product_name,
    variantSku: orderItemRaw.variant_sku,
    variantAttributes: orderItemRaw.variant_attributes
      ? typeof orderItemRaw.variant_attributes === 'string'
        ? JSON.parse(orderItemRaw.variant_attributes)
        : orderItemRaw.variant_attributes
      : null,

    // Precios y cantidades
    quantity: orderItemRaw.quantity,
    unitPrice: Number(orderItemRaw.unit_price),
    totalPrice: Number(orderItemRaw.total_price),
    discountAmount: Number(orderItemRaw.discount_amount)
  }
}

export const OrderItemsMapper = (
  orderItemsRaw: OrderItemsRaw[] | null
): OrderItem[] | undefined => {
  if (!orderItemsRaw || orderItemsRaw.length === 0) return undefined
  return orderItemsRaw.map(OrderItemMapper)
}

export const OrderItemToRawMapper = (
  orderItem: Omit<OrderItem, 'id'>
): Omit<OrderItemsRaw, 'id'> => {
  return {
    order_id: orderItem.orderId,
    variant_id: orderItem.variantId,

    // Informaci√≥n del producto
    product_name: orderItem.productName,
    variant_sku: orderItem.variantSku,
    variant_attributes: orderItem.variantAttributes
      ? JSON.stringify(orderItem.variantAttributes)
      : null,

    // Precios y cantidades
    quantity: orderItem.quantity,
    unit_price: orderItem.unitPrice,
    total_price: orderItem.totalPrice,
    discount_amount: orderItem.discountAmount
  }
}



üìÅ ARCHIVO: src/backend/order-item/index.ts
------------------------------------------------------------------------------------
export * from './OrderItem.mapper'
export { default } from './OrderItem.model'
export * from './OrderItem.repository'



üìÅ ARCHIVO: src/backend/payment-transaction/PaymentTransaction.repository.ts
------------------------------------------------------------------------------------
// üìÑ PaymentTransaction.repository.ts
import { executeQuery } from '@/lib/db'
import { type PaymentTransactions as PaymentTransactionRaw } from '@/types/database'

interface PaymentTransactionWithDetails extends PaymentTransactionRaw {
  payment_method_name?: string
  payment_method_code?: string
  order_number?: string
  customer_email?: string
  customer_name?: string
}

export class PaymentTransactionRepository {
  public async getTransactionById(
    id: number
  ): Promise<PaymentTransactionRaw | null> {
    const transactions = await executeQuery<PaymentTransactionRaw[]>({
      query: 'SELECT * FROM payment_transactions WHERE id = ?',
      values: [id]
    })

    if (transactions.length === 0) return null
    return transactions[0]
  }

  public async getTransactionsByOrderId(
    orderId: number
  ): Promise<PaymentTransactionRaw[] | null> {
    const transactions = await executeQuery<PaymentTransactionRaw[]>({
      query: `
        SELECT * FROM payment_transactions 
        WHERE order_id = ? 
        ORDER BY created_at DESC
      `,
      values: [orderId]
    })

    if (transactions.length === 0) return null
    return transactions
  }

  public async getTransactionByReference(
    referenceNumber: string
  ): Promise<PaymentTransactionRaw | null> {
    const transactions = await executeQuery<PaymentTransactionRaw[]>({
      query: 'SELECT * FROM payment_transactions WHERE reference_number = ?',
      values: [referenceNumber]
    })

    if (transactions.length === 0) return null
    return transactions[0]
  }

  public async getTransactionByTransactionId(
    transactionId: string
  ): Promise<PaymentTransactionRaw | null> {
    const transactions = await executeQuery<PaymentTransactionRaw[]>({
      query: 'SELECT * FROM payment_transactions WHERE transaction_id = ?',
      values: [transactionId]
    })

    if (transactions.length === 0) return null
    return transactions[0]
  }

  public async getTransactionsWithDetails(
    limit: number = 50,
    offset: number = 0
  ): Promise<PaymentTransactionWithDetails[] | null> {
    const transactions = await executeQuery<PaymentTransactionWithDetails[]>({
      query: `
        SELECT 
          pt.*,
          pm.name as payment_method_name,
          pm.code as payment_method_code,
          o.order_number,
          c.email as customer_email,
          CONCAT(c.name, ' ', c.lastname) as customer_name
        FROM payment_transactions pt
        LEFT JOIN payment_methods pm ON pt.payment_method_id = pm.id
        LEFT JOIN orders o ON pt.order_id = o.id
        LEFT JOIN customers c ON o.customer_id = c.id
        ORDER BY pt.created_at DESC
        LIMIT ? OFFSET ?
      `,
      values: [limit, offset]
    })

    if (transactions.length === 0) return null
    return transactions
  }

  public async getTransactionsByStatus(
    status: string
  ): Promise<PaymentTransactionRaw[] | null> {
    const transactions = await executeQuery<PaymentTransactionRaw[]>({
      query: `
        SELECT * FROM payment_transactions 
        WHERE status = ? 
        ORDER BY created_at DESC
      `,
      values: [status]
    })

    if (transactions.length === 0) return null
    return transactions
  }

  public async getTransactionsByPaymentMethod(
    paymentMethodId: number
  ): Promise<PaymentTransactionRaw[] | null> {
    const transactions = await executeQuery<PaymentTransactionRaw[]>({
      query: `
        SELECT * FROM payment_transactions 
        WHERE payment_method_id = ? 
        ORDER BY created_at DESC
      `,
      values: [paymentMethodId]
    })

    if (transactions.length === 0) return null
    return transactions
  }

  public async getTransactionsByDateRange(
    startDate: Date,
    endDate: Date
  ): Promise<PaymentTransactionRaw[] | null> {
    const transactions = await executeQuery<PaymentTransactionRaw[]>({
      query: `
        SELECT * FROM payment_transactions 
        WHERE created_at BETWEEN ? AND ? 
        ORDER BY created_at DESC
      `,
      values: [startDate, endDate]
    })

    if (transactions.length === 0) return null
    return transactions
  }

  public async getPendingTransactions(): Promise<
    PaymentTransactionRaw[] | null
  > {
    const transactions = await executeQuery<PaymentTransactionRaw[]>({
      query: `
        SELECT * FROM payment_transactions 
        WHERE status = 'pending' 
        ORDER BY created_at ASC
      `
    })

    if (transactions.length === 0) return null
    return transactions
  }

  public async getExpiredTransactions(): Promise<
    PaymentTransactionRaw[] | null
  > {
    const transactions = await executeQuery<PaymentTransactionRaw[]>({
      query: `
        SELECT * FROM payment_transactions 
        WHERE status = 'pending' 
        AND expires_at IS NOT NULL 
        AND expires_at < NOW()
        ORDER BY expires_at ASC
      `
    })

    if (transactions.length === 0) return null
    return transactions
  }

  public async createTransaction(
    transaction: Omit<PaymentTransactionRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<PaymentTransactionRaw | null> {
    const transactionData = {
      ...transaction,
      created_at: new Date(),
      updated_at: new Date()
    }

    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO payment_transactions SET ?',
      values: [transactionData]
    })

    return await this.getTransactionById(result.insertId)
  }

  public async updateTransaction(
    transactionData: Partial<Omit<PaymentTransactionRaw, 'id' | 'created_at'>>,
    id: number
  ): Promise<PaymentTransactionRaw | null> {
    const updateData = {
      ...transactionData,
      updated_at: new Date()
    }

    await executeQuery({
      query: 'UPDATE payment_transactions SET ? WHERE id = ?',
      values: [updateData, id]
    })

    return await this.getTransactionById(id)
  }

  public async updateTransactionStatus(
    id: number,
    status: string,
    gatewayResponse?: any,
    processedAt?: Date
  ): Promise<PaymentTransactionRaw | null> {
    const updateData: any = {
      status,
      updated_at: new Date()
    }

    if (gatewayResponse) {
      updateData.gateway_response = JSON.stringify(gatewayResponse)
    }

    if (processedAt) {
      updateData.processed_at = processedAt
    }

    await executeQuery({
      query: 'UPDATE payment_transactions SET ? WHERE id = ?',
      values: [updateData, id]
    })

    return await this.getTransactionById(id)
  }

  public async markAsCompleted(
    id: number,
    transactionId: string,
    gatewayResponse?: any
  ): Promise<PaymentTransactionRaw | null> {
    const updateData = {
      status: 'completed',
      transaction_id: transactionId,
      processed_at: new Date(),
      updated_at: new Date(),
      ...(gatewayResponse && {
        gateway_response: JSON.stringify(gatewayResponse)
      })
    }

    await executeQuery({
      query: 'UPDATE payment_transactions SET ? WHERE id = ?',
      values: [updateData, id]
    })

    return await this.getTransactionById(id)
  }

  public async markAsFailed(
    id: number,
    gatewayResponse?: any
  ): Promise<PaymentTransactionRaw | null> {
    const updateData = {
      status: 'failed',
      processed_at: new Date(),
      updated_at: new Date(),
      ...(gatewayResponse && {
        gateway_response: JSON.stringify(gatewayResponse)
      })
    }

    await executeQuery({
      query: 'UPDATE payment_transactions SET ? WHERE id = ?',
      values: [updateData, id]
    })

    return await this.getTransactionById(id)
  }

  public async markAsCancelled(
    id: number
  ): Promise<PaymentTransactionRaw | null> {
    const updateData = {
      status: 'cancelled',
      processed_at: new Date(),
      updated_at: new Date()
    }

    await executeQuery({
      query: 'UPDATE payment_transactions SET ? WHERE id = ?',
      values: [updateData, id]
    })

    return await this.getTransactionById(id)
  }

  public async getTransactionSummary(
    startDate?: Date,
    endDate?: Date
  ): Promise<any> {
    let query = `
      SELECT 
        COUNT(*) as total_transactions,
        COALESCE(SUM(amount), 0) as total_amount,
        COALESCE(SUM(processing_fee), 0) as total_fees,
        COALESCE(SUM(net_amount), 0) as net_amount,
        SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as successful_transactions,
        SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed_transactions,
        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending_transactions,
        COALESCE(AVG(amount), 0) as average_amount
      FROM payment_transactions
    `

    const values: any[] = []

    if (startDate && endDate) {
      query += ' WHERE created_at BETWEEN ? AND ?'
      values.push(startDate, endDate)
    }

    const result = await executeQuery<any[]>({ query, values })
    return result[0] || null
  }

  public async deleteTransaction(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM payment_transactions WHERE id = ?',
      values: [id]
    })
  }
}

const paymentTransactionRepository = new PaymentTransactionRepository()
export default paymentTransactionRepository



üìÅ ARCHIVO: src/backend/payment-transaction/PaymentTransaction.mapper.ts
------------------------------------------------------------------------------------
// üìÑ PaymentTransaction.mapper.ts
import { type PaymentTransactions as PaymentTransactionRaw } from '@/types/database'
import { type PaymentTransactions as PaymentTransaction } from '@/types/domain'

export const PaymentTransactionMapper = (
  data: PaymentTransactionRaw
): PaymentTransaction => {
  return {
    id: data.id,
    orderId: data.order_id,
    paymentMethodId: data.payment_method_id,
    amount: data.amount,
    netAmount: data.net_amount,
    processingFee: data.processing_fee,
    currency: data.currency,
    status: data.status,
    transactionId: data.transaction_id,
    referenceNumber: data.reference_number,
    paymentData: data.payment_data,
    gatewayResponse: data.gateway_response,
    processedAt: data.processed_at,
    expiresAt: data.expires_at,
    createdAt: data.created_at,
    updatedAt: data.updated_at
  }
}

export const PaymentTransactionsMapper = (
  data: PaymentTransactionRaw[] | null
): PaymentTransaction[] | undefined => {
  if (data === null) return undefined
  return data.map(PaymentTransactionMapper)
}



üìÅ ARCHIVO: src/backend/payment-transaction/PaymentTransaction.model.ts
------------------------------------------------------------------------------------
// üìÑ PaymentTransaction.model.ts
import { type PaymentTransactions as PaymentTransactionRaw } from '@/types/database'
import { type PaymentTransactions as PaymentTransaction } from '@/types/domain'

import oPaymentMethodRep from '@/backend/payment-method/PaymentMethod.repository'

import {
  type CreateTransactionData,
  type PaymentTransactionExtended,
  type TransactionSummary
} from './PaymentTransaction.interfaces'
import {
  PaymentTransactionMapper,
  PaymentTransactionsMapper
} from './PaymentTransaction.mapper'
import oPaymentTransactionRep from './PaymentTransaction.repository'

export class PaymentTransactionModel {
  public async getTransactionById(
    id: number
  ): Promise<PaymentTransaction | undefined> {
    const transactionRaw = await oPaymentTransactionRep.getTransactionById(id)
    if (!transactionRaw) return undefined
    return PaymentTransactionMapper(transactionRaw)
  }

  public async getTransactionsByOrderId(
    orderId: number
  ): Promise<PaymentTransaction[] | undefined> {
    const transactionsRaw =
      await oPaymentTransactionRep.getTransactionsByOrderId(orderId)
    return PaymentTransactionsMapper(transactionsRaw)
  }

  public async getTransactionByReference(
    referenceNumber: string
  ): Promise<PaymentTransaction | undefined> {
    const transactionRaw =
      await oPaymentTransactionRep.getTransactionByReference(referenceNumber)
    if (!transactionRaw) return undefined
    return PaymentTransactionMapper(transactionRaw)
  }

  public async getTransactionByTransactionId(
    transactionId: string
  ): Promise<PaymentTransaction | undefined> {
    const transactionRaw =
      await oPaymentTransactionRep.getTransactionByTransactionId(transactionId)
    if (!transactionRaw) return undefined
    return PaymentTransactionMapper(transactionRaw)
  }

  public async getTransactionsWithDetails(
    limit: number = 50,
    offset: number = 0
  ): Promise<PaymentTransactionExtended[] | undefined> {
    const transactionsRaw =
      await oPaymentTransactionRep.getTransactionsWithDetails(limit, offset)
    if (!transactionsRaw) return undefined

    return transactionsRaw.map((transaction) => ({
      ...PaymentTransactionMapper(transaction),
      paymentMethodName: transaction.payment_method_name,
      paymentMethodCode: transaction.payment_method_code,
      orderNumber: transaction.order_number,
      customerEmail: transaction.customer_email,
      customerName: transaction.customer_name
    }))
  }

  public async getTransactionsByStatus(
    status: string
  ): Promise<PaymentTransaction[] | undefined> {
    const transactionsRaw =
      await oPaymentTransactionRep.getTransactionsByStatus(status)
    return PaymentTransactionsMapper(transactionsRaw)
  }

  public async getTransactionsByPaymentMethod(
    paymentMethodId: number
  ): Promise<PaymentTransaction[] | undefined> {
    const transactionsRaw =
      await oPaymentTransactionRep.getTransactionsByPaymentMethod(
        paymentMethodId
      )
    return PaymentTransactionsMapper(transactionsRaw)
  }

  public async getTransactionsByDateRange(
    startDate: Date,
    endDate: Date
  ): Promise<PaymentTransaction[] | undefined> {
    const transactionsRaw =
      await oPaymentTransactionRep.getTransactionsByDateRange(
        startDate,
        endDate
      )
    return PaymentTransactionsMapper(transactionsRaw)
  }

  public async getPendingTransactions(): Promise<
    PaymentTransaction[] | undefined
  > {
    const transactionsRaw =
      await oPaymentTransactionRep.getPendingTransactions()
    return PaymentTransactionsMapper(transactionsRaw)
  }

  public async getExpiredTransactions(): Promise<
    PaymentTransaction[] | undefined
  > {
    const transactionsRaw =
      await oPaymentTransactionRep.getExpiredTransactions()
    return PaymentTransactionsMapper(transactionsRaw)
  }

  public async createTransaction(
    data: CreateTransactionData
  ): Promise<PaymentTransaction | undefined> {
    // Obtener m√©todo de pago para calcular comisiones
    const paymentMethod = await oPaymentMethodRep.getPaymentMethodById(
      data.paymentMethodId
    )
    if (!paymentMethod) throw new Error('M√©todo de pago no encontrado')

    // Calcular comisi√≥n
    let processingFee = 0
    if (
      paymentMethod.processing_fee_value &&
      paymentMethod.processing_fee_value > 0
    ) {
      if (paymentMethod.processing_fee_type === 'percentage') {
        processingFee = (data.amount * paymentMethod.processing_fee_value) / 100
      } else {
        processingFee = paymentMethod.processing_fee_value
      }
    }

    const netAmount = data.amount - processingFee

    // Generar n√∫mero de referencia si no se proporciona
    const referenceNumber =
      data.referenceNumber || this.generateReferenceNumber()

    const transactionData: Omit<
      PaymentTransactionRaw,
      'id' | 'created_at' | 'updated_at'
    > = {
      order_id: data.orderId,
      payment_method_id: data.paymentMethodId,
      amount: data.amount,
      net_amount: netAmount,
      processing_fee: processingFee,
      currency: data.currency || 'PEN',
      status: 'pending',
      reference_number: referenceNumber,
      payment_data: data.paymentData ? JSON.stringify(data.paymentData) : null,
      expires_at: data.expiresAt || null,
      transaction_id: null,
      gateway_response: null,
      processed_at: null
    }

    const created =
      await oPaymentTransactionRep.createTransaction(transactionData)
    if (!created) return undefined
    return PaymentTransactionMapper(created)
  }

  public async updateTransactionStatus(
    id: number,
    status: string,
    gatewayResponse?: any,
    processedAt?: Date
  ): Promise<PaymentTransaction | undefined> {
    const updated = await oPaymentTransactionRep.updateTransactionStatus(
      id,
      status,
      gatewayResponse,
      processedAt || new Date()
    )
    if (!updated) return undefined
    return PaymentTransactionMapper(updated)
  }

  public async markAsCompleted(
    id: number,
    transactionId: string,
    gatewayResponse?: any
  ): Promise<PaymentTransaction | undefined> {
    const updated = await oPaymentTransactionRep.markAsCompleted(
      id,
      transactionId,
      gatewayResponse
    )
    if (!updated) return undefined
    return PaymentTransactionMapper(updated)
  }

  public async markAsFailed(
    id: number,
    gatewayResponse?: any
  ): Promise<PaymentTransaction | undefined> {
    const updated = await oPaymentTransactionRep.markAsFailed(
      id,
      gatewayResponse
    )
    if (!updated) return undefined
    return PaymentTransactionMapper(updated)
  }

  public async markAsCancelled(
    id: number
  ): Promise<PaymentTransaction | undefined> {
    const updated = await oPaymentTransactionRep.markAsCancelled(id)
    if (!updated) return undefined
    return PaymentTransactionMapper(updated)
  }

  public async getTransactionSummary(
    startDate?: Date,
    endDate?: Date
  ): Promise<TransactionSummary | undefined> {
    const summary = await oPaymentTransactionRep.getTransactionSummary(
      startDate,
      endDate
    )
    if (!summary) return undefined

    return {
      totalTransactions: summary.total_transactions || 0,
      totalAmount: summary.total_amount || 0,
      totalFees: summary.total_fees || 0,
      netAmount: summary.net_amount || 0,
      successfulTransactions: summary.successful_transactions || 0,
      failedTransactions: summary.failed_transactions || 0,
      pendingTransactions: summary.pending_transactions || 0,
      averageAmount: summary.average_amount || 0
    }
  }

  public async deleteTransaction(id: number): Promise<void> {
    await oPaymentTransactionRep.deleteTransaction(id)
  }

  // M√©todo para procesar transacciones expiradas
  public async processExpiredTransactions(): Promise<
    PaymentTransaction[] | undefined
  > {
    const expiredTransactions = await this.getExpiredTransactions()
    if (!expiredTransactions) return undefined

    const processedTransactions: PaymentTransaction[] = []

    for (const transaction of expiredTransactions) {
      const updated = await this.markAsFailed(transaction.id, {
        reason: 'Transaction expired'
      })
      if (updated) {
        processedTransactions.push(updated)
      }
    }

    return processedTransactions.length > 0 ? processedTransactions : undefined
  }

  // M√©todo para generar n√∫mero de referencia √∫nico
  private generateReferenceNumber(): string {
    const timestamp = Date.now().toString()
    const random = Math.random().toString(36).substring(2, 8).toUpperCase()
    return `TXN-${timestamp}-${random}`
  }

  // M√©todo para validar si una transacci√≥n est√° expirada
  public isTransactionExpired(transaction: PaymentTransaction): boolean {
    if (!transaction.expiresAt) return false
    return new Date() > new Date(transaction.expiresAt)
  }

  // M√©todo para obtener el tiempo restante de una transacci√≥n
  public getTimeRemaining(transaction: PaymentTransaction): number | null {
    if (!transaction.expiresAt) return null
    const now = new Date().getTime()
    const expiry = new Date(transaction.expiresAt).getTime()
    const remaining = expiry - now
    return remaining > 0 ? remaining : 0
  }

  // M√©todo para verificar si una transacci√≥n puede ser cancelada
  public canBeCancelled(transaction: PaymentTransaction): boolean {
    return (
      transaction.status === 'pending' || transaction.status === 'processing'
    )
  }

  // M√©todo para verificar si una transacci√≥n puede ser reintentada
  public canBeRetried(transaction: PaymentTransaction): boolean {
    return (
      transaction.status === 'failed' && !this.isTransactionExpired(transaction)
    )
  }
}

const paymentTransactionModel = new PaymentTransactionModel()
export default paymentTransactionModel



üìÅ ARCHIVO: src/backend/payment-transaction/index.ts
------------------------------------------------------------------------------------
export * from './PaymentTransaction.interfaces'
export * from './PaymentTransaction.mapper'
export { default } from './PaymentTransaction.model'
export * from './PaymentTransaction.repository'



üìÅ ARCHIVO: src/backend/payment-transaction/PaymentTransaction.interfaces.ts
------------------------------------------------------------------------------------
// üìÑ PaymentTransaction.interfaces.ts
import { type PaymentTransactions as PaymentTransaction } from '@/types/domain'

export interface PaymentTransactionExtended extends PaymentTransaction {
  paymentMethodName?: string
  paymentMethodCode?: string
  orderNumber?: string
  customerEmail?: string
  customerName?: string
}

export interface TransactionSummary {
  totalTransactions: number
  totalAmount: number
  totalFees: number
  netAmount: number
  successfulTransactions: number
  failedTransactions: number
  pendingTransactions: number
  averageAmount: number
}

export interface TransactionFilter {
  status?: string[]
  paymentMethodId?: number
  orderId?: number
  dateFrom?: Date
  dateTo?: Date
  amountMin?: number
  amountMax?: number
}

export interface CreateTransactionData {
  orderId: number
  paymentMethodId: number
  amount: number
  currency?: string
  paymentData?: any
  referenceNumber?: string
  expiresAt?: Date
}



üìÅ ARCHIVO: src/backend/variant-image/VariantImage.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type VariantImages as VariantImagesRaw } from '@/types/database'

export class VariantImageRepository {
  public async getVariantImages(
    variantId: number
  ): Promise<VariantImagesRaw[] | null> {
    const images = await executeQuery<VariantImagesRaw[]>({
      query: `
          SELECT *
          FROM variant_images 
          WHERE variant_id = ?
          ORDER BY display_order ASC, is_primary DESC
        `,
      values: [variantId]
    })

    if (images.length === 0) return null
    return images
  }
}

const variantImageRepository = new VariantImageRepository()
export default variantImageRepository



üìÅ ARCHIVO: src/backend/variant-image/index.ts
------------------------------------------------------------------------------------
export * from './VariantImage.mapper'
export { default } from './VariantImage.model'
export * from './VariantImage.repository'



üìÅ ARCHIVO: src/backend/variant-image/VariantImage.model.ts
------------------------------------------------------------------------------------
import { type VariantImages as VariantImage } from '@/types/domain'
import { VariantImagesMapper } from './VariantImage.mapper'
import oVariantImage from './VariantImage.repository'

export class VariantImageModel {
  public async getVariantImages(
    variantId: number
  ): Promise<VariantImage[] | undefined> {
    const variantRaw = await oVariantImage.getVariantImages(variantId)
    if (!variantRaw) return undefined
    return VariantImagesMapper(variantRaw)
  }
}

const variantImageModel = new VariantImageModel()
export default variantImageModel



üìÅ ARCHIVO: src/backend/variant-image/VariantImage.mapper.ts
------------------------------------------------------------------------------------
import { type VariantImages as VariantImageRaw } from '@/types/database'
import { type VariantImages as VariantImage } from '@/types/domain'

export const VariantImageMapper = (img: VariantImageRaw): VariantImage => {
  return {
    id: img.id,
    variantId: img.variant_id,
    imageUrlThumb: img.image_url_thumb,
    imageUrlNormal: img.image_url_normal,
    imageUrlZoom: img.image_url_zoom,
    imageType: img.image_type,
    isPrimary: img.is_primary,
    altText: img.alt_text,
    displayOrder: img.display_order,
    createdAt: img.created_at,
    updatedAt: img.updated_at,
    productVariants: undefined
  }
}

export const VariantImagesMapper = (
  data: VariantImageRaw[] | null
): VariantImage[] | undefined => {
  if (data === null) return undefined
  return data.map(VariantImageMapper)
}



üìÅ ARCHIVO: src/backend/attribute-option-image/AttributeOptionImage.model.ts
------------------------------------------------------------------------------------
import { type AttributeOptionImages as AttributeOptionImageRaw } from '@/types/database'
import { type AttributeOptionImages as AttributeOptionImage } from '@/types/domain'

// me
import {
  AttributeOptionImageMapper,
  AttributeOptionImagesMapper
} from './AttributeOptionImage.mapper'
import oAttributeOptionImageRep from './AttributeOptionImage.repository'

export class AttributeOptionImageModel {
  public async getAttributeOptionImages(
    attributeOptionId: number
  ): Promise<AttributeOptionImage[] | undefined> {
    const imagesRaw =
      await oAttributeOptionImageRep.getAttributeOptionImages(attributeOptionId)
    return AttributeOptionImagesMapper(imagesRaw)
  }

  public async getAttributeOptionImageById(
    id: number
  ): Promise<AttributeOptionImage | undefined> {
    const imageRaw =
      await oAttributeOptionImageRep.getAttributeOptionImageById(id)
    if (!imageRaw) return undefined
    return AttributeOptionImageMapper(imageRaw)
  }

  public async getAttributeOptionImagesByOptionIds(
    attributeOptionIds: number[]
  ): Promise<Map<number, AttributeOptionImage[]>> {
    const imagesRaw =
      await oAttributeOptionImageRep.getAttributeOptionImagesByOptionIds(
        attributeOptionIds
      )

    if (!imagesRaw) return new Map()

    // Agrupar images por attribute_option_id
    const imagesByOptionId = new Map<number, AttributeOptionImage[]>()

    for (const imageRaw of imagesRaw) {
      const image = AttributeOptionImageMapper(imageRaw)
      const optionId = image.attributeOptionId

      if (!imagesByOptionId.has(optionId)) {
        imagesByOptionId.set(optionId, [])
      }

      imagesByOptionId.get(optionId)!.push(image)
    }

    return imagesByOptionId
  }

  public async createAttributeOptionImage(
    imageData: Omit<AttributeOptionImageRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<AttributeOptionImage | undefined> {
    const created =
      await oAttributeOptionImageRep.createAttributeOptionImage(imageData)
    if (!created) return undefined
    return AttributeOptionImageMapper(created)
  }

  public async updateAttributeOptionImage(
    imageData: Partial<
      Omit<AttributeOptionImageRaw, 'id' | 'created_at' | 'updated_at'>
    >,
    id: number
  ): Promise<AttributeOptionImage | undefined> {
    const updated = await oAttributeOptionImageRep.updateAttributeOptionImage(
      imageData,
      id
    )
    if (!updated) return undefined
    return AttributeOptionImageMapper(updated)
  }

  public async deleteAttributeOptionImage(id: number): Promise<void> {
    await oAttributeOptionImageRep.deleteAttributeOptionImage(id)
  }

  public async deleteAttributeOptionImagesByOptionId(
    attributeOptionId: number
  ): Promise<void> {
    await oAttributeOptionImageRep.deleteAttributeOptionImagesByOptionId(
      attributeOptionId
    )
  }
}

const attributeOptionImageModel = new AttributeOptionImageModel()
export default attributeOptionImageModel



üìÅ ARCHIVO: src/backend/attribute-option-image/AttributeOptionImage.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type AttributeOptionImages as AttributeOptionImageRaw } from '@/types/database'

export class AttributeOptionImageRepository {
  public async getAttributeOptionImages(
    attributeOptionId: number
  ): Promise<AttributeOptionImageRaw[] | null> {
    const images = await executeQuery<AttributeOptionImageRaw[]>({
      query: `
        SELECT * FROM attribute_option_images 
        WHERE attribute_option_id = ? 
        ORDER BY display_order ASC, id ASC
      `,
      values: [attributeOptionId]
    })

    if (images.length === 0) return null
    return images
  }

  public async getAttributeOptionImageById(
    id: number
  ): Promise<AttributeOptionImageRaw | null> {
    const images = await executeQuery<AttributeOptionImageRaw[]>({
      query: 'SELECT * FROM attribute_option_images WHERE id = ?',
      values: [id]
    })

    if (images.length === 0) return null
    return images[0]
  }

  public async getAttributeOptionImagesByOptionIds(
    attributeOptionIds: number[]
  ): Promise<AttributeOptionImageRaw[] | null> {
    if (attributeOptionIds.length === 0) return null

    const placeholders = attributeOptionIds.map(() => '?').join(',')
    const images = await executeQuery<AttributeOptionImageRaw[]>({
      query: `
        SELECT * FROM attribute_option_images 
        WHERE attribute_option_id IN (${placeholders})
        ORDER BY attribute_option_id, display_order ASC, id ASC
      `,
      values: attributeOptionIds
    })

    if (images.length === 0) return null
    return images
  }

  public async createAttributeOptionImage(
    image: Omit<AttributeOptionImageRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<AttributeOptionImageRaw | null> {
    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO attribute_option_images SET ?',
      values: [image]
    })

    return await this.getAttributeOptionImageById(result.insertId)
  }

  public async updateAttributeOptionImage(
    imageData: Partial<
      Omit<AttributeOptionImageRaw, 'id' | 'created_at' | 'updated_at'>
    >,
    id: number
  ): Promise<AttributeOptionImageRaw | null> {
    await executeQuery({
      query: 'UPDATE attribute_option_images SET ? WHERE id = ?',
      values: [imageData, id]
    })

    return await this.getAttributeOptionImageById(id)
  }

  public async deleteAttributeOptionImage(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM attribute_option_images WHERE id = ?',
      values: [id]
    })
  }

  public async deleteAttributeOptionImagesByOptionId(
    attributeOptionId: number
  ): Promise<void> {
    await executeQuery({
      query:
        'DELETE FROM attribute_option_images WHERE attribute_option_id = ?',
      values: [attributeOptionId]
    })
  }
}

const attributeOptionImageRepository = new AttributeOptionImageRepository()
export default attributeOptionImageRepository



üìÅ ARCHIVO: src/backend/attribute-option-image/AttributeOptionImage.mapper.ts
------------------------------------------------------------------------------------
import { type AttributeOptionImages as AttributeOptionImageRaw } from '@/types/database'
import { type AttributeOptionImages as AttributeOptionImage } from '@/types/domain'

export const AttributeOptionImageMapper = (
  data: AttributeOptionImageRaw
): AttributeOptionImage => {
  return {
    id: data.id,
    attributeOptionId: data.attribute_option_id,
    imageType: data.image_type,
    imageUrlThumb: data.image_url_thumb,
    imageUrlNormal: data.image_url_normal ?? undefined,
    imageUrlZoom: data.image_url_zoom ?? undefined,
    altText: data.alt_text ?? undefined,
    displayOrder: data.display_order ?? undefined,
    createdAt: data.created_at,
    updatedAt: data.updated_at,
    isPrimary: data.is_primary,
    attributeOption: undefined // Se llena en el modelo si es necesario
  }
}

export const AttributeOptionImagesMapper = (
  data: AttributeOptionImageRaw[] | null
): AttributeOptionImage[] | undefined => {
  if (data === null) return undefined
  return data.map(AttributeOptionImageMapper)
}



üìÅ ARCHIVO: src/backend/attribute-option-image/index.ts
------------------------------------------------------------------------------------
export * from './AttributeOptionImage.mapper'
export { default } from './AttributeOptionImage.model'
export * from './AttributeOptionImage.repository'



üìÅ ARCHIVO: src/backend/customer/Customer.mapper.ts
------------------------------------------------------------------------------------
import { type Customers as CustomerRaw } from '@/types/database'
import { type Customers as Customer } from '@/types/domain'

export const CustomerMapper = (data: CustomerRaw): Customer => {
  return {
    id: data.id,
    name: data.name,
    lastname: data.lastname,
    username: data.username,
    email: data.email,
    password: data.password,
    photo: data.photo,
    isActive: data.is_active,
    addressId: data.address_id,
    createdAt: data.created_at,
    updatedAt: data.updated_at,
    customersAddresses: undefined,
    variantRatings: undefined
  }
}

export const CustomersMapper = (
  data: CustomerRaw[] | null
): Customer[] | undefined => {
  if (data === null) return undefined
  return data.map(CustomerMapper)
}



üìÅ ARCHIVO: src/backend/customer/Customer.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type Customers as CustomerRaw } from '@/types/database'

export class CustomerRepository {
  public async getCustomerByEmail(email: string): Promise<CustomerRaw | null> {
    const customers = await executeQuery<CustomerRaw[]>({
      query: 'SELECT * FROM customers WHERE email = ?',
      values: [email]
    })

    if (customers.length === 0) return null
    return customers[0]
  }

  public async getCustomers(): Promise<CustomerRaw[] | null> {
    const customers = await executeQuery<CustomerRaw[]>({
      query: 'SELECT * FROM customers'
    })

    if (customers.length === 0) return null
    return customers
  }

  public async getCustomer(id: number): Promise<CustomerRaw | null> {
    const customers = await executeQuery<CustomerRaw[]>({
      query: 'SELECT * FROM customers WHERE id = ?',
      values: [id]
    })

    if (customers.length === 0) return null
    return customers[0]
  }

  public async createCustomer(
    customer: Omit<CustomerRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<CustomerRaw | null> {
    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO customers SET ?',
      values: [customer]
    })

    return await this.getCustomer(result.insertId)
  }

  public async updateCustomer(
    customerData: Partial<CustomerRaw>,
    id: number
  ): Promise<CustomerRaw | null> {
    await executeQuery({
      query: 'UPDATE customers SET ? WHERE id=?',
      values: [customerData, id]
    })

    return await this.getCustomer(id)
  }

  public async deleteCustomer(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM customers WHERE id=?',
      values: [id]
    })
  }
}

const customerRepository = new CustomerRepository()
export default customerRepository



üìÅ ARCHIVO: src/backend/customer/Customer.model.ts
------------------------------------------------------------------------------------
import { type Customers as CustomerRaw } from '@/types/database'
import { type Customers as Customer } from '@/types/domain'

// me
import { CustomerMapper, CustomersMapper } from './Customer.mapper'
import oCustomerRep from './Customer.repository'

export class CustomerModel {
  public async getCustomerByEmail(
    email: string
  ): Promise<Customer | undefined> {
    const customerRaw = await oCustomerRep.getCustomerByEmail(email)
    if (!customerRaw) return undefined
    return CustomerMapper(customerRaw)
  }

  public async getCustomers(): Promise<Customer[] | undefined> {
    const customersRaw = await oCustomerRep.getCustomers()
    return CustomersMapper(customersRaw)
  }

  public async getCustomer(id: number): Promise<Customer | undefined> {
    const customerRaw = await oCustomerRep.getCustomer(id)
    if (!customerRaw) return undefined
    return CustomerMapper(customerRaw)
  }

  public async createCustomer(
    customerData: Omit<Customer, 'id' | 'dni' | 'phone' | 'photo'>
  ): Promise<Customer | undefined> {
    const created = await oCustomerRep.createCustomer(customerData)
    if (!created) return undefined
    return CustomerMapper(created)
  }

  public async updateCustomer(
    customerData: Partial<CustomerRaw>,
    id: number
  ): Promise<Customer | undefined> {
    const updated = await oCustomerRep.updateCustomer(customerData, id)
    if (!updated) return undefined
    return CustomerMapper(updated)
  }

  public async deleteCustomer(id: number): Promise<void> {
    await oCustomerRep.deleteCustomer(id)
  }
}

const customerModel = new CustomerModel()
export default customerModel



üìÅ ARCHIVO: src/backend/customer/index.ts
------------------------------------------------------------------------------------
export * from './Customer.mapper'
export { default } from './Customer.model'
export * from './Customer.repository'



üìÅ ARCHIVO: src/backend/shipping-method/ShippingMethod.interfaces.ts
------------------------------------------------------------------------------------
// üìÑ ShippingMethod.interfaces.ts
import { type ShippingMethods as ShippingMethod } from '@/types/domain'

export interface ShippingMethodWithZones extends ShippingMethod {
  zones?: ShippingZoneMethod[]
}

export interface ShippingZoneMethod {
  id: number
  shippingZoneId: number
  cost: number
  estimatedDaysMin?: number
  estimatedDaysMax?: number
  freeShippingThreshold?: number
  isActive?: number
  zoneName: string
  districts: string[]
}



üìÅ ARCHIVO: src/backend/shipping-method/ShippingMethod.mapper.ts
------------------------------------------------------------------------------------
// üìÑ ShippingMethod.mapper.ts
import { type ShippingMethods as ShippingMethodRaw } from '@/types/database'
import { type ShippingMethods as ShippingMethod } from '@/types/domain'

export const ShippingMethodMapper = (
  data: ShippingMethodRaw
): ShippingMethod => {
  return {
    id: data.id,
    name: data.name,
    description: data.description,
    baseCost: data.base_cost,
    estimatedDaysMin: data.estimated_days_min,
    estimatedDaysMax: data.estimated_days_max,
    freeShippingThreshold: data.free_shipping_threshold,
    isActive: data.is_active,
    displayOrder: data.display_order,
    createdAt: data.created_at,
    updatedAt: data.updated_at
  }
}

export const ShippingMethodsMapper = (
  data: ShippingMethodRaw[] | null
): ShippingMethod[] | undefined => {
  if (data === null) return undefined
  return data.map(ShippingMethodMapper)
}



üìÅ ARCHIVO: src/backend/shipping-method/index.ts
------------------------------------------------------------------------------------
// üìÑ index.ts
export * from './ShippingMethod.interfaces'
export * from './ShippingMethod.mapper'
export { default } from './ShippingMethod.model'
export * from './ShippingMethod.repository'



üìÅ ARCHIVO: src/backend/shipping-method/ShippingMethod.model.ts
------------------------------------------------------------------------------------
// üìÑ ShippingMethod.model.ts
import { type ShippingMethods as ShippingMethodRaw } from '@/types/database'
import { type ShippingMethods as ShippingMethod } from '@/types/domain'

import oShippingZoneMethodRep from '@/backend/shipping-zone-method/ShippingZoneMethod.repository'
import { type ShippingMethodWithZones } from './ShippingMethod.interfaces'

import {
  ShippingMethodMapper,
  ShippingMethodsMapper
} from './ShippingMethod.mapper'
import oShippingMethodRep from './ShippingMethod.repository'

export class ShippingMethodModel {
  public async getShippingMethods(): Promise<ShippingMethod[] | undefined> {
    const methodsRaw = await oShippingMethodRep.getShippingMethods()
    return ShippingMethodsMapper(methodsRaw)
  }

  public async getShippingMethodById(
    id: number
  ): Promise<ShippingMethod | undefined> {
    const methodRaw = await oShippingMethodRep.getShippingMethodById(id)
    if (!methodRaw) return undefined
    return ShippingMethodMapper(methodRaw)
  }

  public async getShippingMethodsByZoneId(
    zoneId: number
  ): Promise<ShippingMethod[] | undefined> {
    const methodsRaw =
      await oShippingMethodRep.getShippingMethodsByZoneId(zoneId)
    return ShippingMethodsMapper(methodsRaw)
  }

  public async getShippingMethodsWithZones(): Promise<
    ShippingMethodWithZones[] | undefined
  > {
    const methods = await this.getShippingMethods()
    if (!methods) return undefined

    const methodsWithZones: ShippingMethodWithZones[] = []

    for (const method of methods) {
      const zones =
        await oShippingZoneMethodRep.getZoneMethodsByShippingMethodId(method.id)
      methodsWithZones.push({
        ...method,
        zones: zones || []
      })
    }

    return methodsWithZones
  }

  public async createShippingMethod(
    methodData: Omit<ShippingMethodRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<ShippingMethod | undefined> {
    const created = await oShippingMethodRep.createShippingMethod(methodData)
    if (!created) return undefined
    return ShippingMethodMapper(created)
  }

  public async updateShippingMethod(
    methodData: Partial<Omit<ShippingMethodRaw, 'id' | 'created_at'>>,
    id: number
  ): Promise<ShippingMethod | undefined> {
    const updated = await oShippingMethodRep.updateShippingMethod(
      methodData,
      id
    )
    if (!updated) return undefined
    return ShippingMethodMapper(updated)
  }

  public async deleteShippingMethod(id: number): Promise<void> {
    await oShippingMethodRep.deleteShippingMethod(id)
  }

  public async activateShippingMethod(id: number): Promise<void> {
    await oShippingMethodRep.activateShippingMethod(id)
  }

  public async deactivateShippingMethod(id: number): Promise<void> {
    await oShippingMethodRep.deactivateShippingMethod(id)
  }

  // M√©todo para calcular el costo de env√≠o para una zona espec√≠fica
  public async calculateShippingCost(
    methodId: number,
    zoneId: number,
    orderValue: number
  ): Promise<{ cost: number, isFree: boolean } | undefined> {
    const zoneMethod = await oShippingZoneMethodRep.getZoneMethodByIds(
      methodId,
      zoneId
    )
    if (!zoneMethod) return undefined

    const threshold = zoneMethod.free_shipping_threshold || null
    const isFree = threshold !== null && orderValue >= threshold

    return {
      cost: isFree ? 0 : zoneMethod.cost,
      isFree
    }
  }
}

const shippingMethodModel = new ShippingMethodModel()
export default shippingMethodModel



üìÅ ARCHIVO: src/backend/shipping-method/ShippingMethod.repository.ts
------------------------------------------------------------------------------------
import { executeQuery } from '@/lib/db'
import { type ShippingMethods as ShippingMethodRaw } from '@/types/database'

export class ShippingMethodRepository {
  public async getShippingMethods(): Promise<ShippingMethodRaw[] | null> {
    const methods = await executeQuery<ShippingMethodRaw[]>({
      query: `
        SELECT * FROM shipping_methods 
        WHERE is_active = 1 
        ORDER BY display_order ASC, name ASC
      `
    })

    if (methods.length === 0) return null
    return methods
  }

  public async getShippingMethodById(
    id: number
  ): Promise<ShippingMethodRaw | null> {
    const methods = await executeQuery<ShippingMethodRaw[]>({
      query: 'SELECT * FROM shipping_methods WHERE id = ?',
      values: [id]
    })

    if (methods.length === 0) return null
    return methods[0]
  }

  public async getShippingMethodsByZoneId(
    zoneId: number
  ): Promise<ShippingMethodRaw[] | null> {
    const methods = await executeQuery<ShippingMethodRaw[]>({
      query: `
        SELECT sm.* 
        FROM shipping_methods sm
        JOIN shipping_zone_methods szm ON sm.id = szm.shipping_method_id
        WHERE szm.shipping_zone_id = ? 
        AND sm.is_active = 1 
        AND szm.is_active = 1
        ORDER BY sm.display_order ASC, sm.name ASC
      `,
      values: [zoneId]
    })

    if (methods.length === 0) return null
    return methods
  }

  public async createShippingMethod(
    method: Omit<ShippingMethodRaw, 'id' | 'created_at' | 'updated_at'>
  ): Promise<ShippingMethodRaw | null> {
    const methodData = {
      ...method,
      created_at: new Date(),
      updated_at: new Date()
    }

    const result = await executeQuery<{ insertId: number }>({
      query: 'INSERT INTO shipping_methods SET ?',
      values: [methodData]
    })

    return await this.getShippingMethodById(result.insertId)
  }

  public async updateShippingMethod(
    methodData: Partial<Omit<ShippingMethodRaw, 'id' | 'created_at'>>,
    id: number
  ): Promise<ShippingMethodRaw | null> {
    const updateData = {
      ...methodData,
      updated_at: new Date()
    }

    await executeQuery({
      query: 'UPDATE shipping_methods SET ? WHERE id = ?',
      values: [updateData, id]
    })

    return await this.getShippingMethodById(id)
  }

  public async deleteShippingMethod(id: number): Promise<void> {
    await executeQuery({
      query: 'DELETE FROM shipping_methods WHERE id = ?',
      values: [id]
    })
  }

  public async activateShippingMethod(id: number): Promise<void> {
    await executeQuery({
      query:
        'UPDATE shipping_methods SET is_active = 1, updated_at = ? WHERE id = ?',
      values: [new Date(), id]
    })
  }

  public async deactivateShippingMethod(id: number): Promise<void> {
    await executeQuery({
      query:
        'UPDATE shipping_methods SET is_active = 0, updated_at = ? WHERE id = ?',
      values: [new Date(), id]
    })
  }
}

const shippingMethodRepository = new ShippingMethodRepository()
export default shippingMethodRepository



üìÅ ARCHIVO: src/shared.ts
------------------------------------------------------------------------------------
import { type AttributeOptionImages, type VariantImages } from '@/types/domain'

export enum SEARCH_SORT {
  PRICE_ASC = 'price_asc',
  PRICE_DESC = 'price_desc',
  NAME_ASC = 'name_asc',
  NAME_DESC = 'name_desc',
  NEWEST = 'newest'
}

export type FILTER_SORT =
  | SEARCH_SORT.PRICE_ASC
  | SEARCH_SORT.PRICE_DESC
  | SEARCH_SORT.NAME_ASC
  | SEARCH_SORT.NAME_DESC
  | SEARCH_SORT.NEWEST

export interface SearchParams {
  q?: string
  category?: string
  brand?: string
  minPrice?: string
  maxPrice?: string
  sort?: string
  page?: string
  [key: string]: string | string[] | undefined
}

type ItemImageMix = AttributeOptionImages | VariantImages

export type ItemImageOmit = Omit<
  ItemImageMix,
  'attributeOptionId' | 'createdAt' | 'updatedAt' | 'displayOrder'
>

export interface ItemImage extends ItemImageOmit {
  displayOrder: number
}



üìÅ ARCHIVO: src/components/ui/CartButton.tsx
------------------------------------------------------------------------------------
'use client'
import { useCartContext } from '@/providers/cart'
import { ShoppingCart } from 'lucide-react'
import { useRouter } from 'next/navigation'
import React from 'react'

const CartButton: React.FC = () => {
  const { totalItems } = useCartContext() // üëà Usar useCart directamente
  const router = useRouter()
  const handleGoToPageCart = () => {
    router.push('/cart')
  }

  return (
    <button
      className="relative flex flex-col items-center"
      onClick={handleGoToPageCart}
      aria-label="Abrir carrito"
    >
      <ShoppingCart className="h-6 w-6" />
      <span className="mt-1 text-xs">Carrito</span>
      {totalItems > 0 && (
        <span className="absolute -right-2 -top-2 flex h-5 w-5 items-center justify-center rounded-full bg-primary text-xs text-white">
          {totalItems}
        </span>
      )}
    </button>
  )
}

export default CartButton



üìÅ ARCHIVO: src/components/ui/InputField.tsx
------------------------------------------------------------------------------------
// components/InputField.tsx
'use client'

import { Input } from '@/components/ui/Input'
import { Label } from '@/components/ui/Label'
import { type InputHTMLAttributes, type JSX } from 'react'

interface InputFieldProps extends InputHTMLAttributes<HTMLInputElement> {
  id: string
  label: string
  error?: string
  containerClassName?: string
}

export const InputField = ({
  id,
  label,
  error,
  containerClassName = '',
  ...inputProps
}: InputFieldProps): JSX.Element => {
  return (
    <div className={`space-y-2 ${containerClassName}`}>
      <Label htmlFor={id}>{label}</Label>
      <Input
        id={id}
        className={`${error != null ? 'border-red-500 focus:border-red-500 focus:ring-red-500' : 'border-gray-300 focus:border-blue-500 focus:ring-blue-500'} focus:ring-2`}
        {...inputProps}
      />
      {error != null && (
        <p className="flex items-center gap-1 text-sm text-red-600">
          <span className="h-1 w-1 rounded-full bg-red-600"></span>
          {error}
        </p>
      )}
    </div>
  )
}



üìÅ ARCHIVO: src/components/ui/Card.tsx
------------------------------------------------------------------------------------
import { cn } from '@/lib/utils'
import { forwardRef } from 'react'

const Card = forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('bg-card text-card-foreground border shadow-sm', className)}
      {...props}
    />
  )
)
Card.displayName = 'Card'

const CardHeader = forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex flex-col space-y-1.5 p-6', className)}
    {...props}
  />
))
CardHeader.displayName = 'CardHeader'

const CardTitle = forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      'text-2xl font-semibold leading-none tracking-tight',
      className
    )}
    {...props}
  />
))
CardTitle.displayName = 'CardTitle'

const CardContent = forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
))
CardContent.displayName = 'CardContent'

export { Card, CardContent, CardHeader, CardTitle }



üìÅ ARCHIVO: src/components/ui/ClientAuthButton.tsx
------------------------------------------------------------------------------------
'use client'
import { useAuthModal } from '@/providers/auth-modal'
import { User } from 'lucide-react'
import { useSession } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import React, { useEffect, useState } from 'react'
import UserMenu from './UserMenu'

interface ClientAuthButtonProps {
  initialIsAuthenticated: boolean
  initialUserName: string
  initialUserEmail: string
  initialUserId: string
}

const ClientAuthButton: React.FC<ClientAuthButtonProps> = ({
  initialIsAuthenticated,
  initialUserName,
  initialUserEmail,
  initialUserId
}) => {
  const { data: session, status } = useSession()
  const router = useRouter()
  const { openLogin } = useAuthModal() // üëà Usar el provider centralizado
  const [isUserMenuOpen, setIsUserMenuOpen] = useState(false)

  // üëà ESTADO H√çBRIDO: Usar valores iniciales del servidor hasta que el cliente se hidrate
  const [authState, setAuthState] = useState({
    isAuthenticated: initialIsAuthenticated,
    userName: initialUserName,
    userEmail: initialUserEmail,
    userId: initialUserId
  })

  // üëà ACTUALIZAR SOLO CUANDO LA SESI√ìN CAMBIE (no durante hydration)
  useEffect(() => {
    if (status === 'loading') return // No hacer nada mientras carga

    // Solo actualizar si hay un cambio real en la autenticaci√≥n
    const newIsAuthenticated = !!session

    if (newIsAuthenticated !== authState.isAuthenticated) {
      console.log('üîÑ Auth state changed:', {
        from: authState.isAuthenticated,
        to: newIsAuthenticated
      })

      setAuthState({
        isAuthenticated: newIsAuthenticated,
        userName: session?.user?.name || '',
        userEmail: session?.user?.email || '',
        userId: session?.user?.id || ''
      })
    }
  }, [session, status]) // No incluir authState para evitar loops

  // Crear objeto de sesi√≥n para UserMenu
  const sessionData = authState.isAuthenticated
    ? {
        user: {
          id: authState.userId,
          name: authState.userName,
          email: authState.userEmail
        },
        expires: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()
      }
    : null

  const handleAuthClick = () => {
    if (authState.isAuthenticated) {
      console.log('üë§ Opening user menu')
      // setIsUserMenuOpen(true);
      router.push('/account')
    } else {
      console.log('üîê User not authenticated, opening login modal')
      // üëà USAR EL PROVIDER CENTRALIZADO - Sin callbacks especiales para el header
      openLogin()
    }
  }

  return (
    <>
      <button
        onClick={handleAuthClick}
        className="relative flex flex-col items-center"
      >
        <User className="h-6 w-6" />
        <span className="mt-1 text-xs">
          {authState.isAuthenticated ? 'Mi cuenta' : 'Iniciar sesi√≥n'}
        </span>
      </button>

      {/* Men√∫ de usuario - Solo se renderiza si est√° autenticado */}
      {authState.isAuthenticated && sessionData && (
        <UserMenu
          isOpen={isUserMenuOpen}
          onClose={() => { setIsUserMenuOpen(false) }}
          session={sessionData}
        />
      )}
    </>
  )
}

export default ClientAuthButton



üìÅ ARCHIVO: src/components/ui/SlidePage.tsx
------------------------------------------------------------------------------------
'use client'
import { X } from 'lucide-react'
import React, { type ReactNode, useEffect, useRef } from 'react'

interface SlidePageProps {
  isOpen: boolean
  onClose: () => void
  children: ReactNode
  title?: string
  direction?: 'left' | 'right'
  width?: number
}

const SlidePage: React.FC<SlidePageProps> = ({
  isOpen,
  onClose,
  children,
  title,
  direction = 'right',
  width = 400
}) => {
  const slideRef = useRef<HTMLDivElement>(null)

  // Cerrar al hacer clic fuera
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        isOpen &&
        slideRef.current &&
        !slideRef.current.contains(event.target as Node)
      ) {
        onClose()
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [isOpen, onClose])

  // Prevenir scroll del body cuando est√° abierto
  useEffect(() => {
    console.log('SlidePage isOpen', isOpen)

    if (isOpen) {
      document.body.style.overflow = 'hidden'
    } else {
      document.body.style.overflow = 'auto'
    }
    return () => {
      document.body.style.overflow = 'auto'
    }
  }, [isOpen])

  // Manejar tecla Escape para cerrar
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isOpen) {
        onClose()
      }
    }

    window.addEventListener('keydown', handleEscape)
    return () => {
      window.removeEventListener('keydown', handleEscape)
    }
  }, [isOpen, onClose])

  if (!isOpen) return null

  const transformValue =
    direction === 'right'
      ? isOpen
        ? 'translateX(0)'
        : 'translateX(100%)'
      : isOpen
        ? 'translateX(0)'
        : 'translateX(-100%)'

  const positionStyle = direction === 'right' ? { right: 0 } : { left: 0 }

  return (
    <div className="fixed inset-0 z-50 bg-black bg-opacity-50 transition-opacity">
      <div
        ref={slideRef}
        className="fixed top-0 h-full transform overflow-auto bg-white shadow-xl transition-transform duration-300 ease-in-out"
        style={{
          ...positionStyle,
          width: `${width}px`,
          transform: transformValue
        }}
      >
        {title && (
          <div className="border-b border-gray-200 p-4">
            <div className="flex items-center justify-between">
              <h2 className="text-xl font-bold">{title}</h2>
              <button
                onClick={onClose}
                className="rounded-full p-2 hover:bg-gray-100"
                aria-label="Cerrar"
              >
                <X className="h-5 w-5" />
              </button>
            </div>
          </div>
        )}
        {children}
      </div>
    </div>
  )
}

export default SlidePage



üìÅ ARCHIVO: src/components/ui/UserMenu.tsx
------------------------------------------------------------------------------------
'use client'
import { Heart, LogOut, MapPin, ShoppingBag, User } from 'lucide-react'
import { type Session } from 'next-auth'
import { signOut } from 'next-auth/react'
import React from 'react'
import SlidePage from './SlidePage'

interface UserMenuProps {
  isOpen: boolean
  onClose: () => void
  session: Session
}

const UserMenu: React.FC<UserMenuProps> = ({ isOpen, onClose, session }) => {
  const handleSignOut = async () => {
    await signOut({ redirect: false })
    onClose()
  }

  const menuItems = [
    {
      icon: <User className="h-5 w-5" />,
      label: 'Mi cuenta',
      href: '/account'
    },
    {
      icon: <ShoppingBag className="h-5 w-5" />,
      label: 'Mis pedidos',
      href: '/orders'
    },
    {
      icon: <Heart className="h-5 w-5" />,
      label: 'Mis favoritos',
      href: '/favorites'
    },
    {
      icon: <MapPin className="h-5 w-5" />,
      label: 'Mis direcciones',
      href: '/addresses'
    }
  ]

  return (
    <SlidePage
      isOpen={isOpen}
      onClose={onClose}
      title="Mi cuenta"
      direction="right"
      width={320}
    >
      <div className="flex h-full flex-col">
        <div className="border-b border-gray-200 p-4">
          <div className="flex items-center space-x-3">
            <div className="flex h-12 w-12 items-center justify-center rounded-full bg-primary/10">
              <User className="h-6 w-6 text-primary" />
            </div>
            <div>
              <p className="font-medium">{session.user?.name}</p>
              <p className="text-sm text-gray-500">{session.user?.email}</p>
            </div>
          </div>
        </div>
        <div className="flex-grow">
          <nav className="mt-2">
            <ul>
              {menuItems.map((item, index) => (
                <li key={index}>
                  <a
                    href={item.href}
                    className="flex items-center px-4 py-3 text-gray-700 hover:bg-gray-100"
                  >
                    <span className="mr-3 text-gray-500">{item.icon}</span>
                    {item.label}
                  </a>
                </li>
              ))}
            </ul>
          </nav>
        </div>
        <div className="border-t border-gray-200 p-4">
          <button
            onClick={handleSignOut}
            className="flex w-full items-center rounded-md px-4 py-2 text-left text-red-600 hover:bg-red-50"
          >
            <LogOut className="mr-3 h-5 w-5" />
            Cerrar sesi√≥n
          </button>
        </div>
      </div>
    </SlidePage>
  )
}

export default UserMenu



üìÅ ARCHIVO: src/components/ui/CollapsibleSection.tsx
------------------------------------------------------------------------------------
'use client'
import { ChevronDown, ChevronUp } from 'lucide-react'
import React, { useState } from 'react'

interface CollapsibleSectionProps {
  title: string
  children: React.ReactNode
  defaultExpanded?: boolean
  className?: string
}

const CollapsibleSection: React.FC<CollapsibleSectionProps> = ({
  title,
  children,
  defaultExpanded = true,
  className = 'mb-6'
}) => {
  const [isExpanded, setIsExpanded] = useState(defaultExpanded)

  return (
    <div className={className}>
      <div
        className="flex cursor-pointer items-center justify-between py-4"
        onClick={() => { setIsExpanded(!isExpanded) }}
      >
        <h4 className="font-bold">{title}</h4>
        {isExpanded ? (
          <ChevronUp className="h-5 w-5 text-gray-500" />
        ) : (
          <ChevronDown className="h-5 w-5 text-gray-500" />
        )}
      </div>
      {isExpanded && <div className="pb-7">{children}</div>}
      <div className="border-b border-gray-200"></div>
    </div>
  )
}

export default CollapsibleSection



üìÅ ARCHIVO: src/components/ui/SidePage.tsx
------------------------------------------------------------------------------------
// SidePage.tsx - Con onClose handler
'use client'
import React, { type ReactNode, useEffect, useRef, useState } from 'react'

interface SidePageProps {
  isOpen: boolean
  onClose: () => void // üëà AGREGADO
  children: ReactNode
  direction?: 'left' | 'right'
  width?: number
  preventInitialAnimation?: boolean
  closeOnEscape?: boolean // üëà OPCIONAL
  closeOnClickOutside?: boolean // üëà OPCIONAL
}

const SidePage: React.FC<SidePageProps> = ({
  isOpen,
  onClose, // üëà AGREGADO
  children,
  direction = 'right',
  width = 400,
  preventInitialAnimation = false,
  closeOnEscape = true, // üëà NUEVO
  closeOnClickOutside = true // üëà NUEVO
}) => {
  const [hasInteracted, setHasInteracted] = useState(!preventInitialAnimation)
  const sidePageRef = useRef<HTMLDivElement>(null) // üëà REF PARA CLICK OUTSIDE

  useEffect(() => {
    const body = document.body
    const shouldAnimate = hasInteracted || !preventInitialAnimation

    if (isOpen) {
      const marginProperty =
        direction === 'right' ? 'marginRight' : 'marginLeft'
      body.style[marginProperty] = `${width}px`

      if (shouldAnimate) {
        body.style.transition = 'margin 150ms ease-out'
      } else {
        body.style.transition = 'none'
        setTimeout(() => { setHasInteracted(true) }, 100)
      }
    } else {
      body.style.marginLeft = '0'
      body.style.marginRight = '0'

      if (shouldAnimate) {
        body.style.transition = 'margin 150ms ease-out'
      }

      if (!hasInteracted) {
        setHasInteracted(true)
      }
    }

    return () => {
      if (body) {
        body.style.marginLeft = ''
        body.style.marginRight = ''
        body.style.transition = ''
      }
    }
  }, [isOpen, width, direction, hasInteracted, preventInitialAnimation])

  // üëà MANEJAR TECLA ESCAPE
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isOpen && closeOnEscape) {
        onClose()
      }
    }

    if (isOpen) {
      window.addEventListener('keydown', handleEscape)
    }

    return () => {
      window.removeEventListener('keydown', handleEscape)
    }
  }, [isOpen, onClose, closeOnEscape])

  // üëà MANEJAR CLICK OUTSIDE
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        isOpen &&
        closeOnClickOutside &&
        sidePageRef.current &&
        !sidePageRef.current.contains(event.target as Node)
      ) {
        onClose()
      }
    }

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside)
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [isOpen, onClose, closeOnClickOutside])

  const positionClass = direction === 'right' ? 'right-0' : 'left-0'

  return (
    <div
      ref={sidePageRef} // üëà REF AGREGADA
      className={`fixed top-0 z-40 h-full overflow-auto bg-white shadow-xl transition-transform duration-150 ease-out ${positionClass} ${
        isOpen
          ? 'translate-x-0'
          : direction === 'right'
            ? 'translate-x-full'
            : '-translate-x-full'
      }`}
      style={{ width: `${width}px` }}
    >
      {children}
    </div>
  )
}

export default SidePage



üìÅ ARCHIVO: src/components/ui/ProductCard/ProductCard.helpers.ts
------------------------------------------------------------------------------------
import { type ProductVariantComplete } from '@/backend/product-variant'
import { type ProductDTO, type ProductVariantDTO } from '@/dto'
import { type ItemImage } from '@/shared'
import {
  type AttributeOptionImages,
  type ProductVariants,
  type VariantImages
} from '@/types/domain'

/**
 * Calcula el precio m√≠nimo de las variantes de un producto
 * @param variants Variantes del producto
 * @param basePrice Precio base del producto
 * @returns El precio m√≠nimo de las variantes o el precio base si no hay variantes
 */
export const calculateMinVariantPrice = (
  variants: ProductDTO['variants'],
  basePrice: number
): number => {
  if (!variants || variants.length === 0) return basePrice

  const prices = variants.map((variant) => {
    // Si hay promoci√≥n, usar el precio promocional
    if (variant.promotion && variant.promotion.promotionPrice !== null) {
      return Number(variant.promotion.promotionPrice)
    }
    return Number(variant.price)
  })

  return Math.min(...prices)
}

/**
 * Calcula el precio m√°ximo de las variantes de un producto
 * @param variants Variantes del producto
 * @param basePrice Precio base del producto
 * @returns El precio m√°ximo de las variantes o el precio base si no hay variantes
 */
export const calculateMaxVariantPrice = (
  variants: ProductDTO['variants'],
  basePrice: number
): number => {
  if (!variants || variants.length === 0) return basePrice

  const prices = variants.map((variant) => Number(variant.price))
  return Math.max(...prices)
}

/**
 * Agrupa los atributos de las variantes por nombre
 * @param variants Variantes del producto
 * @returns Un objeto con los atributos agrupados por nombre
 */
export const groupAttributesByName = (
  variants: ProductDTO['variants']
): Record<string, Set<string>> => {
  const attributeGroups: Record<string, Set<string>> = {}

  variants.forEach((variant) => {
    variant.attributes.forEach((attr) => {
      if (!attributeGroups[attr.name]) {
        attributeGroups[attr.name] = new Set()
      }
      attributeGroups[attr.name].add(attr.value)
    })
  })

  return attributeGroups
}

/**
 * Encuentra la imagen principal de una variante
 * @param variant Variante del producto
 * @param mainProductImage Imagen principal del producto
 * @returns La URL de la imagen principal
 */
export const findMainImage = (
  variant: ProductDTO['variants'][0],
  mainProductImage: string | null
): string => {
  if (!variant?.images || variant.images.length === 0) {
    return (
      mainProductImage ||
      'https://placehold.co/600x400/e2e8f0/1e293b?text=No+Image'
    )
  }

  const primaryImage = variant.images.find((img) => img.isPrimary)
  return primaryImage
    ? primaryImage.imageUrlThumb || primaryImage.imageUrlNormal
    : variant.images[0].imageUrlThumb || variant.images[0].imageUrlNormal
}

/**
 * Verifica si una variante tiene promoci√≥n
 * @param variant Variante a verificar
 * @returns true si la variante tiene promoci√≥n
 */
export const hasPromotion = (variant: ProductVariantComplete): boolean => {
  return !!variant?.promotionVariants?.length
}

/**
 * Calcula el porcentaje de descuento de una variante
 * @param variant Variante a calcular
 * @returns El porcentaje de descuento o 0 si no hay promoci√≥n
 */
export const calculateDiscountPercentage = (
  variant: ProductDTO['variants'][0]
): number => {
  if (!variant.promotion) return 0

  if (variant.promotion.discountType === 'percentage') {
    return variant.promotion.discountValue
  }

  const originalPrice = Number(variant.price)
  const promotionPrice =
    variant.promotion.promotionPrice ||
    originalPrice - variant.promotion.discountValue

  return Math.round(((originalPrice - promotionPrice) / originalPrice) * 100)
}

export const getPromotionDiscount = (
  variant: ProductVariantDTO
): null | number => {
  // Si no hay promoci√≥n, no mostrar nada
  if (!variant.promotion) {
    return null
  }

  const promotion = variant.promotion
  const originalPrice = variant.price
  const promotionPrice = promotion.promotionPrice || 0

  // Calcular el porcentaje de descuento
  const discountPercentage =
    promotion.discountType === 'percentage'
      ? promotion.discountValue
      : Math.round(((originalPrice - promotionPrice) / originalPrice) * 100)

  return discountPercentage
}

export const getVariantImages = (variant: ProductVariants): ItemImage[] => {
  let images: ItemImage[] = []

  // 1. Primero intentar obtener im√°genes directas de la variante
  if (variant.variantImages && variant.variantImages.length > 0) {
    const variantImages = variant.variantImages
      .filter((img): img is VariantImages => !!img)
      .map(
        (img): ItemImage => ({
          ...img,
          displayOrder: Number(img.displayOrder || 0)
        })
      )

    images = [...images, ...variantImages]
  }

  // 2. Luego obtener im√°genes de attributeOptionImages
  if (
    variant.variantAttributeOptions &&
    variant.variantAttributeOptions.length > 0
  ) {
    const attributeImages: ItemImage[] = []

    variant.variantAttributeOptions.forEach((variantAttrOption) => {
      if (variantAttrOption?.attributeOption?.attributeOptionImages) {
        const attrOptionImages =
          variantAttrOption.attributeOption.attributeOptionImages
            .filter((img): img is AttributeOptionImages => !!img)
            .map(
              (img): ItemImage => ({
                // Omitir las propiedades que no est√°n en ItemImage
                altText: img.altText,
                id: img.id,
                imageType: img.imageType,
                imageUrlNormal: img.imageUrlNormal,
                imageUrlThumb: img.imageUrlThumb,
                imageUrlZoom: img.imageUrlZoom,
                isPrimary: img.isPrimary,
                displayOrder: Number(img.displayOrder || 0)
              })
            )

        attributeImages.push(...attrOptionImages)
      }
    })

    images = [...images, ...attributeImages]
  }

  // 3. Si no hay im√°genes, devolver imagen por defecto
  if (images.length === 0) {
    return [
      {
        imageType: 'front', // Ajusta seg√∫n tu enum
        id: 0,
        imageUrlNormal: '/no-image.webp',
        imageUrlThumb: '/no-image.webp',
        imageUrlZoom: '/no-image.webp',
        displayOrder: 0,
        altText: null,
        isPrimary: null
      }
    ]
  }

  // 4. Eliminar duplicados por id (en caso de que haya im√°genes repetidas)
  const uniqueImages = images.filter(
    (img, index, self) => index === self.findIndex((i) => i.id === img.id)
  )

  // 5. Ordenar: front primero, luego por displayOrder
  const sortedImages = uniqueImages.sort((a, b) => {
    // Priorizar im√°genes tipo 'front'
    if (a.imageType === 'front' && b.imageType !== 'front') return -1
    if (b.imageType === 'front' && a.imageType !== 'front') return 1

    // Luego ordenar por displayOrder
    return a.displayOrder - b.displayOrder
  })

  return sortedImages
}

export const getImagesToProductCard = (
  variant: ProductVariantComplete
): ItemImage[] => {
  const images = getVariantImages(variant)
  return images
}

export const getThumbImageToProductCard = (
  variant: ProductVariantComplete
): string => {
  const images = getVariantImages(variant)
  if (images.length === 0) return '/no-image.webp'
  return images.find((img) => img.imageUrlThumb)?.imageUrlThumb || ''
}



üìÅ ARCHIVO: src/components/ui/ProductCard/ProductCardPromotion.tsx
------------------------------------------------------------------------------------
'use client'
import React from 'react'
import { Clock } from 'lucide-react'
import { type ProductCardPromotionProps } from './ProductCard.interfaces'

const ProductCardPromotion: React.FC<ProductCardPromotionProps> = ({
  variant,
  layout = 'grid'
}) => {
  // Si no hay promoci√≥n, no mostrar nada
  if (!variant.promotion) {
    return null
  }

  const promotion = variant.promotion
  const originalPrice = variant.price
  const promotionPrice = promotion.promotionPrice || 0

  // Calcular el porcentaje de descuento
  const discountPercentage =
    promotion.discountType === 'percentage'
      ? promotion.discountValue
      : Math.round(((originalPrice - promotionPrice) / originalPrice) * 100)

  // Calcular tiempo restante
  const now = new Date()
  const endDate = new Date(promotion.endDate)
  const timeRemaining = endDate.getTime() - now.getTime()

  // Convertir a d√≠as, horas, minutos
  const days = Math.floor(timeRemaining / (1000 * 60 * 60 * 24))
  const hours = Math.floor(
    (timeRemaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)
  )
  const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60))

  // Formatear tiempo restante
  let timeRemainingText = ''
  if (days > 0) {
    timeRemainingText = `${days}d ${hours}h`
  } else if (hours > 0) {
    timeRemainingText = `${hours}h ${minutes}m`
  } else {
    timeRemainingText = `${minutes}m`
  }

  // Si la promoci√≥n tiene un l√≠mite de stock
  const hasStockLimit = promotion.stockLimit !== null
  const stockPercentage = hasStockLimit
    ? Math.min(100, Math.max(0, (variant.stock / promotion.stockLimit) * 100))
    : 0

  return (
    <div className="mb-3 mt-2">
      {/* Etiqueta de descuento */}
      <div className="mb-2 flex items-center gap-2">
        <span className="rounded bg-red-500 px-2 py-1 text-sm font-bold text-white">
          {discountPercentage}% OFF
        </span>
        <span className="text-sm text-gray-500">{promotion.name}</span>
      </div>

      {/* Tiempo restante */}
      <div className="mb-2 flex items-center gap-2 text-sm font-medium text-gray-600">
        <Clock className="h-4 w-4" />
        <span>Termina en: {timeRemainingText}</span>
      </div>

      {/* Barra de progreso de stock (si aplica) */}
      {hasStockLimit && (
        <div className="mb-2">
          <div className="mb-1 flex justify-between text-sm text-gray-600">
            <span>Disponible: {variant.stock}</span>
            <span>L√≠mite: {promotion.stockLimit}</span>
          </div>
          <div className="h-2 w-full rounded-full bg-gray-200">
            <div
              className="h-2 rounded-full bg-secondary"
              style={{
                width: `${stockPercentage}%`
              }}
            />
          </div>
        </div>
      )}
    </div>
  )
}

export default ProductCardPromotion



üìÅ ARCHIVO: src/components/ui/ProductCard/ProductCardRating.tsx
------------------------------------------------------------------------------------
'use client'
import React from 'react'
import { Star } from 'lucide-react'

interface ProductCardRatingProps {
  rating: number
  totalRatings: number
  size?: 'sm' | 'md' | 'lg'
  showCount?: boolean
  className?: string
}

const ProductCardRating: React.FC<ProductCardRatingProps> = ({
  rating,
  totalRatings,
  size = 'sm',
  showCount = true,
  className = ''
}) => {
  // Determinar el tama√±o de las estrellas
  const starSize = {
    sm: 'h-3 w-3',
    md: 'h-4 w-4',
    lg: 'h-5 w-5'
  }[size]

  // Determinar el tama√±o del texto
  const textSize = {
    sm: 'text-xs',
    md: 'text-sm',
    lg: 'text-base'
  }[size]

  // Redondear el rating a 0.5 m√°s cercano para mostrar medias estrellas
  const roundedRating = Math.round(rating * 2) / 2

  return (
    <div className={`flex items-center ${className}`}>
      {/* Estrellas */}
      <div className="flex">
        {[1, 2, 3, 4, 5].map((star) => {
          // Estrella completa
          if (star <= roundedRating) {
            return (
              <Star
                key={star}
                className={`${starSize} fill-yellow-400 text-yellow-400`}
              />
            )
          }
          // Media estrella
          else if (star - 0.5 === roundedRating) {
            return (
              <div key={star} className="relative">
                <Star className={`${starSize} text-gray-300`} />
                <div className="absolute left-0 top-0 w-1/2 overflow-hidden">
                  <Star
                    className={`${starSize} fill-yellow-400 text-yellow-400`}
                  />
                </div>
              </div>
            )
          }
          // Estrella vac√≠a
          else {
            return <Star key={star} className={`${starSize} text-gray-300`} />
          }
        })}
      </div>

      {/* N√∫mero de valoraciones */}
      {showCount && totalRatings > 0 && (
        <span className={`${textSize} ml-1 text-gray-500`}>
          ({totalRatings})
        </span>
      )}
    </div>
  )
}

export default ProductCardRating



üìÅ ARCHIVO: src/components/ui/ProductCard/ProductCard.tsx
------------------------------------------------------------------------------------
'use client'
import { getPriceIfHasPromotion } from '@/components/product/ProductVariant.helpers'
import ProductCardButtonView from '@/components/ui/ProductCard/ProductCardButtonView'
import { getVariantImages } from '@/helpers/image.helpers'
import { getVariantTitle } from '@/helpers/productVariant.helpers'
import Link from 'next/link'
import React from 'react'
import { hasPromotion } from './ProductCard.helpers'
import { type ProductCardProps } from './ProductCard.interfaces'
import ProductCardPrice from './ProductCardPrice'
import ProductCardSlider from './ProductCardSlider'

const ProductCard: React.FC<ProductCardProps> = ({ product }) => {
  // Verificar que el producto y sus variantes existan
  if (
    !product?.variants ||
    product.variants.length === 0 ||
    !product.variantId
  ) {
    console.error('ProductCard: Producto o variantes no v√°lidos:', product)
    return null
  }

  // Buscar la variante espec√≠fica por variantId
  const variant =
    product.variants.find((v) => v.id === product.variantId) ||
    product.variants[0]
  if (!variant) {
    console.error('ProductCard: Variante no encontrada:', product)
    return null
  }

  const hasDiscount = hasPromotion(variant)
  const images = getVariantImages(variant)

  const thumbImage = images.sort((a, b) => a.displayOrder - b.displayOrder)[0]
    .imageUrlThumb

  const { originalPrice } = getPriceIfHasPromotion(variant)

  return (
    <div className={'relative bg-white pb-2 transition-shadow hover:shadow-lg'}>
      <div className="relative">
        <Link href={`/productos/variante/${variant.id}`} className={'block'}>
          <ProductCardSlider images={images} productName={product.name} />
        </Link>

        {/* <button className="absolute h-10 bottom-2 right-2">
          Addsss
        </button> */}
        <ProductCardButtonView variantId={product.variantId} />
        {/* <ProductCardButtonAddToCart
          id={product.variantId}
          image={thumbImage}
          name={getVariantTitle(product.name, variant)}
          price={originalPrice}
          stock={variant.stock}
          quantity={1}
          promotionVariants={variant.promotionVariants}
        /> */}
      </div>

      <div className="px-1">
        <Link href={`/productos/variante/${variant.id}`}>
          <h3 className="mb-1 line-clamp-1 text-[14px] font-medium leading-[14px] -tracking-wide transition-colors hover:text-primary">
            {/* Promoci√≥n */}
            {hasDiscount && (
              <span className="mr-[1px] inline-block bg-gradient-to-r from-red-500 to-red-700 px-[3px] py-[2px] text-[11px] leading-[11px] text-white">
                Promo
              </span>
            )}

            {getVariantTitle(product.name, variant)}
          </h3>
        </Link>

        {/* Precio */}
        <div className="space-y-2">
          <ProductCardPrice variant={variant} />
        </div>
      </div>
    </div>
  )
}

export default ProductCard



üìÅ ARCHIVO: src/components/ui/ProductCard/ProductCardPromotionLight.tsx
------------------------------------------------------------------------------------
'use client'
import React from 'react'
import { type ProductCardPromotionProps } from './ProductCard.interfaces'

const ProductCardPromotionLight: React.FC<ProductCardPromotionProps> = ({
  variant
}) => {
  // Si no hay promoci√≥n, no mostrar nada
  if (!variant.promotion) {
    return null
  }

  const promotion = variant.promotion
  const originalPrice = variant.price
  const promotionPrice = promotion.promotionPrice || 0

  // Calcular el porcentaje de descuento
  const discountPercentage =
    promotion.discountType === 'percentage'
      ? promotion.discountValue
      : Math.round(((originalPrice - promotionPrice) / originalPrice) * 100)

  // Calcular el ahorro
  const savings = originalPrice - promotionPrice

  // Si la promoci√≥n tiene un l√≠mite de stock
  const hasStockLimit =
    promotion.stockLimit !== null && variant.stock <= promotion.stockLimit

  return (
    <>
      {/* Badges de promoci√≥n y stock */}
      <div className="absolute left-2 top-2 flex flex-col gap-1">
        <div className="promotion-badge rounded-lg bg-red-500 px-2 py-1 text-xs font-bold text-white">
          -{discountPercentage}% DSCTO
        </div>

        {hasStockLimit && (
          <div className="stock-badge inline rounded-lg bg-orange-500 px-2 py-1 text-xs font-bold text-white">
            ¬°Solo {variant.stock}!
          </div>
        )}
      </div>

      {/* Precios */}
      <div className="inline rounded-sm bg-green-100 px-2 py-1 text-xs text-green-600">
        Ahorras S/ {savings.toFixed(2)}
      </div>
    </>
  )
}

export default ProductCardPromotionLight



üìÅ ARCHIVO: src/components/ui/ProductCard/ProductCardPrice.tsx
------------------------------------------------------------------------------------
'use client'
import { getPriceIfHasPromotion } from '@/components/product/ProductVariant.helpers'
import { formatPrice } from '@/helpers/utils'
import React from 'react'
import { type ProductCardVariantsProps } from './ProductCard.interfaces'

const ProductCardPrice: React.FC<ProductCardVariantsProps> = ({ variant }) => {
  const { finalPrice, hasPromotion, originalPrice, currentPromotion } =
    getPriceIfHasPromotion(variant)

  return (
    <div className="mt-1 flex gap-1">
      {/* Mostrar precio original si hay promoci√≥n */}
      {/* <div className="flex gap-1 items-center"> */}
      <div>
        <div className="text-[20px] font-bold leading-[20px] text-primary">
          {formatPrice(Number(finalPrice))}
        </div>
        {/* </div> */}
        {hasPromotion && (
          <div className="text-[14px] leading-[14px] text-gray-500 line-through">
            {formatPrice(Number(originalPrice))}
          </div>
        )}
      </div>
      {hasPromotion && (
        <div className="rounded-sm text-right text-sm font-bold -tracking-widest text-red-500">
          {currentPromotion?.promotion?.discountType === 'percentage'
            ? `-${Number(currentPromotion.promotion.discountValue)}%`
            : `- ${formatPrice(Number(currentPromotion?.promotion?.discountValue))}`}
        </div>
      )}
    </div>
  )
}

export default ProductCardPrice



üìÅ ARCHIVO: src/components/ui/ProductCard/ProductCardButtonAddToCart.tsx
------------------------------------------------------------------------------------
'use client'
import { getPromotions } from '@/helpers/utils'
import { useCartContext } from '@/providers/cart'
import { type PromotionVariants } from '@/types/domain'
import { ShoppingCart } from 'lucide-react'
import React from 'react'

interface ProductCardButtonAddToCartProps {
  id: number
  name: string
  image: string
  price: number
  stock: number
  quantity: number
  promotionVariants?: Array<PromotionVariants | null> | null
}

const ProductCardButtonAddToCart: React.FC<ProductCardButtonAddToCartProps> = ({
  id,
  quantity,
  name,
  price,
  image,
  stock,
  promotionVariants: pvs
}) => {
  const { updateQuantity, items, addItem, openCart } = useCartContext()

  // Encontrar el item en el carrito si existe
  const existingItem = items.find((item) => item.id === id)
  // const currentCartQuantity = existingItem?.quantity || 0;

  // Verificaciones
  const isOutOfStock = stock === 0
  const exceedsStock = quantity > stock
  // const sameAsCart = existingItem && currentCartQuantity === quantity;

  // El bot√≥n se deshabilita si no hay stock, excede stock, o ya tiene esa cantidad
  const isDisabled = isOutOfStock || exceedsStock

  const handleAddToCart = (e: React.MouseEvent<HTMLButtonElement>) => {
    e.preventDefault()

    const promotionVariants = getPromotions(pvs)

    if (isDisabled) return

    if (existingItem) {
      // Establecer la cantidad total (no sumar)
      updateQuantity(id, quantity)
    } else {
      // Agregar nuevo item
      addItem(
        {
          id,
          image,
          name,
          price,
          stock,
          promotionVariants
        },
        quantity
      )
      openCart()
    }
  }

  return (
    <button
      onClick={handleAddToCart}
      className="absolute bottom-2 right-2 mt-3 flex h-10 w-10 items-center justify-center gap-2 rounded-full border border-secondary bg-secondary py-2 text-white transition-colors hover:border-2 hover:border-secondary hover:bg-secondary-200 hover:bg-transparent hover:text-secondary"
    >
      <ShoppingCart className="h-6 w-6" />
    </button>
  )
}

export default ProductCardButtonAddToCart



üìÅ ARCHIVO: src/components/ui/ProductCard/ProductCardSlider.tsx
------------------------------------------------------------------------------------
'use client'
import { cleanAndValidateImages } from '@/components/product/ProductVariant.helpers'
import { ImageGalleryDots } from '@/components/ui/ImageGalleryDots'
import { type ItemImage } from '@/shared'
import { Heart } from 'lucide-react'
import React from 'react'

interface ProductCardSliderProps {
  images: ItemImage[]
  productName: string
  onImageClick?: (imageIndex: number) => void
  showFavoriteButton?: boolean
  mouseZoneDetection?: boolean // ‚úÖ Nueva prop (reemplaza autoSlideInterval y autoSlideOnHover)
  showZoneIndicator?: boolean // ‚úÖ Para debugging
  className?: string
}

const ProductCardSlider: React.FC<ProductCardSliderProps> = ({
  images,
  productName,
  onImageClick,
  showFavoriteButton = true,
  mouseZoneDetection = true, // ‚úÖ Por defecto activado para cards de producto
  showZoneIndicator = false, // ‚úÖ Para debugging, por defecto false
  className = 'relative mb-2 group'
}) => {
  const cleanImages = cleanAndValidateImages(images, productName)

  return (
    <div className={className}>
      <ImageGalleryDots
        images={cleanImages}
        productName={productName}
        mouseZoneDetection={mouseZoneDetection} // ‚úÖ Nueva prop
        showZoneIndicator={showZoneIndicator} // ‚úÖ Para debugging
        showDotsIndicator={true}
        showImageCounter={false}
        onImageClick={onImageClick}
        className="relative aspect-square w-full overflow-hidden rounded bg-gray-50"
      />

      {/* Bot√≥n de favoritos */}
      {showFavoriteButton && (
        <button
          className="absolute right-2 top-2 z-10 flex h-8 w-8 items-center justify-center rounded-full bg-white shadow-md transition-colors hover:bg-gray-100"
          onClick={(e) => {
            e.preventDefault()
            e.stopPropagation()
          }}
        >
          <Heart className="h-4 w-4" />
        </button>
      )}
    </div>
  )
}

export default ProductCardSlider



üìÅ ARCHIVO: src/components/ui/ProductCard/ProductCardDeal.tsx
------------------------------------------------------------------------------------
'use client'
import { Clock } from 'lucide-react'
import Image from 'next/image'
import React from 'react'
import { type ProductCardDealProps } from './ProductCard.interfaces'
import ButtonAddToCart from './ProductCardButtonAddToCart'

const ProductCardDeal: React.FC<ProductCardDealProps> = ({
  product,
  layout = 'grid'
}) => {
  return (
    <div
      className={
        layout === 'list'
          ? 'flex flex-col md:flex-row md:items-center md:gap-6'
          : ''
      }
    >
      <div
        className={`relative mb-4 aspect-square ${
          layout === 'list' ? 'md:w-1/3' : ''
        }`}
      >
        {/* Usar una imagen est√°tica o una imagen optimizada seg√∫n la URL */}
        {product.image.includes('?') ? (
          // Para URLs con par√°metros de consulta, usar img en lugar de Image
          <img
            src={product.image}
            alt={product.name}
            className="h-full w-full rounded-lg object-cover"
          />
        ) : (
          // Para URLs sin par√°metros de consulta, usar el componente Image de Next.js
          <Image
            src={product.image}
            alt={product.name}
            fill
            sizes="(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 25vw"
            className="rounded-lg object-cover"
          />
        )}

        {/* Etiqueta de descuento */}
        <span className="absolute left-2 top-2 rounded bg-red-500 px-2 py-1 text-sm font-bold text-white">
          {product.discount}% OFF
        </span>
      </div>

      <div className={layout === 'list' ? 'md:w-2/3' : ''}>
        <h3 className="mb-2 font-medium">{product.name}</h3>

        <div className="mb-3 flex items-center gap-2">
          <span className="text-lg font-bold text-primary">
            S/ {product.price}
          </span>
          {product.originalPrice && (
            <span className="text-sm text-gray-500 line-through">
              S/ {product.originalPrice}
            </span>
          )}
        </div>

        <div className="mb-3">
          <div className="mb-1 flex justify-between text-sm text-gray-600">
            <span>Vendidos: {30 - product.stock}</span>
            <span>Disponible: {product.stock}</span>
          </div>
          <div className="h-2 w-full rounded-full bg-gray-200">
            <div
              className="h-2 rounded-full bg-secondary"
              style={{
                width: `${((30 - product.stock) / 30) * 100}%`
              }}
            />
          </div>
        </div>
        <div className="mb-3 flex items-center justify-center gap-2 text-sm font-medium text-gray-600">
          <Clock className="h-4 w-4" />
          <span>Oferta termina en: {product.timer}</span>
        </div>
        <ButtonAddToCart {...product} />
      </div>
    </div>
  )
}

export default ProductCardDeal



üìÅ ARCHIVO: src/components/ui/ProductCard/ProductCardButtonView.tsx
------------------------------------------------------------------------------------
'use client'
import ProductVariantInteractive from '@/components/product/ProductVariantInteractive'
import { ProductVariantInteractiveShimmer } from '@/components/product/ProductVariantInteractiveShimmer'
import { Modal } from '@/components/ui/Modal'
import { type ProductVariantData } from '@/services/product/productVariant'
import { type ProductVariants } from '@/types/domain'
import { ShoppingCart } from 'lucide-react'
import React, { useState } from 'react'

interface ProductCardButtonViewProps {
  variantId: number
}

const ProductCardButtonView: React.FC<ProductCardButtonViewProps> = ({
  variantId
}) => {
  const [data, setData] = useState<{
    data: ProductVariantData
    allVariants: ProductVariants[]
    variant: ProductVariants
  } | null>(null)
  const [isOpen, setIsOpen] = useState(false)
  const [loading, setLoading] = useState(false)

  const onCartAction = () => {
    setIsOpen(false)
  }

  const [error, setError] = useState<string>()
  const handleView = async (variantIdSelected: number) => {
    setIsOpen(true)

    try {
      setLoading(true)
      const response = await fetch(
        `/api/productos/variante/${variantIdSelected}`
      )
      if (response.ok) {
        const responseData: ProductVariantData | null = await response.json()

        if (responseData === null) {
          setError('El fetch no trajo la data')
          return
        }

        const allVariants = (responseData.product.productVariants || []).filter(
          (v) => v !== null
        )
        const variant = allVariants.find(
          (variant) => variant.id === variantIdSelected
        )

        if (!variant) {
          setError('No existe la variante')
          return
        }

        setData({
          allVariants,
          data: responseData,
          variant
        })
      }
    } catch (e) {
      setError(e)
    } finally {
      setLoading(false)
    }
  }

  const handleVariantChangePreview = (
    attributeId: number,
    optionId: number
  ) => {
    const allVariants = data?.allVariants
    if (!allVariants) return

    const variantId = allVariants.find((v) => {
      return v?.variantAttributeOptions?.some(
        (vao) => vao?.attributeOption?.id === optionId
      )
    })?.id

    if (!variantId) return
    handleView(variantId)
  }

  return (
    <>
      <button
        onClick={() => {
          handleView(variantId)
        }}
        className="absolute bottom-2 right-2 mt-3 flex h-10 w-10 items-center justify-center gap-2 rounded-full border border-secondary bg-secondary py-2 text-white transition-colors hover:border-2 hover:border-secondary hover:bg-secondary-200 hover:bg-transparent hover:text-secondary"
      >
        <ShoppingCart className="h-6 w-6" />
      </button>
      <Modal
        className="max-h-[calc(100%-80px)] max-w-[calc(100%-80px)] overflow-y-auto pt-10"
        isOpen={isOpen}
        onClose={() => {
          setIsOpen(false)
        }}
      >
        {loading && data === null && <ProductVariantInteractiveShimmer />}
        {error}
        {!!data && (
          <ProductVariantInteractive
            onCartAction={onCartAction}
            handleVariantChangePreview={handleVariantChangePreview}
            preview={true}
            initialData={data.data}
            allVariants={data.allVariants}
            variant={data.variant}
          />
        )}
      </Modal>
    </>
  )
}

export default ProductCardButtonView



üìÅ ARCHIVO: src/components/ui/ProductCard/ProductCard.interfaces.ts
------------------------------------------------------------------------------------
// import { ProductComplete } from '@/backend/product'
import { type ProductComplete } from '@/backend/product'
import { type ProductVariantComplete } from '@/backend/product-variant'
import { type ItemImage } from '@/shared'
import { type ProductVariants } from '@/types/domain'

// Props para el componente ProductCard
export interface ProductCardProps {
  product: ProductComplete
}

// Props para el componente ProductCardVariants
export interface ProductCardVariantsProps {
  variant: ProductVariants
}

// Props para el componente ProductCardPromotion
export interface ProductCardPromotionProps {
  variant: ProductVariantComplete
  layout?: 'grid' | 'list'
}

export interface ProductCardSliderProps {
  images: ItemImage[]
  onFavoriteClick?: () => void
}



üìÅ ARCHIVO: src/components/ui/ProductCard/index.ts
------------------------------------------------------------------------------------
// Exportar el componente principal como default
export { default } from './ProductCard'

// Exportar los componentes individuales
export { default as ProductCardSlider } from './ProductCardSlider'
export { default as ProductCardVariants } from './ProductCardVariants'
export { default as ProductCardPromotion } from './ProductCardPromotion'

// Exportar las interfaces
export * from './ProductCard.interfaces'

// Exportar las funciones auxiliares
export * from './ProductCard.helpers'



üìÅ ARCHIVO: src/components/ui/ProductCard/ProductCardVariants.tsx
------------------------------------------------------------------------------------
'use client'
import React from 'react'
import { type ProductCardVariantsProps } from './ProductCard.interfaces'
import { groupAttributesByName } from './ProductCard.helpers'

const ProductCardVariants: React.FC<ProductCardVariantsProps> = ({
  variantProduct,
  selectedVariantIndex,
  setSelectedVariantIndex
}) => {
  const selectedVariant = variantProduct.variants[selectedVariantIndex]

  // Agrupar atributos por nombre para mostrar opciones
  const attributeGroups = groupAttributesByName(variantProduct.variants)

  return (
    <div className="space-y-2">
      {Object.entries(attributeGroups).map(([attrName, values]) => (
        <div key={attrName} className="flex items-center text-sm">
          <span className="mr-2 text-gray-500">{attrName}:</span>
          <div className="flex flex-wrap gap-1">
            {Array.from(values).map((value) => {
              // Verificar si la variante seleccionada tiene este atributo con este valor
              const isSelected = selectedVariant.attributes.some(
                (attr) => attr.name === attrName && attr.value === value
              )

              // Encontrar variantes con este atributo
              const variantWithAttr = variantProduct.variants.findIndex(
                (variant) =>
                  variant.attributes.some(
                    (attr) => attr.name === attrName && attr.value === value
                  )
              )

              // Determinar el tipo de visualizaci√≥n para este atributo
              const attribute = selectedVariant.attributes.find(
                (attr) => attr.name === attrName
              )
              const displayType = attribute?.display_type || 'pills'

              // Clases seg√∫n el tipo de visualizaci√≥n
              let buttonClasses = 'text-xs px-2 py-0.5 rounded cursor-pointer '

              if (displayType === 'color') {
                // Para atributos de tipo color
                buttonClasses += isSelected
                  ? 'ring-2 ring-primary border border-white'
                  : 'ring-1 ring-gray-300 border border-white'

                // Intentar interpretar el valor como un color
                const isColorValue =
                  /^#([0-9A-F]{3}){1,2}$/i.test(value) ||
                  [
                    'black',
                    'white',
                    'red',
                    'blue',
                    'green',
                    'yellow',
                    'purple',
                    'gray',
                    'silver'
                  ].includes(value.toLowerCase())

                if (isColorValue) {
                  return (
                    <button
                      key={value}
                      title={value}
                      className={buttonClasses}
                      style={{
                        backgroundColor: value.toLowerCase(),
                        width: '24px',
                        height: '24px',
                        borderRadius: '50%'
                      }}
                      onClick={(e) => {
                        e.preventDefault()
                        if (variantWithAttr >= 0) {
                          setSelectedVariantIndex(variantWithAttr)
                        }
                      }}
                    />
                  )
                }
              }

              // Para otros tipos de atributos (pills, radio, select, custom)
              buttonClasses += isSelected
                ? 'bg-primary/10 text-primary border border-primary'
                : 'bg-gray-100 text-gray-700 border border-transparent'

              return (
                <button
                  key={value}
                  className={buttonClasses}
                  onClick={(e) => {
                    e.preventDefault()
                    if (variantWithAttr >= 0) {
                      setSelectedVariantIndex(variantWithAttr)
                    }
                  }}
                >
                  {value}
                </button>
              )
            })}
          </div>
        </div>
      ))}

      {/* Precio */}
      <div className="mt-3 flex items-center gap-2">
        <span className="text-lg font-bold text-primary">
          S/{' '}
          {selectedVariant.promotion?.promotionPrice || selectedVariant.price}
        </span>

        {/* Mostrar precio original si hay promoci√≥n */}
        {selectedVariant.promotion && (
          <span className="text-sm text-gray-500 line-through">
            S/ {selectedVariant.price}
          </span>
        )}
      </div>
    </div>
  )
}

export default ProductCardVariants



üìÅ ARCHIVO: src/components/ui/ProductCard/ProductCardPromotionDiscount.tsx
------------------------------------------------------------------------------------
'use client'
import React from 'react'
import { type ProductCardPromotionProps } from './ProductCard.interfaces'

const ProductCardPromotionDiscount: React.FC<ProductCardPromotionProps> = ({
  variant
}) => {
  // Si no hay promoci√≥n, no mostrar nada
  if (!variant.promotion) {
    return null
  }

  const promotion = variant.promotion
  const originalPrice = variant.price
  const promotionPrice = promotion.promotionPrice || 0

  // Calcular el porcentaje de descuento
  const discountPercentage =
    promotion.discountType === 'percentage'
      ? promotion.discountValue
      : Math.round(((originalPrice - promotionPrice) / originalPrice) * 100)

  // Calcular el ahorro
  const savings = originalPrice - promotionPrice

  // Si la promoci√≥n tiene un l√≠mite de stock
  const hasStockLimit =
    promotion.stockLimit !== null && variant.stock <= promotion.stockLimit

  return (
    <>
      {/* Badges de promoci√≥n y stock */}
      <div className="absolute left-2 top-2 flex flex-col gap-1">
        <div className="promotion-badge rounded-lg bg-red-500 px-2 py-1 text-xs font-bold text-white">
          -{discountPercentage}% DSCTO
        </div>

        {hasStockLimit && (
          <div className="stock-badge inline rounded-lg bg-orange-500 px-2 py-1 text-xs font-bold text-white">
            ¬°Solo {variant.stock}!
          </div>
        )}
      </div>

      {/* Precios */}
      <div className="inline rounded-sm bg-green-100 px-2 py-1 text-xs text-green-600">
        Ahorras S/ {savings.toFixed(2)}
      </div>
    </>
  )
}

export default ProductCardPromotionDiscount



üìÅ ARCHIVO: src/components/ui/PlusMinusButton.tsx
------------------------------------------------------------------------------------
import { cn } from '@/lib/utils'
import { type ProductVariants } from '@/types/domain'
import { type FC, useEffect, useState } from 'react'

interface PlusMinusButtonProps {
  variant?: ProductVariants
  initialQuantity?: number
  maxQuantity?: number
  minQuantity?: number
  onQuantityChange?: (quantity: number) => void
  onRemoveRequest?: () => void
  disabled?: boolean
  forceEnabled?: boolean
  size?: 'sm' | 'md' | 'lg'
  className?: string
  stock: number
  allowRemove?: boolean
  // üÜï Nueva prop para preservar la cantidad del usuario
  preserveQuantity?: boolean
}

export const PlusMinusButton: FC<PlusMinusButtonProps> = ({
  stock,
  initialQuantity = 1,
  maxQuantity,
  minQuantity = 1,
  allowRemove = false,
  onQuantityChange,
  onRemoveRequest,
  disabled = false,
  forceEnabled = false,
  size = 'md',
  className,
  preserveQuantity = false // üÜï Por defecto false (comportamiento original)
}) => {
  const [quantity, setQuantity] = useState(initialQuantity)

  // Determinar la cantidad m√°xima
  const effectiveMaxQuantity = maxQuantity || stock || 999

  // L√≥gica simple: forceEnabled override disabled
  const effectiveDisabled = forceEnabled ? false : disabled

  // Sincronizar con initialQuantity cuando cambie
  useEffect(() => {
    setQuantity(initialQuantity)
  }, [initialQuantity])

  // üÜï Asegurar que la cantidad inicial est√© en el rango v√°lido
  // SOLO si preserveQuantity es false
  useEffect(() => {
    if (!preserveQuantity) {
      // ‚úÖ Comportamiento original: ajustar autom√°ticamente
      if (initialQuantity < minQuantity) {
        setQuantity(minQuantity)
      } else if (initialQuantity > effectiveMaxQuantity) {
        setQuantity(effectiveMaxQuantity)
      } else {
        setQuantity(initialQuantity)
      }
    } else {
      // ‚úÖ Preservar cantidad: NO hacer ajustes autom√°ticos
      setQuantity(initialQuantity)
      console.log(
        `üîí Preserving user quantity: ${initialQuantity} (max available: ${effectiveMaxQuantity})`
      )
    }
  }, [initialQuantity, minQuantity, effectiveMaxQuantity, preserveQuantity])

  const increaseQuantity = () => {
    // ‚úÖ Con preserveQuantity, permitir aumentar incluso si excede stock
    // El control se hace mediante advertencias visuales, no bloqueando la acci√≥n
    if (!effectiveDisabled) {
      if (preserveQuantity || quantity < effectiveMaxQuantity) {
        const newQuantity = quantity + 1
        console.log(
          `‚ûï Increasing quantity: ${quantity} ‚Üí ${newQuantity} (max: ${effectiveMaxQuantity}, preserve: ${preserveQuantity})`
        )
        setQuantity(newQuantity)
        onQuantityChange?.(newQuantity)
      } else {
        console.log(
          `üö´ Cannot increase: ${quantity} >= ${effectiveMaxQuantity} (preserve: ${preserveQuantity})`
        )
      }
    }
  }

  const decreaseQuantity = () => {
    if (!effectiveDisabled) {
      // Si allowRemove es true y quantity es 1, mostrar confirmaci√≥n
      if (allowRemove && quantity === 1) {
        onRemoveRequest?.()
        return
      }

      // Si allowRemove es false, no permitir bajar de minQuantity
      const minimumAllowed = allowRemove ? 0 : minQuantity

      if (quantity > minimumAllowed) {
        const newQuantity = quantity - 1
        console.log(
          `‚ûñ Decreasing quantity: ${quantity} ‚Üí ${newQuantity} (min: ${minimumAllowed})`
        )
        setQuantity(newQuantity)
        onQuantityChange?.(newQuantity)
      } else {
        console.log(`üö´ Cannot decrease: ${quantity} <= ${minimumAllowed}`)
      }
    }
  }

  // Determinar si el bot√≥n de disminuir debe estar deshabilitado
  const isDecreaseDisabled = () => {
    if (effectiveDisabled) return true

    // Si allowRemove es false, deshabilitar cuando llegue al m√≠nimo
    if (!allowRemove) {
      return quantity <= minQuantity
    }

    // Si allowRemove es true, nunca deshabilitar
    return false
  }

  // üÜï Determinar si el bot√≥n de aumentar debe estar deshabilitado
  const isIncreaseDisabled = () => {
    if (effectiveDisabled) return true

    // Si preserveQuantity es true, permitir aumentar libremente (advertencias se muestran visualmente)
    if (preserveQuantity) return false

    // Si preserveQuantity es false, comportamiento normal (respetar stock)
    return quantity >= effectiveMaxQuantity
  }

  // Variantes de tama√±o
  const sizeStyles = {
    sm: {
      button: 'w-6 h-6 text-xs',
      display: 'w-8 h-6 text-sm',
      container: ''
    },
    md: {
      button: 'w-8 h-8 text-sm',
      display: 'w-12 h-8 text-sm',
      container: ''
    },
    lg: {
      button: 'w-10 h-10 text-base',
      display: 'w-16 h-10 text-base',
      container: ''
    }
  }

  const currentSize = sizeStyles[size]

  return (
    <div
      className={cn(
        'flex items-center',
        currentSize.container,
        effectiveDisabled && 'opacity-50',
        className
      )}
    >
      <button
        onClick={decreaseQuantity}
        disabled={isDecreaseDisabled()}
        className={cn(
          'flex items-center justify-center rounded-full bg-gray-100 font-semibold text-gray-600 transition-colors hover:bg-gray-200 disabled:cursor-not-allowed disabled:opacity-50',
          currentSize.button
        )}
        aria-label="Disminuir cantidad"
      >
        ‚àí
      </button>

      <div
        className={cn(
          'flex items-center justify-center font-bold text-gray-900',
          currentSize.display,
          // üÜï Indicador visual cuando la cantidad excede el stock disponible
          preserveQuantity &&
            quantity > effectiveMaxQuantity &&
            'text-orange-600'
        )}
      >
        {quantity}
      </div>

      <button
        onClick={increaseQuantity}
        disabled={isIncreaseDisabled()}
        className={cn(
          'flex items-center justify-center rounded-full bg-gray-100 font-semibold text-gray-600 transition-colors hover:bg-gray-200 disabled:cursor-not-allowed disabled:opacity-50',
          currentSize.button
        )}
        aria-label="Aumentar cantidad"
      >
        +
      </button>
    </div>
  )
}



üìÅ ARCHIVO: src/components/ui/MiniCart.tsx
------------------------------------------------------------------------------------
'use client'
import { CartContentThin } from '@/components/ui/CartContent/CartContentThin'
import { Modal } from '@/components/ui/Modal'
import { ModalContent } from '@/components/ui/Modal/ModalContent'
import { ModalTitle } from '@/components/ui/Modal/ModalTitle'
import SidePage from '@/components/ui/SidePage'
import Toast from '@/components/ui/Toast'
import { useCartContext } from '@/providers/cart'
import React from 'react'

const MiniCart: React.FC = () => {
  const {
    items,
    totalPrice,
    updateQuantity,
    isCartOpen,
    closeCart,
    toastMessage,
    canShowMinicart, // üëà Tu funci√≥n del hook
    deleteConfirmation,
    openDeleteConfirmation,
    closeDeleteConfirmation,
    confirmDelete
  } = useCartContext()

  return (
    <>
      {canShowMinicart() && (
        <SidePage
          closeOnClickOutside={false}
          onClose={closeCart}
          isOpen={isCartOpen}
          direction="right"
          width={215}
        >
          <CartContentThin
            items={items}
            totalPrice={totalPrice}
            updateQuantity={updateQuantity}
            onDelete={openDeleteConfirmation} // üëà Usar la funci√≥n del provider
            onClose={closeCart}
          />
        </SidePage>
      )}

      {toastMessage && <Toast message={toastMessage} position="bottom-right" />}

      {/* üëà MODAL DE CONFIRMACI√ìN */}
      <Modal
        isOpen={deleteConfirmation.isOpen}
        onClose={closeDeleteConfirmation}
        className="p-4 pt-4"
      >
        <ModalTitle onClose={closeDeleteConfirmation} className="mb-5 p-0">
          <p className="pl-2 font-bold">Quitar articulo</p>
        </ModalTitle>
        <ModalContent className="p-0">
          <div className="space-y-4">
            <div className="flex items-center gap-3">
              <div>
                <p className="text-sm text-gray-700">
                  {deleteConfirmation.message ||
                    '¬øEst√°s seguro de que quieres eliminar el art√≠culo de tu cesta?'}
                </p>
              </div>
            </div>

            <div className="flex justify-end gap-3 pt-2">
              <button
                onClick={closeDeleteConfirmation}
                className="font-semibol border border-gray-300 px-4 py-2 text-sm text-gray-700 transition-colors hover:bg-gray-50"
              >
                Cancelar
              </button>
              <button
                onClick={confirmDelete}
                className="bg-red-600 px-4 py-2 text-sm font-semibold text-white transition-colors hover:bg-red-700"
              >
                Quitar
              </button>
            </div>
          </div>
        </ModalContent>
      </Modal>
    </>
  )
}

export default MiniCart



üìÅ ARCHIVO: src/components/ui/SearchBar.tsx
------------------------------------------------------------------------------------
'use client'
import { useRouter } from 'next/navigation'
import SearchSuggestions from '../search/SearchSuggestions'

export default function SearchBar() {
  const router = useRouter()

  const handleSearch = (query?: string) => {
    // Construir URL de b√∫squeda
    const searchUrl = '/search'
    const params = new URLSearchParams()

    if (query === undefined) {
      router.push(`${searchUrl}`)
      return
    }

    // A√±adir query si existe
    if (query.trim()) {
      params.set('q', query.trim())
    }

    // Navegar a la p√°gina de b√∫squeda
    router.push(`${searchUrl}?${params.toString()}`)
  }

  return (
    <div className="flex-1">
      <SearchSuggestions
        onSearch={handleSearch}
        placeholder="Buscar productos..."
        className="w-full"
      />
    </div>
  )
}



üìÅ ARCHIVO: src/components/ui/Label.tsx
------------------------------------------------------------------------------------
import { cn } from '@/lib/utils'
import { forwardRef } from 'react'

export type LabelProps = React.LabelHTMLAttributes<HTMLLabelElement>

const Label = forwardRef<HTMLLabelElement, LabelProps>(
  ({ className, ...props }, ref) => (
    <label
      ref={ref}
      className={cn(
        'text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70',
        className
      )}
      {...props}
    />
  )
)
Label.displayName = 'Label'

export { Label }



üìÅ ARCHIVO: src/components/ui/ImageZoomModal.tsx
------------------------------------------------------------------------------------
'use client'
import React from 'react'
import Image from 'next/image'
import { X } from 'lucide-react'

interface ImageZoomModalProps {
  isOpen: boolean
  imageUrl: string
  altText: string
  onClose: () => void
}

const ImageZoomModal: React.FC<ImageZoomModalProps> = ({
  isOpen,
  imageUrl,
  altText,
  onClose
}) => {
  if (!isOpen) return null

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose()
    }
  }

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 p-4"
      onClick={handleBackdropClick}
    >
      <div className="relative flex h-full max-h-full w-full max-w-7xl items-center justify-center">
        {/* Bot√≥n de cerrar */}
        <button
          onClick={onClose}
          className="absolute right-4 top-4 z-10 flex h-10 w-10 items-center justify-center rounded-full bg-white/20 text-white transition-colors hover:bg-white/30"
          aria-label="Cerrar zoom"
        >
          <X className="h-6 w-6" />
        </button>

        {/* Imagen ampliada */}
        <div className="max-h-4xl relative h-full w-full max-w-4xl">
          <Image
            src={imageUrl}
            alt={altText}
            fill
            sizes="100vw"
            className="object-contain"
            priority
          />
        </div>
      </div>
    </div>
  )
}

export default ImageZoomModal



üìÅ ARCHIVO: src/components/ui/CategoriesMenu.tsx
------------------------------------------------------------------------------------
'use client'
import { type Categories } from '@/types/domain'
import { ChevronLeft, ChevronRight, Home } from 'lucide-react'
import Image from 'next/image'
import Link from 'next/link'
import React, { useState } from 'react'

interface CategoriesMenuProps {
  categories: Categories[]
  onClose?: () => void
}

interface CategoryLevel {
  category: Categories | null
  children: Categories[]
  title: string
}

const CategoriesMenu: React.FC<CategoriesMenuProps> = ({
  categories,
  onClose
}) => {
  const [categoryStack, setCategoryStack] = useState<CategoryLevel[]>([
    {
      category: null,
      children: categories
        ? categories.filter((cat) => cat.parentId === null)
        : [],
      title: 'Todas las categor√≠as'
    }
  ])

  const currentLevel = categoryStack[categoryStack.length - 1]

  const handleCategoryClick = (category: Categories) => {
    const children = categories
      ? categories.filter((cat) => cat.parentId === category.id)
      : []

    if (children.length > 0) {
      // Si tiene subcategor√≠as, navegar a ellas
      setCategoryStack((prev) => [
        ...prev,
        {
          category,
          children,
          title: category.name
        }
      ])
    } else {
      // Si no tiene subcategor√≠as, ir a la p√°gina de la categor√≠a
      if (onClose) {
        onClose()
      }
      window.location.href = `/categoria/${category.id}`
    }
  }

  const handleBackClick = () => {
    if (categoryStack.length > 1) {
      setCategoryStack((prev) => prev.slice(0, -1))
    }
  }

  const handleHomeClick = () => {
    setCategoryStack([
      {
        category: null,
        children: categories
          ? categories.filter((cat) => cat.parentId === null)
          : [],
        title: 'Todas las categor√≠as'
      }
    ])
  }

  return (
    <div className="flex h-full flex-col">
      {/* Header con navegaci√≥n */}
      <div className="border-b border-gray-200 bg-gray-50 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-lg font-semibold text-gray-800">
            {currentLevel.title}
          </h3>
          {categoryStack.length > 1 && (
            <button
              onClick={handleHomeClick}
              className="rounded-full p-2 transition-colors hover:bg-gray-200"
              title="Ir al inicio"
            >
              <Home className="h-4 w-4 text-gray-600" />
            </button>
          )}
        </div>

        {/* Breadcrumb */}
        <div className="flex items-center text-sm text-gray-600">
          {categoryStack.map((level, index) => (
            <React.Fragment key={index}>
              {index > 0 && (
                <ChevronRight className="mx-1 h-3 w-3 text-gray-400" />
              )}
              <button
                onClick={() => { setCategoryStack((prev) => prev.slice(0, index + 1)) }
                }
                className="transition-colors hover:text-primary"
              >
                {level.title}
              </button>
            </React.Fragment>
          ))}
        </div>
      </div>

      {/* Bot√≥n de retroceso */}
      {categoryStack.length > 1 && (
        <div className="border-b border-gray-100 p-3">
          <button
            onClick={handleBackClick}
            className="flex w-full items-center gap-2 text-left text-gray-600 transition-colors hover:text-primary"
          >
            <ChevronLeft className="h-4 w-4" />
            <span>Volver</span>
          </button>
        </div>
      )}

      {/* Lista de categor√≠as */}
      <div className="flex-1 overflow-y-auto">
        {currentLevel.children.length > 0 ? (
          <div className="p-2">
            {currentLevel.children.map((category) => {
              const hasChildren = categories
                ? categories.some((cat) => cat.parentId === category.id)
                : false

              return (
                <div
                  key={category.id}
                  className="border-b border-gray-100 last:border-b-0"
                >
                  <button
                    onClick={() => { handleCategoryClick(category) }}
                    className="group flex w-full items-center justify-between p-3 transition-colors hover:bg-gray-50"
                  >
                    <div className="flex items-center gap-3">
                      {category.imageUrl && (
                        <div className="h-8 w-8 flex-shrink-0 overflow-hidden rounded-full bg-gray-100">
                          <Image
                            src={category.imageUrl}
                            alt={category.name}
                            width={32}
                            height={32}
                            className="h-full w-full object-cover"
                          />
                        </div>
                      )}
                      <div className="text-left">
                        <div className="font-medium text-gray-800 transition-colors group-hover:text-primary">
                          {category.name}
                        </div>
                        {category.description && (
                          <div className="mt-1 text-xs text-gray-500">
                            {category.description}
                          </div>
                        )}
                      </div>
                    </div>

                    {hasChildren && (
                      <ChevronRight className="h-4 w-4 text-gray-400 transition-colors group-hover:text-primary" />
                    )}
                  </button>
                </div>
              )
            })}
          </div>
        ) : (
          <div className="p-6 text-center text-gray-500">
            <p>No hay subcategor√≠as disponibles</p>
            <Link
              href={`/categoria/${currentLevel.category?.id}`}
              className="mt-3 inline-block rounded-lg bg-primary px-4 py-2 text-white transition-colors hover:bg-primary/90"
            >
              Ver productos
            </Link>
          </div>
        )}
      </div>

      {/* Footer con enlaces √∫tiles */}
      <div className="border-t border-gray-200 bg-gray-50 p-4">
        <div className="space-y-2">
          <Link
            href="/ofertas"
            className="block text-sm text-gray-600 transition-colors hover:text-primary"
          >
            üî• Ver todas las ofertas
          </Link>
          <Link
            href="/nuevos"
            className="block text-sm text-gray-600 transition-colors hover:text-primary"
          >
            ‚ú® Productos nuevos
          </Link>
          <Link
            href="/marcas"
            className="block text-sm text-gray-600 transition-colors hover:text-primary"
          >
            üè∑Ô∏è Explorar marcas
          </Link>
        </div>
      </div>
    </div>
  )
}

export default CategoriesMenu



üìÅ ARCHIVO: src/components/ui/ImageSlider/useImageSlider.ts
------------------------------------------------------------------------------------
import { useEffect, useState } from 'react'

interface UseImageSliderProps {
  imagesLength: number
  autoSlideInterval?: number
}

export const useImageSlider = ({
  imagesLength,
  autoSlideInterval = 2000
}: UseImageSliderProps) => {
  const [currentImageIndex, setCurrentImageIndex] = useState(0)
  const [isSliderActive, setIsSliderActive] = useState(false)

  // Efecto para cambiar autom√°ticamente las im√°genes cuando el slider est√° activo
  useEffect(() => {
    let interval: NodeJS.Timeout

    if (isSliderActive && imagesLength > 1) {
      interval = setInterval(() => {
        setCurrentImageIndex((prevIndex) => (prevIndex + 1) % imagesLength)
      }, autoSlideInterval)
    }

    return () => {
      if (interval) clearInterval(interval)
    }
  }, [isSliderActive, imagesLength, autoSlideInterval])

  const goToImage = (index: number) => {
    setCurrentImageIndex(index)
  }

  const startSlider = () => {
    setIsSliderActive(true)
  }

  const stopSlider = () => {
    setIsSliderActive(false)
  }

  return {
    currentImageIndex,
    isSliderActive,
    goToImage,
    startSlider,
    stopSlider
  }
}



üìÅ ARCHIVO: src/components/ui/ImageSlider/ImageSlider.tsx
------------------------------------------------------------------------------------
'use client'
import { type ItemImage } from '@/shared'
import Image from 'next/image'
import React from 'react'
import { useImageSlider } from './useImageSlider' // Ajusta la ruta seg√∫n tu estructura

interface ImageSliderProps {
  images: ItemImage[]
  defaultImage?: string
  className?: string
  autoSlideInterval?: number
  showIndicators?: boolean
}

const ImageSlider: React.FC<ImageSliderProps> = ({
  images,
  defaultImage = '/no-image.webp',
  className = 'w-full aspect-square overflow-hidden relative bg-gray-50',
  autoSlideInterval = 2000,
  showIndicators = true
}) => {
  const { currentImageIndex, goToImage, startSlider, stopSlider } =
    useImageSlider({
      imagesLength: images.length,
      autoSlideInterval
    })

  // Si no hay im√°genes, mostrar imagen por defecto
  if (images.length === 0) {
    return (
      <div className={className}>
        <Image
          src={defaultImage}
          alt="No image available"
          fill
          sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
          className="object-contain"
          priority
        />
      </div>
    )
  }

  return (
    <div
      className={className}
      onMouseEnter={startSlider}
      onMouseLeave={stopSlider}
    >
      {/* Contenedor de im√°genes */}
      {images.map((image, idx) => (
        <div
          key={idx}
          className={`absolute inset-0 transition-opacity duration-500 ${
            currentImageIndex === idx ? 'opacity-100' : 'opacity-0'
          }`}
        >
          <Image
            src={image.imageUrlNormal || defaultImage}
            alt={image.altText || ''}
            fill
            sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
            className="object-contain"
            priority={idx === 0}
          />
        </div>
      ))}

      {/* Indicadores de im√°genes */}
      {showIndicators && images.length > 1 && (
        <div className="absolute bottom-0 left-0 right-0 flex justify-center gap-1">
          {images.map((_, idx) => (
            <button
              key={idx}
              className={`h-2 w-2 rounded-full transition-colors ${
                currentImageIndex === idx ? 'bg-gray-800' : 'bg-gray-300'
              }`}
              onClick={(e) => {
                e.preventDefault()
                goToImage(idx)
              }}
            />
          ))}
        </div>
      )}
    </div>
  )
}

export default ImageSlider



üìÅ ARCHIVO: src/components/ui/CartContent/CartContentEmpty.tsx
------------------------------------------------------------------------------------
import { ShoppingBag } from 'lucide-react'

export const CartContentEmpty = () => {
  return (
    <div className="flex h-full">
      <div className="flex flex-grow flex-col items-center justify-center p-4">
        <ShoppingBag className="mb-4 h-16 w-16 text-gray-300" />
        <p className="text-center text-gray-500">
          Tu carrito est√° vac√≠o. Agrega algunos productos para continuar.
        </p>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/ui/CartContent/CartContentThin/CartContentThin.tsx
------------------------------------------------------------------------------------
'use client'
import { CartContentThinEmpty } from './CartContentThinEmpty'
import { CartContentThinItem } from './CartContentThinItem'
import { CartContentThinPurchase } from './CartContentThinPurchase'

import { type CartItem } from '@/hooks/useCart'
import React, { type JSX } from 'react'

interface CartContentThinProps {
  items: CartItem[]
  totalPrice: number
  updateQuantity: (id: number, quantity: number) => void
  onDelete: (id: number) => void // Nueva prop
  onClose: () => void
}

export const CartContentThin: React.FC<CartContentThinProps> = ({
  items,
  totalPrice,
  updateQuantity,
  onDelete,
  onClose
}): JSX.Element => {
  const hasNotItems = items.length === 0

  if (hasNotItems) {
    return <CartContentThinEmpty />
  }

  return (
    <div className="flex h-full flex-col gap-4 overflow-hidden p-4">
      <CartContentThinPurchase onClose={onClose} totalPrice={totalPrice} />
      <div className="flex h-full max-h-[calc(100%-144px)] flex-col overflow-y-auto">
        <div className="grid grid-cols-2 gap-4 gap-y-5">
          {items.map((item) => (
            <CartContentThinItem
              key={item.id}
              item={item}
              updateQuantity={updateQuantity}
              onDelete={onDelete} // Pasar la funci√≥n
            />
          ))}
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/ui/CartContent/CartContentThin/CartContentThinItem.tsx
------------------------------------------------------------------------------------
import { PlusMinusButton } from '@/components/ui/PlusMinusButton'
import { formatPrice } from '@/helpers/utils'
import { type CartItem } from '@/hooks/useCart'
import Image from 'next/image'
import { type FC } from 'react'

interface CartContentThinItemProps {
  item: CartItem
  updateQuantity: (id: number, quantity: number) => void
  onDelete: (id: number) => void // Nueva prop
}

export const CartContentThinItem: FC<CartContentThinItemProps> = ({
  item,
  updateQuantity,
  onDelete
}) => {
  // const variant: ProductVariants = item?.promotionVariants?.find(pv => pv?.variantId === item.id)

  // const getVariant = (promotionVariants?: (PromotionVariants | null)[] | null | undefined): ProductVariants | null => {

  //   const variant = item?.promotionVariants?.find(pv => pv?.variantId === item.id)
  //   return variant
  // }

  const getPrice = (): number => {
    // const variant = getVariant(item.promotionVariants);
    if (!item?.promotionVariants) return item.price
    const promotionPrice = item?.promotionVariants[0]?.promotionPrice
    if (!promotionPrice) return item.price
    return promotionPrice
  }

  const price = getPrice()

  const handleQuantityChange = (quantity: number) => {
    updateQuantity(item.id, quantity)
  }

  const handleRemoveRequest = () => {
    onDelete(item.id)
  }

  return (
    <div key={item.id} className="flex flex-col items-center space-y-2">
      <div className="relative h-20 w-20 flex-shrink-0">
        <Image
          src={item.image}
          alt={item.name}
          fill
          sizes="80px"
          className="object-cover"
        />
      </div>
      <p className="text-sm font-bold text-primary">{formatPrice(price)}</p>
      <div className="mt-2 flex items-center">
        <PlusMinusButton
          allowRemove={true}
          stock={item.stock}
          initialQuantity={item.quantity}
          onQuantityChange={handleQuantityChange}
          onRemoveRequest={handleRemoveRequest} // Nueva prop
          size="sm"
        />
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/ui/CartContent/CartContentThin/CartContentThinPurchase.tsx
------------------------------------------------------------------------------------
import { formatPrice } from '@/helpers/utils'
import Link from 'next/link'
import { type FC } from 'react'

interface CartContentThinPurchaseProps {
  totalPrice: number
  onClose: () => void
}

export const CartContentThinPurchase: FC<CartContentThinPurchaseProps> = ({
  totalPrice
}) => {
  return (
    <>
      <div>
        <div className="mb-2 flex justify-center">
          {/* <span className="font-medium">Subtotal:</span> */}
          <span className="text-sm font-bold">
            {formatPrice(Number(totalPrice))}
          </span>
        </div>
        <Link
          href="/checkout"
          className="flex w-full justify-center bg-primary py-1.5 text-[15px] font-semibold text-white transition-colors hover:bg-primary/90"
        >
          Continuar
        </Link>
        <Link
          href="/cart"
          className="mt-2 flex w-full justify-center border border-gray-300 py-1.5 text-[15px] font-semibold transition-colors hover:bg-gray-50"
        >
          Ir al carrito
        </Link>
      </div>
      <div className="border-b border-gray-200"></div>
    </>
  )
}



üìÅ ARCHIVO: src/components/ui/CartContent/CartContentThin/index.ts
------------------------------------------------------------------------------------
export * from './CartContentThin'



üìÅ ARCHIVO: src/components/ui/CartContent/CartContentThin/CartContentThinEmpty.tsx
------------------------------------------------------------------------------------
import { ShoppingBag } from 'lucide-react'

export const CartContentThinEmpty = () => {
  return (
    <div className="flex h-full">
      <div className="flex flex-grow flex-col items-center justify-center p-4">
        <ShoppingBag className="mb-4 h-16 w-16 text-gray-300" />
        <p className="text-center text-gray-500">Tu carrito est√° vac√≠o.</p>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/ui/CartContent/CartContentPurchase.tsx
------------------------------------------------------------------------------------
import { formatPrice } from '@/helpers/utils'
import Link from 'next/link'
import { type FC } from 'react'

interface CartContentPurchaseProps {
  totalPrice: number
  onClose: () => void
}

export const CartContentPurchase: FC<CartContentPurchaseProps> = ({
  totalPrice
}) => {
  return (
    <div className="mt-auto border-t border-gray-200 p-4">
      <div className="mb-4 flex justify-between">
        <span className="font-medium">Subtotal:</span>
        <span className="font-bold">{formatPrice(Number(totalPrice))}</span>
      </div>
      <Link
        href="/checkout"
        className="flex w-full justify-center bg-primary py-3 text-white transition-colors hover:bg-primary/90"
      >
        Continuar
      </Link>
      <Link
        href="/cart"
        className="mt-2 flex w-full justify-center border border-gray-300 py-3 transition-colors hover:bg-gray-50"
      >
        Ir al carrito
      </Link>
    </div>
  )
}



üìÅ ARCHIVO: src/components/ui/CartContent/CartContent.tsx
------------------------------------------------------------------------------------
'use client'
import { CartContentEmpty } from '@/components/ui/CartContent/CartContentEmpty'
import { CartContentItem } from '@/components/ui/CartContent/CartContentItem'
import { CartContentPurchase } from '@/components/ui/CartContent/CartContentPurchase'
import { type CartItem } from '@/hooks/useCart'
import React, { type JSX } from 'react'

interface CartContentProps {
  items: CartItem[]
  totalPrice: number
  removeItem: (id: number) => void
  updateQuantity: (id: number, quantity: number) => void
  onClose: () => void
}

export const CartContent: React.FC<CartContentProps> = ({
  items,
  totalPrice,
  removeItem,
  updateQuantity,
  onClose
}): JSX.Element => {
  const hasNotItems = items.length === 0

  if (hasNotItems) {
    return <CartContentEmpty />
  }

  return (
    <div className="flex h-full flex-col">
      <CartContentPurchase onClose={onClose} totalPrice={totalPrice} />
      <div className="flex h-full max-h-[calc(100%-179px)] flex-col">
        <div className="flex-grow overflow-auto p-4">
          {items.map((item, key) => (
            <CartContentItem
              key={key}
              item={item}
              removeItem={removeItem}
              updateQuantity={updateQuantity}
            />
          ))}
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/ui/CartContent/index.ts
------------------------------------------------------------------------------------
export * from './CartContent'



üìÅ ARCHIVO: src/components/ui/CartContent/CartContentItem.tsx
------------------------------------------------------------------------------------
import { PlusMinusButton } from '@/components/ui/PlusMinusButton'
import { formatPrice } from '@/helpers/utils'
import { type CartItem } from '@/hooks/useCart'
import { Trash2 } from 'lucide-react'
import Image from 'next/image'
import { type FC } from 'react'

interface CartContentItemProps {
  item: CartItem
  removeItem: (id: number) => void
  updateQuantity: (id: number, quantity: number) => void
}

export const CartContentItem: FC<CartContentItemProps> = ({
  item,
  updateQuantity,
  removeItem
}) => {
  return (
    <div key={item.id} className="flex border-b border-gray-100 py-4">
      <div className="relative h-20 w-20 flex-shrink-0">
        <Image
          src={item.image}
          alt={item.name}
          fill
          sizes="80px"
          className="object-cover"
        />
      </div>
      <div className="ml-4 flex-grow">
        <h3 className="font-medium">{item.name}</h3>
        <p className="font-bold text-primary">{formatPrice(item.price)}</p>
        <div className="mt-2 flex items-center">
          <PlusMinusButton
            stock={item.stock}
            initialQuantity={item.quantity}
            onQuantityChange={(quantity: number) => { updateQuantity(item.id, quantity) }
            }
            size="sm"
          />
          <button
            onClick={() => { removeItem(item.id) }}
            className="ml-auto rounded-full p-1 text-red-500 hover:bg-red-50"
            aria-label="Eliminar producto"
          >
            <Trash2 className="h-5 w-5" />
          </button>
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/ui/PasswordField/PasswordField.tsx
------------------------------------------------------------------------------------
// components/PasswordField.tsx
'use client'

import { Input, type InputProps } from '@/components/ui/Input'
import { Label } from '@/components/ui/Label'
import { Eye, EyeOff } from 'lucide-react'
import { type JSX } from 'react'
import { type PasswordCriterion } from './PasswordField.types'

interface PasswordFieldProps extends Omit<InputProps, 'type' | 'onChange'> {
  label: string
  onChange: (value: string) => void
  showPassword: boolean
  onToggleVisibility: () => void
  error?: string | null
  showRequirements?: boolean
  criteriaStatus?: (criteria: PasswordCriterion) => boolean
  confirmField?: boolean
  matchingPassword?: string
}

export const PasswordField = ({
  id,
  label,
  value,
  onChange,
  showPassword,
  onToggleVisibility,
  error = null,
  disabled = false,
  showRequirements = false,
  criteriaStatus,
  confirmField = false,
  matchingPassword = '',
  className = '',
  ...inputProps
}: PasswordFieldProps): JSX.Element => {
  // Determinar clases de error
  const errorClasses =
    error != null
      ? 'border-red-500 text-red-900 focus:border-red-500 focus:ring-red-500'
      : 'border-gray-300 focus:border-blue-500 focus:ring-blue-500'

  return (
    <div className="space-y-2">
      <Label htmlFor={id} className={error != null ? 'text-red-600' : ''}>
        {label}
        {(inputProps.required ?? false) && (
          <span className="text-red-500"> *</span>
        )}
      </Label>

      <div className="relative">
        <Input
          id={id}
          type={showPassword ? 'text' : 'password'}
          value={value}
          onChange={(e) => {
            onChange(e.target.value)
          }}
          className={`${errorClasses} focus:ring-2 ${className}`}
          placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
          disabled={disabled}
          aria-invalid={!(error == null)}
          aria-describedby={error != null ? `${id}-error` : undefined}
          {...inputProps}
        />

        <button
          type="button"
          onClick={onToggleVisibility}
          className="absolute right-3 top-1/2 -translate-y-1/2 transform text-gray-500 hover:text-gray-700"
          disabled={disabled}
          aria-label={
            showPassword ? 'Ocultar contrase√±a' : 'Mostrar contrase√±a'
          }
        >
          {showPassword ? (
            <EyeOff className="h-4 w-4" />
          ) : (
            <Eye className="h-4 w-4" />
          )}
        </button>
      </div>

      {error != null && (
        <p
          id={`${id}-error`}
          className="mt-1 flex items-center gap-1 text-sm text-red-600"
        >
          <span className="h-1 w-1 rounded-full bg-red-600" />
          {error}
        </p>
      )}

      {confirmField &&
        Array.isArray(value) &&
        typeof value === 'string' &&
        value === matchingPassword && (
          <p className="mt-1 flex items-center gap-1 text-sm text-green-600">
            <span className="h-1 w-1 rounded-full bg-green-600" />
            Las contrase√±as coinciden
          </p>
        )}

      {showRequirements && criteriaStatus != null && (
        <div className="mt-3 space-y-2">
          <p className="text-sm font-medium text-gray-700">
            Requisitos de la contrase√±a:
          </p>
          <div className="space-y-1">
            <PasswordCriterionItem
              met={criteriaStatus('length')}
              text="Al menos 8 caracteres"
            />
            <PasswordCriterionItem
              met={criteriaStatus('uppercase')}
              text="Una letra may√∫scula"
            />
            <PasswordCriterionItem
              met={criteriaStatus('lowercase')}
              text="Una letra min√∫scula"
            />
            <PasswordCriterionItem
              met={criteriaStatus('number')}
              text="Un n√∫mero"
            />
            <PasswordCriterionItem
              met={criteriaStatus('special')}
              text="Un car√°cter especial (!@#$%^&*)"
            />
          </div>
        </div>
      )}
    </div>
  )
}

const PasswordCriterionItem = ({
  met,
  text
}: {
  met: boolean
  text: string
}): JSX.Element => (
  <div
    className={`flex items-center gap-2 text-xs ${met ? 'text-green-600' : 'text-gray-500'}`}
  >
    <div
      className={`h-1.5 w-1.5 rounded-full ${met ? 'bg-green-600' : 'bg-gray-300'}`}
    />
    {text}
  </div>
)



üìÅ ARCHIVO: src/components/ui/PasswordField/index.ts
------------------------------------------------------------------------------------
export * from './PasswordField'



üìÅ ARCHIVO: src/components/ui/PasswordField/PasswordField.types.ts
------------------------------------------------------------------------------------
// components/PasswordField.types.ts
export type PasswordCriterion =
  | 'length'
  | 'uppercase'
  | 'lowercase'
  | 'number'
  | 'special'



üìÅ ARCHIVO: src/components/ui/Breadcrumb.tsx
------------------------------------------------------------------------------------
import { getVariantTitle } from '@/helpers/productVariant.helpers'
import { type Products, type ProductVariants } from '@/types/domain'
import Link from 'next/link'
import { type FC } from 'react'

interface BreadcrumbProps {
  product: Products
  variant: ProductVariants
}

export const Breadcrumb: FC<BreadcrumbProps> = ({ product, variant }) => {
  return (
    <nav className="mb-8">
      <ol className="flex items-center space-x-2 text-sm text-gray-600">
        <li>
          <Link href="/" className="hover:text-primary">
            Inicio
          </Link>
        </li>
        <li>/</li>
        <li>
          <Link href="/search" className="hover:text-primary">
            Productos
          </Link>
        </li>
        <li>/</li>
        <li className="text-gray-900">
          {getVariantTitle(product.name, variant)}
        </li>
      </ol>
    </nav>
  )
}



üìÅ ARCHIVO: src/components/ui/ImageGalleryThumbs.tsx
------------------------------------------------------------------------------------
'use client'
import { type CleanImage } from '@/components/product/ProductVariant.helpers'
import { useImageCarousel } from '@/hooks/useImageCarousel'
import { cn } from '@/lib/utils'
import { ChevronLeft, ChevronRight } from 'lucide-react'
import Image from 'next/image'
import React, { useState } from 'react'

interface ImageGalleryThumbsProps {
  images: CleanImage[]
  productName: string
  className?: string
  onImageClick?: (imageIndex: number) => void
  onImageZoom?: (imageUrl: string) => void
  initialImageIndex?: number
  isInModal?: boolean
  showImageType?: boolean
  thumbsPosition?: 'left' | 'bottom'
}

export const ImageGalleryThumbs: React.FC<ImageGalleryThumbsProps> = ({
  images,
  productName,
  className,
  onImageClick,
  onImageZoom,
  initialImageIndex = 0,
  isInModal = false,
  showImageType = true,
  thumbsPosition = 'left'
}) => {
  // Estado para controlar la fuente de navegaci√≥n
  const [lastNavigationSource, setLastNavigationSource] = useState<
    'arrow' | 'thumbnail' | null
  >(null)

  const {
    currentImageIndex,
    currentImage,
    hasMultipleImages,
    goToNextImage,
    goToPrevImage,
    goToImage
  } = useImageCarousel({
    images,
    initialIndex: initialImageIndex,
    autoSlideInterval: 0, // Sin auto-slide para vista de producto
    autoSlideOnHover: false,
    loop: true,
    preloadImages: true
  })

  // Si no hay im√°genes v√°lidas
  if (!images || images.length === 0) {
    return (
      <div
        className={cn(
          'flex aspect-square items-center justify-center rounded bg-gray-100',
          className
        )}
      >
        <p className="text-gray-500">No hay im√°genes disponibles</p>
      </div>
    )
  }

  const handleImageClick = () => {
    if (!isInModal) {
      onImageClick?.(currentImageIndex)
    } else if (currentImage) {
      onImageZoom?.(currentImage.imageUrlZoom)
    }
  }

  // Navegaci√≥n con flechas
  const handleArrowPrev = () => {
    setLastNavigationSource('arrow')
    goToPrevImage()
    // Reset despu√©s de un tiempo
    setTimeout(() => { setLastNavigationSource(null) }, 300)
  }

  const handleArrowNext = () => {
    setLastNavigationSource('arrow')
    goToNextImage()
    // Reset despu√©s de un tiempo
    setTimeout(() => { setLastNavigationSource(null) }, 300)
  }

  // Navegaci√≥n con thumbnails
  const handleThumbnailClick = (index: number) => {
    setLastNavigationSource('thumbnail')
    goToImage(index)
  }

  const handleThumbnailHover = (index: number) => {
    // Solo cambiar en hover si no se naveg√≥ recientemente con flechas
    if (lastNavigationSource !== 'arrow') {
      goToImage(index)
    }
  }

  const getImageTypeLabel = (imageType?: string): string => {
    const labels: Record<string, string> = {
      front: 'Frontal',
      back: 'Trasera',
      left: 'Lateral Izq.',
      right: 'Lateral Der.',
      top: 'Superior',
      bottom: 'Inferior',
      detail: 'Detalle',
      lifestyle: 'Lifestyle',
      packaging: 'Empaque'
    }
    return labels[imageType || 'front'] || 'Imagen'
  }

  // Layout horizontal (thumbnails abajo)
  if (thumbsPosition === 'bottom') {
    return (
      <div className={cn('space-y-4', className)}>
        {/* Imagen principal */}
        <div
          className={cn(
            'group relative overflow-hidden rounded bg-gray-100',
            !isInModal && 'aspect-square'
          )}
          style={isInModal ? { height: '70vh' } : undefined}
        >
          {currentImage && (
            <Image
              src={currentImage.imageUrlNormal}
              alt={currentImage.altText || productName}
              width={isInModal ? 1200 : 600}
              height={isInModal ? 1200 : 600}
              className={cn(
                'h-full w-full object-contain transition-opacity duration-200',
                !isInModal ? 'cursor-zoom-in' : 'cursor-pointer'
              )}
              onClick={handleImageClick}
              priority
            />
          )}

          {/* Badge del tipo de imagen */}
          {showImageType && currentImage && (
            <div className="absolute bottom-2 left-2 rounded bg-black/70 px-2 py-1 text-xs text-white">
              {getImageTypeLabel(currentImage.imageType)}
            </div>
          )}

          {/* Botones de navegaci√≥n */}
          {hasMultipleImages && (
            <>
              <button
                onClick={handleArrowPrev}
                className="absolute left-2 top-1/2 z-10 flex h-10 w-10 -translate-y-1/2 transform items-center justify-center rounded-full bg-white/80 opacity-0 shadow-md transition-all hover:bg-white group-hover:opacity-100"
                aria-label="Imagen anterior"
              >
                <ChevronLeft className="h-6 w-6" />
              </button>
              <button
                onClick={handleArrowNext}
                className="absolute right-2 top-1/2 z-10 flex h-10 w-10 -translate-y-1/2 transform items-center justify-center rounded-full bg-white/80 opacity-0 shadow-md transition-all hover:bg-white group-hover:opacity-100"
                aria-label="Imagen siguiente"
              >
                <ChevronRight className="h-6 w-6" />
              </button>
            </>
          )}
        </div>

        {/* Thumbnails horizontales */}
        {hasMultipleImages && (
          <div className="flex gap-2 overflow-x-auto pb-2">
            {images.map((image, index) => (
              <button
                key={image.id}
                onMouseEnter={() => { handleThumbnailHover(index) }}
                onClick={() => { handleThumbnailClick(index) }}
                className={cn(
                  'relative flex-shrink-0 overflow-hidden rounded border-2 transition-colors',
                  'h-16 w-16',
                  index === currentImageIndex
                    ? 'border-indigo-600'
                    : 'border-gray-200 hover:border-gray-300'
                )}
                aria-label={`Ver imagen ${index + 1}`}
              >
                <Image
                  src={image.imageUrlThumb}
                  alt={image.altText || `Imagen ${index + 1}`}
                  width={64}
                  height={64}
                  className="h-full w-full object-cover"
                />
              </button>
            ))}
          </div>
        )}
      </div>
    )
  }

  // Layout vertical (thumbnails a la izquierda) - default
  return (
    <div className={cn('flex', isInModal ? 'gap-6' : 'gap-4', className)}>
      {/* Thumbnails verticales */}
      {hasMultipleImages && (
        <div
          className={cn(
            'flex flex-col',
            isInModal ? 'w-24 space-y-3' : 'w-20 space-y-2'
          )}
        >
          {images.map((image, index) => (
            <button
              key={image.id}
              onMouseEnter={() => { handleThumbnailHover(index) }}
              onClick={() => { handleThumbnailClick(index) }}
              className={cn(
                'relative flex-shrink-0 overflow-hidden rounded border-2 transition-colors',
                isInModal ? 'h-20 w-20' : 'h-16 w-16',
                index === currentImageIndex
                  ? 'border-indigo-600'
                  : 'border-gray-200 hover:border-gray-300'
              )}
              aria-label={`Ver imagen ${index + 1}`}
            >
              <Image
                src={image.imageUrlThumb}
                alt={image.altText || `Imagen ${index + 1}`}
                width={isInModal ? 80 : 64}
                height={isInModal ? 80 : 64}
                className="h-full w-full object-cover"
              />
            </button>
          ))}
        </div>
      )}

      {/* Imagen principal */}
      <div className="flex-1">
        <div
          className={cn(
            'group relative overflow-hidden rounded bg-gray-100',
            !isInModal && 'aspect-square'
          )}
          style={isInModal ? { height: '70vh' } : undefined}
        >
          {currentImage && (
            <Image
              src={currentImage.imageUrlNormal}
              alt={currentImage.altText || productName}
              width={isInModal ? 1200 : 600}
              height={isInModal ? 1200 : 600}
              className={cn(
                'h-full w-full object-contain transition-opacity duration-200',
                !isInModal ? 'cursor-zoom-in' : 'cursor-pointer'
              )}
              onClick={handleImageClick}
              priority
            />
          )}

          {/* Badge del tipo de imagen */}
          {showImageType && currentImage && (
            <div className="absolute bottom-2 left-2 rounded bg-black/70 px-2 py-1 text-xs text-white">
              {getImageTypeLabel(currentImage.imageType)}
            </div>
          )}

          {/* Botones de navegaci√≥n */}
          {hasMultipleImages && (
            <>
              <button
                onClick={handleArrowPrev}
                className="absolute left-2 top-1/2 z-10 flex h-10 w-10 -translate-y-1/2 transform items-center justify-center rounded-full bg-white/80 opacity-0 shadow-md transition-all hover:bg-white group-hover:opacity-100"
                aria-label="Imagen anterior"
              >
                <ChevronLeft className="h-6 w-6" />
              </button>
              <button
                onClick={handleArrowNext}
                className="absolute right-2 top-1/2 z-10 flex h-10 w-10 -translate-y-1/2 transform items-center justify-center rounded-full bg-white/80 opacity-0 shadow-md transition-all hover:bg-white group-hover:opacity-100"
                aria-label="Imagen siguiente"
              >
                <ChevronRight className="h-6 w-6" />
              </button>
            </>
          )}

          {/* Indicadores de puntos - solo en modal */}
          {isInModal && hasMultipleImages && (
            <div className="absolute bottom-4 left-1/2 flex -translate-x-1/2 transform space-x-2">
              {images.map((_, index) => (
                <button
                  key={index}
                  onClick={() => { handleThumbnailClick(index) }}
                  className={cn(
                    'h-3 w-3 rounded-full transition-colors',
                    index === currentImageIndex
                      ? 'bg-white'
                      : 'bg-white/50 hover:bg-white/75'
                  )}
                  aria-label={`Ir a imagen ${index + 1}`}
                />
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/ui/Logo.tsx
------------------------------------------------------------------------------------
'use client'
import Image from 'next/image'
import Link from 'next/link'
import { siteConfig } from '@/config'

const Logo = () => {
  return (
    <Link href="/" className="flex cursor-pointer items-center">
      <Image
        width={32}
        height={32}
        alt="logo"
        src={'/Logo.svg'}
        className="mr-2 h-auto w-auto"
      />
      <span className="text-2xl font-extralight text-black md:text-4xl">
        {siteConfig.name}
      </span>
    </Link>
  )
}

export default Logo



üìÅ ARCHIVO: src/components/ui/ServerAuthButton.tsx
------------------------------------------------------------------------------------
import { authOptions } from '@/lib/auth'
import { getServerSession } from 'next-auth'
import ClientAuthButton from './ClientAuthButton'

export default async function ServerAuthButton() {
  // Obtener la sesi√≥n del servidor para el renderizado inicial
  const session = await getServerSession(authOptions)

  const isAuthenticated = !!session

  // Pasar la informaci√≥n inicial al componente de cliente
  return (
    <ClientAuthButton
      initialIsAuthenticated={isAuthenticated}
      initialUserName={session?.user?.name || ''}
      initialUserEmail={session?.user?.email || ''}
      initialUserId={session?.user?.id || ''}
    />
  )
}



üìÅ ARCHIVO: src/components/ui/Badge.tsx
------------------------------------------------------------------------------------
import { cn } from '@/lib/utils'
import { forwardRef } from 'react'

export interface BadgeProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: 'default' | 'secondary' | 'destructive' | 'outline'
}

const Badge = forwardRef<HTMLDivElement, BadgeProps>(
  ({ className, variant = 'default', ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn(
          'focus:ring-ring inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2',
          {
            'text-primary-foreground border-transparent bg-primary hover:bg-primary/80':
              variant === 'default',
            'text-secondary-foreground border-transparent bg-secondary hover:bg-secondary/80':
              variant === 'secondary',
            'bg-destructive text-destructive-foreground hover:bg-destructive/80 border-transparent':
              variant === 'destructive',
            'text-foreground': variant === 'outline'
          },
          className
        )}
        {...props}
      />
    )
  }
)
Badge.displayName = 'Badge'

export { Badge }



üìÅ ARCHIVO: src/components/ui/Button.tsx
------------------------------------------------------------------------------------
import { cn } from '@/lib/utils'
import { forwardRef } from 'react'

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'outline' | 'ghost' | 'destructive'
  size?: 'default' | 'sm' | 'lg'
  asChild?: boolean
}

const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      className,
      variant = 'default',
      size = 'default',
      asChild = false,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? 'span' : 'button'

    return (
      <Comp
        className={cn(
          'focus-visible:ring-ring ring-offset-background inline-flex items-center justify-center text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
          {
            'bg-primary text-white hover:bg-primary/90': variant === 'default',
            'border-input hover:text-accent-foreground border hover:bg-accent':
              variant === 'outline',
            'hover:text-accent-foreground hover:bg-accent': variant === 'ghost',
            'bg-destructive text-destructive-foreground hover:bg-destructive/90':
              variant === 'destructive'
          },
          {
            'h-10 px-4 py-2': size === 'default',
            'h-9 px-3': size === 'sm',
            'h-11 px-8': size === 'lg'
          },
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = 'Button'

export { Button }



üìÅ ARCHIVO: src/components/ui/Modal/ModalContent.tsx
------------------------------------------------------------------------------------
import { cn } from '@/lib/utils'
import { type ReactNode } from 'react'

export const ModalContent = ({
  children,
  className
}: {
  children: ReactNode
  className?: string
}) => {
  return <div className={cn('p-4', className)}>{children}</div>
}



üìÅ ARCHIVO: src/components/ui/Modal/ModalTitle.tsx
------------------------------------------------------------------------------------
import { cn } from '@/lib/utils'
import { X } from 'lucide-react'
import { type FC, type ReactNode } from 'react'

interface ModalTitleProps {
  onClose: () => void
  title?: string
  className?: string
  children?: ReactNode
}

export const ModalTitle: FC<ModalTitleProps> = ({
  onClose,
  title,
  className,
  children
}) => {
  return (
    <div className={cn('border-b border-gray-200 p-4', className)}>
      <div className="flex items-center justify-between">
        {children || <h2 className="text-xl font-bold">{title}</h2>}
        <button
          onClick={onClose}
          className="rounded-full p-2 hover:bg-gray-100"
          aria-label="Cerrar"
        >
          <X className="h-5 w-5" />
        </button>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/ui/Modal/index.ts
------------------------------------------------------------------------------------
export * from './Modal'
export * from './ModalContent'
export * from './ModalTitle'



üìÅ ARCHIVO: src/components/ui/Modal/Modal.tsx
------------------------------------------------------------------------------------
'use client'
import { cn } from '@/lib/utils'
import React, { useEffect, useRef, useState } from 'react'
import { createPortal } from 'react-dom'

interface ModalProps {
  isOpen: boolean
  onClose: () => void
  children: React.ReactNode
  className?: string
}

export const Modal: React.FC<ModalProps> = ({
  isOpen,
  onClose,
  children,
  className
}) => {
  const modalRef = useRef<HTMLDivElement>(null)
  const [mounted, setMounted] = useState(false)
  const [isVisible, setIsVisible] = useState(false)
  const [shouldRender, setShouldRender] = useState(false)

  // üëà ASEGURAR QUE ESTAMOS EN EL CLIENTE
  useEffect(() => {
    setMounted(true)
    return () => { setMounted(false) }
  }, [])

  // üëà MANEJAR ANIMACIONES DE ENTRADA Y SALIDA
  useEffect(() => {
    if (isOpen) {
      setShouldRender(true)
      const timer = setTimeout(() => { setIsVisible(true) }, 10)
      return () => { clearTimeout(timer) }
    } else {
      setIsVisible(false)
      const timer = setTimeout(() => { setShouldRender(false) }, 200)
      return () => { clearTimeout(timer) }
    }
  }, [isOpen])

  // Cerrar al hacer clic fuera
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        isOpen &&
        modalRef.current &&
        !modalRef.current.contains(event.target as Node)
      ) {
        onClose()
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [isOpen, onClose])

  // Prevenir scroll del body cuando est√° abierto
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden'
    } else {
      document.body.style.overflow = 'auto'
    }
    return () => {
      document.body.style.overflow = 'auto'
    }
  }, [isOpen])

  // Manejar tecla Escape para cerrar
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isOpen) {
        onClose()
      }
    }

    window.addEventListener('keydown', handleEscape)
    return () => {
      window.removeEventListener('keydown', handleEscape)
    }
  }, [isOpen, onClose])

  if (!mounted || !shouldRender) return null

  // üëà M√öLTIPLES OPCIONES PARA EL FONDO - ELIGE LA QUE FUNCIONE
  const modalContent = (
    <div
      // Opci√≥n 1: Con bg-black/80 (sintaxis moderna)
      className={cn(
        'fixed inset-0 z-[9999] flex items-center justify-center p-4',
        'transition-all duration-200 ease-out',
        isVisible ? 'bg-black/98' : 'bg-transparent'
      )}
      // üëà OPCI√ìN 2: Forzar con style inline (garantizado)
      style={{
        backgroundColor: isVisible ? 'rgba(0, 0, 0, 0.7)' : 'transparent'
      }}
    >
      <div
        ref={modalRef}
        className={cn(
          'w-full max-w-md overflow-hidden bg-white px-10 py-5 shadow-xl',
          'transform transition-all duration-200 ease-out',
          isVisible
            ? 'translate-y-0 scale-100 opacity-100'
            : 'translate-y-4 scale-95 opacity-0',
          className
        )}
        role="dialog"
        aria-modal="true"
      >
        {children}
      </div>
    </div>
  )

  return createPortal(modalContent, document.body)
}



üìÅ ARCHIVO: src/components/ui/Toast.tsx
------------------------------------------------------------------------------------
'use client'
import { cn } from '@/lib/utils'
import React, { useEffect, useState } from 'react'
import { createPortal } from 'react-dom'

type ToastPosition =
  | 'bottom-right'
  | 'bottom-left'
  | 'bottom-center'
  | 'top-right'
  | 'top-left'
  | 'top-center'
  | 'center'

interface ToastProps {
  message: string
  className?: string
  position?: ToastPosition
}

const Toast: React.FC<ToastProps> = ({
  message,
  className,
  position = 'bottom-right'
}) => {
  const [isVisible, setIsVisible] = useState(false)
  const [mounted, setMounted] = useState(false)

  // üëà ASEGURAR QUE ESTAMOS EN EL CLIENTE
  useEffect(() => {
    setMounted(true)
    return () => { setMounted(false) }
  }, [])

  useEffect(() => {
    // Mostrar el toast con una peque√±a animaci√≥n
    setIsVisible(true)

    // Ocultar el toast despu√©s de 3 segundos
    const timer = setTimeout(() => {
      setIsVisible(false)
    }, 2700) // Un poco menos que el tiempo en useCart para que la animaci√≥n termine antes

    return () => { clearTimeout(timer) }
  }, [message])

  // üëà CLASES DE POSICIONAMIENTO
  const getPositionClasses = (pos: ToastPosition) => {
    const positions = {
      'bottom-right': 'bottom-4 right-4',
      'bottom-left': 'bottom-4 left-4',
      'bottom-center': 'bottom-4 left-1/2 transform -translate-x-1/2',
      'top-right': 'top-4 right-4',
      'top-left': 'top-4 left-4',
      'top-center': 'top-4 left-1/2 transform -translate-x-1/2',
      center: 'left-0 right-0 top-0 bottom-0'
    }
    return positions[pos]
  }

  // üëà ANIMACI√ìN SEG√öN POSICI√ìN
  const getAnimationClasses = (pos: ToastPosition, visible: boolean) => {
    const animations = {
      'bottom-right': visible
        ? 'translate-y-0 opacity-100'
        : 'translate-y-10 opacity-0',
      'bottom-left': visible
        ? 'translate-y-0 opacity-100'
        : 'translate-y-10 opacity-0',
      'bottom-center': visible
        ? 'translate-y-0 opacity-100'
        : 'translate-y-10 opacity-0',
      'top-right': visible
        ? 'translate-y-0 opacity-100'
        : '-translate-y-10 opacity-0',
      'top-left': visible
        ? 'translate-y-0 opacity-100'
        : '-translate-y-10 opacity-0',
      'top-center': visible
        ? 'translate-y-0 opacity-100'
        : '-translate-y-10 opacity-0',
      center: visible
        ? 'translate-y-0 opacity-100'
        : '-translate-y-10 opacity-0'
    }
    return animations[pos]
  }

  // üëà NO RENDERIZAR SI NO EST√Å MONTADO
  if (!mounted) return null

  // üëà CONTENIDO DEL TOAST
  const toastContent = (
    <div
      className={cn(
        'fixed z-[9999] rounded-lg bg-secondary px-4 py-3 text-white shadow-lg transition-all duration-300',
        getPositionClasses(position),
        getAnimationClasses(position, isVisible),
        className
      )}
      role="alert"
      aria-live="polite"
    >
      <div className="flex items-center">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          className="mr-2 h-5 w-5"
          viewBox="0 0 20 20"
          fill="currentColor"
          aria-hidden="true"
        >
          <path
            fillRule="evenodd"
            d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"
            clipRule="evenodd"
          />
        </svg>
        <p>{message}</p>
      </div>
    </div>
  )

  // üëà USAR PORTAL PARA RENDERIZAR EN document.body
  return createPortal(toastContent, document.body)
}

export default Toast



üìÅ ARCHIVO: src/components/ui/Navigation.tsx
------------------------------------------------------------------------------------
'use client'
import { type Categories } from '@/types/domain'
import { Menu, Percent } from 'lucide-react'
import Link from 'next/link'
import React, { useState } from 'react'
import CategoriesMenu from './CategoriesMenu'
import SlidePage from './SlidePage'

type ButtonType = 'mini' | 'normal'
interface NavigationProps {
  categories: Categories[]
  type?: ButtonType
}

const Navigation: React.FC<NavigationProps> = ({
  categories,
  type = 'normal'
}) => {
  const [isCategoriesMenuOpen, setIsCategoriesMenuOpen] = useState(false)

  if (type === 'mini') {
    return (
      <>
        <button
          className="flex items-center gap-2 rounded-sm bg-primary px-2 py-2 text-white transition-colors hover:bg-primary/90"
          onClick={() => { setIsCategoriesMenuOpen(true) }}
        >
          <Menu className="h-5 w-5" />
        </button>
        <SlidePage
          isOpen={isCategoriesMenuOpen}
          onClose={() => { setIsCategoriesMenuOpen(false) }}
          title="Categor√≠as"
          direction="left"
          width={400}
        >
          <CategoriesMenu
            categories={categories}
            onClose={() => { setIsCategoriesMenuOpen(false) }}
          />
        </SlidePage>
      </>
    )
  }

  return (
    <div className="border-t border-none border-gray-200 bg-gray-100">
      <div className="mx-auto max-w-screen-4xl px-12">
        <div className="flex items-center">
          {/* Bot√≥n de categor√≠as que abre el SlidePage */}

          <div className="relative">
            <button
              className="flex items-center gap-2 bg-primary px-6 py-3 text-white transition-colors hover:bg-primary/90"
              onClick={() => { setIsCategoriesMenuOpen(true) }}
            >
              <Menu className="h-5 w-5" />
              <span>Categor√≠as</span>
            </button>
          </div>

          {/* Main Navigation */}
          <nav className="flex items-center gap-8 px-6">
            {/* <Link
              href="/search"
              className="text-gray-700 hover:text-primary transition-colors duration-300 flex items-center gap-2"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                className="h-4 w-4"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                />
              </svg>
              Buscar
            </Link> */}
            <Link
              href="/ofertas"
              className="flex items-center gap-2 text-gray-700 transition-colors duration-300 hover:text-primary"
            >
              <Percent className="h-4 w-4" />
              Ofertas
            </Link>
            {categories
              .filter((categorie) => categorie.parentId === null)
              .map((categorie, index) => (
                <Link
                  key={index}
                  href={`/categoria/${categorie.id}`}
                  className="text-gray-700 transition-colors duration-300 hover:text-primary"
                >
                  {categorie.name}
                </Link>
              ))}

            {/* <Link
              href="/nuevos"
              className="text-gray-700 hover:text-primary transition-colors duration-300"
            >
              Nuevos Productos
            </Link>
            <Link
              href="/marcas"
              className="text-gray-700 hover:text-primary transition-colors duration-300"
            >
              Marcas
            </Link>
            <Link
              href="/vendedores"
              className="text-gray-700 hover:text-primary transition-colors duration-300"
            >
              Vendedores
            </Link>
            <Link
              href="/blog"
              className="text-gray-700 hover:text-primary transition-colors duration-300"
            >
              Blog
            </Link>
            <Link
              href="/contacto"
              className="text-gray-700 hover:text-primary transition-colors duration-300"
            >
              Contacto
            </Link> */}
          </nav>
        </div>
      </div>

      {/* SlidePage para el men√∫ de categor√≠as */}
      <SlidePage
        isOpen={isCategoriesMenuOpen}
        onClose={() => { setIsCategoriesMenuOpen(false) }}
        title="Categor√≠as"
        direction="left"
        width={400}
      >
        <CategoriesMenu
          categories={categories}
          onClose={() => { setIsCategoriesMenuOpen(false) }}
        />
      </SlidePage>
    </div>
  )
}

export default Navigation



üìÅ ARCHIVO: src/components/ui/Textarea.tsx
------------------------------------------------------------------------------------
import { cn } from '@/lib/utils'
import { forwardRef } from 'react'

export type TextareaProps = React.TextareaHTMLAttributes<HTMLTextAreaElement>

const Textarea = forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          'border-input bg-background ring-offset-background placeholder:text-muted-foreground focus-visible:ring-ring flex min-h-[80px] w-full rounded-md border px-3 py-2 text-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = 'Textarea'

export { Textarea }



üìÅ ARCHIVO: src/components/ui/Input.tsx
------------------------------------------------------------------------------------
import { cn } from '@/lib/utils'
import { forwardRef } from 'react'

export type InputProps = React.InputHTMLAttributes<HTMLInputElement>

const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          'border-input bg-background ring-offset-background placeholder:text-muted-foreground focus-visible:ring-ring flex h-10 w-full border px-3 py-2 text-sm file:border-0 file:bg-transparent file:text-sm file:font-medium focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = 'Input'

export { Input }



üìÅ ARCHIVO: src/components/ui/ImageGalleryDots.tsx
------------------------------------------------------------------------------------
'use client'
import { type CleanImage } from '@/components/product/ProductVariant.helpers'
import { useImageCarousel } from '@/hooks/useImageCarousel'
import { cn } from '@/lib/utils'
import Image from 'next/image'
import React from 'react'

interface ImageGalleryDotsProps {
  images: CleanImage[]
  productName: string
  className?: string
  mouseZoneDetection?: boolean // ‚úÖ Nueva prop
  showDotsIndicator?: boolean
  showImageCounter?: boolean
  showZoneIndicator?: boolean // Para debugging
  onImageClick?: (imageIndex: number) => void
}

export const ImageGalleryDots: React.FC<ImageGalleryDotsProps> = ({
  images,
  productName,
  className = 'w-full aspect-square overflow-hidden relative bg-gray-50 rounded',
  mouseZoneDetection = false, // ‚úÖ Por defecto desactivado
  showDotsIndicator = true,
  showImageCounter = false,
  showZoneIndicator = false,
  onImageClick
}) => {
  const {
    currentImageIndex,
    currentImage,
    hasMultipleImages,
    handleMouseEnter,
    handleMouseLeave,
    handleMouseMove, // ‚úÖ Nuevo handler
    goToImage,
    totalImages,
    containerRef, // ‚úÖ Ref que necesitas usar
    currentZone,
    isHovering
  } = useImageCarousel({
    images,
    initialIndex: 0,
    mouseZoneDetection, // ‚úÖ Pasar la prop
    loop: true,
    preloadImages: true
  })

  // Si no hay im√°genes, mostrar placeholder
  if (!images || images.length === 0) {
    return (
      <div className={className}>
        <div className="flex h-full w-full items-center justify-center bg-gray-100">
          <span className="text-sm text-gray-400">Sin im√°genes</span>
        </div>
      </div>
    )
  }

  const handleClick = () => {
    onImageClick?.(currentImageIndex)
  }

  return (
    <div
      ref={containerRef} // ‚úÖ AQU√ç usas el containerRef
      className={className}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      onMouseMove={handleMouseMove} // ‚úÖ Agregar el handler de mouse move
    >
      {/* Imagen actual */}
      {currentImage && (
        <div
          className="relative h-full w-full cursor-pointer"
          onClick={handleClick}
        >
          <Image
            src={currentImage.imageUrlNormal}
            alt={
              currentImage.altText ||
              `${productName} - Imagen ${currentImageIndex + 1}`
            }
            fill
            sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
            className="object-contain transition-opacity duration-200"
            priority={currentImageIndex === 0}
          />
        </div>
      )}

      {/* Precargar im√°genes siguientes (ocultas) */}
      {images.map(
        (image, idx) =>
          idx !== currentImageIndex && (
            <div
              key={`preload-${idx}`}
              className="pointer-events-none absolute inset-0 opacity-0"
            >
              <Image
                src={image.imageUrlNormal}
                alt={image.altText || ''}
                fill
                sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                className="object-contain"
              />
            </div>
          )
      )}

      {/* Indicadores de puntos */}
      {showDotsIndicator && hasMultipleImages && (
        <div className="absolute bottom-2 left-1/2 z-40 flex -translate-x-1/2 transform gap-1.5 rounded-full bg-black/20 px-2 py-1">
          {images.map((_, idx) => (
            <button
              key={idx}
              className={cn(
                'h-2 w-2 rounded-full transition-all duration-200',
                currentImageIndex === idx
                  ? 'scale-110 bg-white'
                  : 'bg-white/60 hover:bg-white/80'
              )}
              onClick={(e) => {
                e.stopPropagation()
                goToImage(idx)
                e.preventDefault()
              }}
              aria-label={`Ver imagen ${idx + 1}`}
            />
          ))}
        </div>
      )}

      {/* Contador de im√°genes */}
      {showImageCounter && hasMultipleImages && (
        <div className="absolute right-2 top-2 rounded bg-black/60 px-2 py-1 text-xs text-white">
          {currentImageIndex + 1}/{totalImages}
        </div>
      )}
    </div>
  )
}



üìÅ ARCHIVO: src/components/sections/Newsletter.tsx
------------------------------------------------------------------------------------
import { siteConfig } from '@/config'
import Image from 'next/image'
import React from 'react'

const Newsletter: React.FC = () => {
  return (
    <section className="bg-gray-100 py-16">
      <div className="mx-auto max-w-screen-4xl px-12">
        <div className="relative overflow-hidden bg-secondary p-8 md:p-12">
          <div className="relative z-10 max-w-2xl">
            <h2 className="mb-4 text-3xl font-bold text-white md:text-4xl">
              Mantente en casa y consigue tu entrega diaria desde nuestra tienda
            </h2>
            <p className="mb-8 text-gray-200">
              Comienza tus compras diarias con {siteConfig.name}
            </p>
            <div className="flex gap-4">
              <div className="relative max-w-md flex-1">
                <input
                  type="email"
                  placeholder="Tu direcci√≥n de email"
                  className="w-full px-4 py-3"
                />
                <button className="absolute right-2 top-1/2 -translate-y-1/2 bg-accent px-6 py-2 text-white transition-colors hover:bg-accent/90">
                  Suscribirse
                </button>
              </div>
            </div>
          </div>
          <div className="absolute right-0 top-0 hidden h-full w-1/3 md:block">
            <Image
              src="https://images.unsplash.com/photo-1542838132-92c53300491e?w=400&h=400&fit=crop"
              alt="Delivery"
              width={500}
              height={500}
              className="h-full w-full object-cover"
            />
          </div>
        </div>
      </div>
    </section>
  )
}

export default Newsletter



üìÅ ARCHIVO: src/components/sections/DailyDeals.tsx
------------------------------------------------------------------------------------
import { type ProductSearchItem } from '@/backend/search'
import ProductCard from '@/components/ui/ProductCard'
import { ChevronRight } from 'lucide-react'
import Image from 'next/image'
import React from 'react'

interface DailyDealsProps {
  bannerImage?: string
  bannerTitle?: string
  products: ProductSearchItem[]
}

const DailyDeals: React.FC<DailyDealsProps> = ({
  bannerImage = 'https://images.unsplash.com/photo-1542291026-7eec264c27ff',
  bannerTitle = 'Trae la naturaleza a tu hogar',
  products
}) => {
  return (
    <section className="py-8">
      <div className="mb-6 flex items-center justify-between">
        <h2 className="text-2xl font-bold">Mejores Ventas del D√≠a</h2>
        <div className="flex items-center gap-4">
          <span className="text-gray-600">Termina en:</span>
          <div className="flex gap-2">
            {['10d', '22h', '57m', '28s'].map((time, index) => (
              <div key={index} className="px-0 py-1 text-gray-700">
                {index === 0 ? <></> : <span className="pr-2">:</span>}
                <span className="font-bold">{time}</span>
              </div>
            ))}
          </div>
        </div>
      </div>

      <div className="grid grid-cols-1 gap-6 md:grid-cols-12">
        {/* Banner */}
        <div className="md:col-span-2">
          <div className="relative h-[400px] overflow-hidden md:h-full">
            <Image
              src={bannerImage}
              alt="Daily Deals"
              fill
              sizes="(max-width: 768px) 100vw, 25vw"
              className="object-cover"
              priority
            />
            <div className="absolute inset-0 flex flex-col justify-end bg-gradient-to-t from-black/80 to-transparent p-6">
              <h3 className="mb-2 text-2xl font-bold text-white">
                {bannerTitle}
              </h3>
              <button className="inline-flex items-center gap-2 border border-white px-6 py-2 text-white transition-colors hover:bg-white hover:text-black">
                Comprar ahora
                <ChevronRight className="h-4 w-4" />
              </button>
            </div>
          </div>
        </div>

        {/* Products Grid */}
        <div className="md:col-span-10">
          <div className="grid grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-5">
            {products?.map((item) => (
              <ProductCard key={item.variantId || item.id} product={item} />
            )) || (
              <div className="col-span-4 py-8 text-center text-gray-500">
                No hay ofertas disponibles
              </div>
            )}
          </div>
        </div>
      </div>
    </section>
  )
}

export default DailyDeals



üìÅ ARCHIVO: src/components/sections/Features.tsx
------------------------------------------------------------------------------------
import { type Feature } from '@/services/features'
import { Clock, Percent } from 'lucide-react'
import React from 'react'

interface FeaturesProps {
  features: Feature[]
}

const Features: React.FC<FeaturesProps> = ({ features }) => {
  const renderIcon = (iconName: string) => {
    switch (iconName) {
      case 'shipping':
        return (
          <svg
            className="h-6 w-6 text-primary"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4"
            />
          </svg>
        )
      case 'discount':
        return <Percent className="h-6 w-6 text-primary" />
      case 'delivery':
        return <Clock className="h-6 w-6 text-primary" />
      case 'secure':
        return (
          <svg
            className="h-6 w-6 text-primary"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"
            />
          </svg>
        )
      default:
        return null
    }
  }

  return (
    <section className="mx-auto max-w-screen-4xl py-6">
      <div className="grid grid-cols-4 gap-6">
        {features.map((feature, index) => (
          <div key={index} className="flex items-center gap-4 bg-gray-50 p-4">
            <div className="flex h-12 w-12 items-center justify-center rounded-full bg-primary/10">
              {renderIcon(feature.icon)}
            </div>
            <div>
              <h4 className="font-semibold">{feature.title}</h4>
              <p className="text-sm text-gray-600">{feature.description}</p>
            </div>
          </div>
        ))}
      </div>
    </section>
  )
}

export default Features



üìÅ ARCHIVO: src/components/sections/FeaturedCategories.tsx
------------------------------------------------------------------------------------
import { type FeaturedCategory } from '@/services/featuredCategories'
import { ChevronRight } from 'lucide-react'
import Image from 'next/image'
import Link from 'next/link'
import React from 'react'

interface FeaturedCategoriesProps {
  categories: FeaturedCategory[]
}

const FeaturedCategories: React.FC<FeaturedCategoriesProps> = ({
  categories
}) => {
  return (
    <section className="py-8">
      <h2 className="mb-6 text-2xl font-bold">Categor√≠as Destacadas</h2>
      <div className="grid grid-cols-1 gap-6 md:grid-cols-3">
        {categories.map((category, index) => (
          <div key={index} className="group relative h-48 overflow-hidden">
            <Image
              src={category.image ? category.image : '/no-image.webp'}
              alt={category.title}
              fill
              sizes="(max-width: 768px) 100vw, 33vw"
              className="object-cover"
              priority={index < 2}
            />

            <div className="absolute inset-0 flex flex-col justify-end bg-gradient-to-r from-black/70 to-transparent p-6">
              <h3 className="mb-1 text-xl font-bold text-white">
                {category.title}
              </h3>
              <p className="text-gray-200">{category.subtitle}</p>
              <Link
                href={
                  category.link ||
                  `/categoria/${category.title
                    .toLowerCase()
                    .replace(/\s+/g, '-')}`
                }
                className="mt-4 inline-flex w-fit items-center gap-2 border border-white px-4 py-2 text-white transition-colors hover:bg-white hover:text-black"
              >
                Comprar ahora
                <ChevronRight className="h-4 w-4" />
              </Link>
            </div>
          </div>
        ))}
      </div>
    </section>
  )
}

export default FeaturedCategories



üìÅ ARCHIVO: src/components/sections/PopularProducts.tsx
------------------------------------------------------------------------------------
import { type ProductComplete } from '@/backend/product'
import ProductCard from '@/components/ui/ProductCard'
import { ChevronRight } from 'lucide-react'
import Link from 'next/link'
import React from 'react'

interface PopularProductsProps {
  products: ProductComplete[]
}

const PopularProducts: React.FC<PopularProductsProps> = ({ products }) => {
  return (
    <section className="py-8">
      <div className="mb-6 flex items-center justify-between">
        <h2 className="text-2xl font-bold">Productos Populares</h2>
        <Link
          href="/populares"
          className="flex items-center gap-1 text-primary hover:text-secondary"
        >
          Ver todos
          <ChevronRight className="h-4 w-4" />
        </Link>
      </div>
      <div className="grid grid-cols-6 gap-6">
        {products?.map((item) => (
          <ProductCard key={item.variantId} product={item} />
        )) || (
          <div className="col-span-5 py-8 text-center text-gray-500">
            No hay productos disponibles
          </div>
        )}
      </div>
    </section>
  )
}

export default PopularProducts



üìÅ ARCHIVO: src/components/sections/Categories.tsx
------------------------------------------------------------------------------------
import { type MainCategory } from '@/services/mainCategories'
import { ShoppingBag } from 'lucide-react'
import Image from 'next/image'
import Link from 'next/link'
import React from 'react'

interface CategoriesProps {
  categories: MainCategory[]
}

const Categories: React.FC<CategoriesProps> = ({ categories }) => {
  return (
    <section className="bg-gray-50 py-12">
      <div className="mb-10 text-center">
        <div className="mb-4 flex items-center justify-center gap-3">
          <ShoppingBag className="h-8 w-8 text-primary" />
          <h2 className="font-roboto text-3xl font-bold text-gray-900">
            Explora Nuestras Categor√≠as
          </h2>
        </div>
        <p className="font-roboto mx-auto max-w-2xl text-lg text-gray-600">
          Descubre la mejor tecnolog√≠a organizada por categor√≠as para encontrar
          exactamente lo que necesitas
        </p>
      </div>

      <div className="grid grid-cols-2 gap-6 md:grid-cols-4 lg:grid-cols-5">
        {categories.map((category) => (
          <Link
            key={category.name}
            href={`/categoria/${category.name.toLowerCase()}`}
            className="group border border-gray-100 bg-white p-6 transition-all duration-300 hover:-translate-y-1 hover:shadow-lg"
          >
            <div className="flex flex-col items-center text-center">
              <div className="mb-4 rounded-full bg-gray-50 p-4 transition-colors group-hover:bg-primary/10">
                {category.image === null ? (
                  <Image
                    alt={category.name}
                    src="/no-image.webp"
                    width={60}
                    height={60}
                    className=""
                  />
                ) : (
                  <Image
                    src={category.image}
                    width={60}
                    height={60}
                    alt={category.name}
                    className="transition-transform duration-300 group-hover:scale-110"
                  />
                )}
              </div>
              <span className="text-sm font-semibold text-gray-800 transition-colors group-hover:text-primary">
                {category.name}
              </span>
            </div>
          </Link>
        ))}
      </div>
    </section>
  )
}

export default Categories



üìÅ ARCHIVO: src/components/sections/HeroSlider.tsx
------------------------------------------------------------------------------------
'use client'
import { type Hero } from '@/services/hero'
import { ChevronLeft, ChevronRight } from 'lucide-react'
import Image from 'next/image'
import Link from 'next/link'
import React, { useState } from 'react'

interface SideBanner {
  title: string
  subtitle: string
  image: string
  link: string
}

interface HeroSliderProps {
  slides: Hero[]
  sideBanners?: SideBanner[]
}

const HeroSlider: React.FC<HeroSliderProps> = ({
  slides,
  sideBanners = []
}) => {
  const [currentSlide, setCurrentSlide] = useState(0)

  const nextSlide = () => {
    setCurrentSlide((prev) => (prev + 1) % slides.length)
  }

  const prevSlide = () => {
    setCurrentSlide((prev) => (prev - 1 + slides.length) % slides.length)
  }

  return (
    <section className="relative">
      <div className="mx-auto max-w-screen-4xl py-6">
        <div className="grid grid-cols-12 gap-6">
          {/* Slider */}
          <div className="relative col-span-8 h-[400px] overflow-hidden">
            {slides.map((slide, index) => (
              <div
                key={index}
                className={`absolute inset-0 transition-opacity duration-500 ${
                  index === currentSlide ? 'opacity-100' : 'opacity-0'
                }`}
              >
                <Image
                  src={slide.image}
                  alt={slide.title}
                  fill
                  sizes="(max-width: 768px) 100vw, 66vw"
                  priority={index === 0}
                  className="object-cover"
                />
                <div className="absolute inset-0 bg-gradient-to-r from-black/70 to-transparent">
                  <div className="flex h-full items-center px-12">
                    <div className="max-w-lg">
                      <div className="mb-2 font-medium text-yellow-400">
                        {slide.subtitle}
                      </div>
                      <h1 className="mb-4 text-5xl font-bold text-white">
                        {slide.title}
                      </h1>
                      <p className="mb-6 text-gray-200">{slide.description}</p>
                      <Link
                        href={slide.ctaLink}
                        className="inline-block border border-secondary bg-secondary px-8 py-3 text-white transition-colors hover:border hover:border-secondary hover:bg-transparent"
                      >
                        {slide.cta}
                      </Link>
                    </div>
                  </div>
                </div>
              </div>
            ))}

            {/* Slider Controls */}
            <button
              onClick={prevSlide}
              className="absolute left-4 top-1/2 -translate-y-1/2 rounded-full bg-white/80 p-2 hover:bg-white"
            >
              <ChevronLeft className="h-6 w-6" />
            </button>
            <button
              onClick={nextSlide}
              className="absolute right-4 top-1/2 -translate-y-1/2 rounded-full bg-white/80 p-2 hover:bg-white"
            >
              <ChevronRight className="h-6 w-6" />
            </button>

            {/* Dots */}
            <div className="absolute bottom-4 left-1/2 flex -translate-x-1/2 gap-2">
              {slides.map((_, index) => (
                <button
                  key={index}
                  onClick={() => { setCurrentSlide(index) }}
                  className={`h-3 w-3 rounded-full ${
                    index === currentSlide ? 'bg-white' : 'bg-white/50'
                  }`}
                />
              ))}
            </div>
          </div>

          {/* Side Banners */}
          {sideBanners.length > 0 && (
            <div className="col-span-4 space-y-4">
              {sideBanners.map((banner, index) => (
                <div key={index} className="relative h-[192px] overflow-hidden">
                  <Image
                    src={banner.image}
                    alt={banner.title}
                    fill
                    sizes="(max-width: 768px) 100vw, 33vw"
                    className="object-cover"
                  />
                  <div className="absolute inset-0 bg-gradient-to-r from-black/60 to-transparent p-6">
                    <div className="mb-1 font-medium text-yellow-400">
                      {banner.subtitle}
                    </div>
                    <h3 className="mb-2 text-xl font-bold text-white">
                      {banner.title}
                    </h3>
                    <Link
                      href={banner.link}
                      className="text-white hover:underline"
                    >
                      Ver m√°s
                    </Link>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    </section>
  )
}

export default HeroSlider



üìÅ ARCHIVO: src/components/auth/AuthModals.tsx
------------------------------------------------------------------------------------
'use client'
import LoginCustomerForm from '@/components/LoginCustomerForm'
import RegisterCustomerForm from '@/components/RegisterCustomerForm'
import { Modal } from '@/components/ui/Modal'
import { ModalContent } from '@/components/ui/Modal/ModalContent'
import { ModalTitle } from '@/components/ui/Modal/ModalTitle'
import { type JSX } from 'react'

interface AuthModalsProps {
  isLoginOpen: boolean
  isRegisterOpen: boolean
  closeAll: () => void
  onLoginSuccess: () => void
  onRegisterSuccess: () => void
  onSwitchToRegister: () => void
  onSwitchToLogin: () => void
}

export function AuthModals({
  isLoginOpen,
  isRegisterOpen,
  closeAll,
  onLoginSuccess,
  onRegisterSuccess,
  onSwitchToRegister,
  onSwitchToLogin
}: AuthModalsProps): JSX.Element {
  return (
    <>
      <Modal isOpen={isLoginOpen} onClose={closeAll} className="max-w-lg">
        <ModalTitle onClose={closeAll} title="Iniciar sesi√≥n" />
        <ModalContent>
          <LoginCustomerForm
            onSuccess={onLoginSuccess}
            onClose={closeAll}
            onSwitchToRegister={onSwitchToRegister}
          />
        </ModalContent>
      </Modal>
      <Modal isOpen={isRegisterOpen} onClose={closeAll} className="max-w-lg">
        <ModalTitle onClose={closeAll} title="Crear cuenta" />
        <ModalContent>
          <RegisterCustomerForm
            onSuccess={onRegisterSuccess}
            onClose={closeAll}
            onSwitchToLogin={onSwitchToLogin}
          />
        </ModalContent>
      </Modal>
    </>
  )
}



üìÅ ARCHIVO: src/components/payment/PaymentPage.tsx
------------------------------------------------------------------------------------
// üìÑ components/payment/PaymentPage.tsx
'use client'

import {
  AlertCircle,
  ArrowLeft,
  CheckCircle,
  Clock,
  CreditCard,
  MapPin,
  User
} from 'lucide-react'
import { useRouter } from 'next/navigation'
import { useEffect, useState } from 'react'

// Usar tipos del dominio
import {
  type Customers,
  type CustomersAddresses,
  type OrderItems,
  type Orders,
  type PaymentMethods,
  type PaymentTransactions
} from '@/types/domain'

interface PaymentPageData {
  transaction: PaymentTransactions
  order: Orders
  orderItems: OrderItems[]
  customer: Customers
  shippingAddress: CustomersAddresses
  paymentMethod: PaymentMethods
}

interface PaymentPageClientProps {
  transactionId: string
}

// Componentes Sandbox espec√≠ficos por m√©todo de pago
interface SandboxProps {
  onPaymentAction: (action: 'approve' | 'reject', reason?: string) => void
  processing: boolean
  amount: number
  paymentMethod?: string
}

const BankTransferSandbox = ({
  onPaymentAction,
  processing,
  amount
}: SandboxProps) => (
  <div className="space-y-4">
    <div className="rounded-lg border border-blue-200 bg-blue-50 p-3">
      <h5 className="mb-2 font-medium text-blue-800">
        üè¶ Transferencia Bancaria
      </h5>
      <p className="mb-2 text-sm text-blue-700">
        Simula el resultado de una transferencia por S/{' '}
        {Number(amount).toFixed(2)}
      </p>
      <div className="space-y-1 text-xs text-blue-600">
        <p>‚Ä¢ Cuenta: 123-456789-001</p>
        <p>‚Ä¢ CCI: 00312345678900112345</p>
        <p>‚Ä¢ Banco: BCP</p>
      </div>
    </div>

    <div className="grid grid-cols-1 gap-2 sm:grid-cols-3">
      <button
        onClick={() => { onPaymentAction('approve') }}
        disabled={processing}
        className="rounded bg-green-600 px-3 py-2 text-sm text-white hover:bg-green-700 disabled:opacity-50"
      >
        ‚úÖ Transferencia Exitosa
      </button>
      <button
        onClick={() => { onPaymentAction('reject', 'Fondos insuficientes') }}
        disabled={processing}
        className="rounded bg-red-600 px-3 py-2 text-sm text-white hover:bg-red-700 disabled:opacity-50"
      >
        ‚ùå Fondos Insuficientes
      </button>
      <button
        onClick={() => { onPaymentAction('reject', 'Datos incorrectos') }}
        disabled={processing}
        className="rounded bg-orange-600 px-3 py-2 text-sm text-white hover:bg-orange-700 disabled:opacity-50"
      >
        ‚ö†Ô∏è Datos Incorrectos
      </button>
    </div>
  </div>
)

const CardSandbox = ({ onPaymentAction, processing, amount }: SandboxProps) => (
  <div className="space-y-4">
    <div className="rounded-lg border border-purple-200 bg-purple-50 p-3">
      <h5 className="mb-2 font-medium text-purple-800">
        üí≥ Tarjeta de Cr√©dito/D√©bito
      </h5>
      <p className="mb-2 text-sm text-purple-700">
        Simula el resultado del pago con tarjeta por S/ {amount.toFixed(2)}
      </p>
      <div className="space-y-1 text-xs text-purple-600">
        <p>‚Ä¢ Tarjeta: **** **** **** 1234</p>
        <p>‚Ä¢ Vencimiento: 12/25</p>
        <p>‚Ä¢ CVV: ***</p>
      </div>
    </div>

    <div className="grid grid-cols-1 gap-2 sm:grid-cols-4">
      <button
        onClick={() => { onPaymentAction('approve') }}
        disabled={processing}
        className="rounded bg-green-600 px-3 py-2 text-sm text-white hover:bg-green-700 disabled:opacity-50"
      >
        ‚úÖ Aprobado
      </button>
      <button
        onClick={() => { onPaymentAction('reject', 'Tarjeta rechazada') }}
        disabled={processing}
        className="rounded bg-red-600 px-3 py-2 text-sm text-white hover:bg-red-700 disabled:opacity-50"
      >
        ‚ùå Rechazada
      </button>
      <button
        onClick={() => { onPaymentAction('reject', 'Tarjeta expirada') }}
        disabled={processing}
        className="rounded bg-orange-600 px-3 py-2 text-sm text-white hover:bg-orange-700 disabled:opacity-50"
      >
        ‚è∞ Expirada
      </button>
      <button
        onClick={() => { onPaymentAction('reject', 'CVV incorrecto') }}
        disabled={processing}
        className="rounded bg-yellow-600 px-3 py-2 text-sm text-white hover:bg-yellow-700 disabled:opacity-50"
      >
        üîí CVV Error
      </button>
    </div>
  </div>
)

const YapeSandbox = ({ onPaymentAction, processing, amount }: SandboxProps) => (
  <div className="space-y-4">
    <div className="rounded-lg border border-purple-200 bg-purple-50 p-3">
      <h5 className="mb-2 font-medium text-purple-800">üì± Yape</h5>
      <p className="mb-2 text-sm text-purple-700">
        Simula el resultado del pago con Yape por S/ {amount.toFixed(2)}
      </p>
      <div className="space-y-1 text-xs text-purple-600">
        <p>‚Ä¢ N√∫mero: 999 999 999</p>
        <p>‚Ä¢ QR Code generado</p>
        <p>‚Ä¢ C√≥digo de transacci√≥n: YP123456</p>
      </div>
    </div>

    <div className="grid grid-cols-1 gap-2 sm:grid-cols-3">
      <button
        onClick={() => { onPaymentAction('approve') }}
        disabled={processing}
        className="rounded bg-green-600 px-3 py-2 text-sm text-white hover:bg-green-700 disabled:opacity-50"
      >
        ‚úÖ Yape Exitoso
      </button>
      <button
        onClick={() => { onPaymentAction('reject', 'Usuario cancel√≥') }}
        disabled={processing}
        className="rounded bg-red-600 px-3 py-2 text-sm text-white hover:bg-red-700 disabled:opacity-50"
      >
        ‚ùå Usuario Cancel√≥
      </button>
      <button
        onClick={() => { onPaymentAction('reject', 'L√≠mite diario excedido') }}
        disabled={processing}
        className="rounded bg-orange-600 px-3 py-2 text-sm text-white hover:bg-orange-700 disabled:opacity-50"
      >
        ‚ö†Ô∏è L√≠mite Excedido
      </button>
    </div>
  </div>
)

const PlinSandbox = ({ onPaymentAction, processing, amount }: SandboxProps) => (
  <div className="space-y-4">
    <div className="rounded-lg border border-green-200 bg-green-50 p-3">
      <h5 className="mb-2 font-medium text-green-800">üì≤ Plin</h5>
      <p className="mb-2 text-sm text-green-700">
        Simula el resultado del pago con Plin por S/ {amount.toFixed(2)}
      </p>
      <div className="space-y-1 text-xs text-green-600">
        <p>‚Ä¢ N√∫mero: 999 999 999</p>
        <p>‚Ä¢ Banco origen: BCP</p>
        <p>‚Ä¢ C√≥digo de operaci√≥n: PL789012</p>
      </div>
    </div>

    <div className="grid grid-cols-1 gap-2 sm:grid-cols-3">
      <button
        onClick={() => { onPaymentAction('approve') }}
        disabled={processing}
        className="rounded bg-green-600 px-3 py-2 text-sm text-white hover:bg-green-700 disabled:opacity-50"
      >
        ‚úÖ Plin Exitoso
      </button>
      <button
        onClick={() => { onPaymentAction('reject', 'Cuenta no encontrada') }}
        disabled={processing}
        className="rounded bg-red-600 px-3 py-2 text-sm text-white hover:bg-red-700 disabled:opacity-50"
      >
        ‚ùå Cuenta No Encontrada
      </button>
      <button
        onClick={() => { onPaymentAction('reject', 'Servicio no disponible') }}
        disabled={processing}
        className="rounded bg-orange-600 px-3 py-2 text-sm text-white hover:bg-orange-700 disabled:opacity-50"
      >
        ‚ö†Ô∏è Servicio No Disponible
      </button>
    </div>
  </div>
)

const GenericSandbox = ({
  onPaymentAction,
  processing,
  amount,
  paymentMethod
}: SandboxProps) => (
  <div className="space-y-4">
    <div className="rounded-lg border border-gray-200 bg-gray-50 p-3">
      <h5 className="mb-2 font-medium text-gray-800">üí∞ {paymentMethod}</h5>
      <p className="mb-2 text-sm text-gray-700">
        Simula el resultado del pago por S/ {Number(amount).toFixed(2)}
      </p>
    </div>

    <div className="grid grid-cols-1 gap-2 sm:grid-cols-2">
      <button
        onClick={() => { onPaymentAction('approve') }}
        disabled={processing}
        className="rounded bg-green-600 px-3 py-2 text-sm text-white hover:bg-green-700 disabled:opacity-50"
      >
        ‚úÖ Pago Exitoso
      </button>
      <button
        onClick={() => { onPaymentAction('reject', 'Pago rechazado') }}
        disabled={processing}
        className="rounded bg-red-600 px-3 py-2 text-sm text-white hover:bg-red-700 disabled:opacity-50"
      >
        ‚ùå Pago Rechazado
      </button>
    </div>
  </div>
)

export const PaymentPage = ({ transactionId }: PaymentPageClientProps) => {
  const router = useRouter()

  const [data, setData] = useState<PaymentPageData | null>(null)
  const [loading, setLoading] = useState(true)
  const [processing, setProcessing] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [countdown, setCountdown] = useState<number | null>(null)
  const [paymentStatus, setPaymentStatus] = useState<
    'pending' | 'processing' | 'completed' | 'failed'
  >('pending')

  // Cargar datos de pago
  useEffect(() => {
    const fetchPaymentData = async () => {
      try {
        const response = await fetch(`/api/payment/${transactionId}`)

        if (!response.ok) {
          throw new Error('Transaction not found')
        }

        const paymentData = await response.json()
        setData(paymentData)

        // Iniciar countdown si hay expiraci√≥n
        if (paymentData.transaction.expiresAt) {
          const expiryTime = new Date(
            paymentData.transaction.expiresAt
          ).getTime()
          const updateCountdown = () => {
            const now = new Date().getTime()
            const timeLeft = Math.max(0, Math.floor((expiryTime - now) / 1000))
            setCountdown(timeLeft)

            if (timeLeft === 0) {
              setError('La transacci√≥n ha expirado')
            }
          }

          updateCountdown()
          const interval = setInterval(updateCountdown, 1000)
          return () => { clearInterval(interval) }
        }
      } catch (err) {
        setError(
          err instanceof Error ? err.message : 'Error loading payment data'
        )
      } finally {
        setLoading(false)
      }
    }

    fetchPaymentData()
  }, [transactionId])

  const formatTime = (seconds: number): string => {
    const mins = Math.floor(seconds / 60)
    const secs = seconds % 60
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
  }

  // Funci√≥n auxiliar para obtener el nombre del gateway
  const getGatewayName = (code: string): string => {
    const gateways = {
      bank_transfer: 'Manual Transfer System',
      card: 'Visa/Mastercard Gateway',
      yape: 'Yape API',
      plin: 'Plin Gateway',
      default: 'Payment Gateway'
    }
    return gateways[code as keyof typeof gateways] || gateways.default
  }

  // Funci√≥n auxiliar para obtener c√≥digos de error espec√≠ficos
  const getErrorCode = (reason?: string): string => {
    const errorCodes = {
      'Fondos insuficientes': 'INSUFFICIENT_FUNDS',
      'Datos incorrectos': 'INVALID_DATA',
      'Tarjeta rechazada': 'CARD_DECLINED',
      'Tarjeta expirada': 'CARD_EXPIRED',
      'CVV incorrecto': 'INVALID_CVV',
      'Usuario cancel√≥': 'USER_CANCELLED',
      'L√≠mite diario excedido': 'DAILY_LIMIT_EXCEEDED',
      'Cuenta no encontrada': 'ACCOUNT_NOT_FOUND',
      'Servicio no disponible': 'SERVICE_UNAVAILABLE',
      'Pago rechazado': 'PAYMENT_DECLINED'
    }
    return errorCodes[reason as keyof typeof errorCodes] || 'UNKNOWN_ERROR'
  }

  const handlePayment = async (
    action: 'approve' | 'reject',
    reason?: string
  ) => {
    if (!data) return

    setProcessing(true)
    setPaymentStatus('processing')

    try {
      // Simular delay realista seg√∫n el m√©todo de pago
      const delays = {
        bank_transfer: 2000,
        card: 3000,
        yape: 1500,
        plin: 1500,
        default: 2000
      }

      const delay =
        delays[data.paymentMethod.code as keyof typeof delays] || delays.default
      await new Promise((resolve) => setTimeout(resolve, delay))

      const endpoint =
        action === 'approve'
          ? `/api/payment/${transactionId}/complete`
          : `/api/payment/${transactionId}/fail`

      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          gatewayResponse: {
            approved: action === 'approve',
            authCode:
              action === 'approve'
                ? `AUTH_${Math.random().toString(36).substr(2, 9)}`
                : null,
            reason:
              reason ||
              (action === 'reject' ? 'Payment rejected by user' : null),
            processedAt: new Date().toISOString(),
            method: data.paymentMethod.code,
            gateway: getGatewayName(data.paymentMethod.code),
            errorCode: action === 'reject' ? getErrorCode(reason) : null
          }
        })
      })

      if (!response.ok) {
        throw new Error('Error processing payment')
      }

      const result = await response.json()

      if (action === 'approve') {
        setPaymentStatus('completed')

        // Actualizar estado local
        setData((prev) =>
          prev
            ? {
                ...prev,
                transaction: { ...prev.transaction, status: 'completed' },
                order: { ...prev.order, paymentStatus: 'paid' }
              }
            : null
        )

        // Redirigir a confirmaci√≥n despu√©s de 3 segundos
        setTimeout(() => {
          router.push(`/order/${data.order.orderNumber}/confirmation`)
        }, 3000)
      } else {
        setPaymentStatus('failed')

        setData((prev) =>
          prev
            ? {
                ...prev,
                transaction: { ...prev.transaction, status: 'failed' },
                order: { ...prev.order, paymentStatus: 'failed' }
              }
            : null
        )
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Error processing payment')
      setPaymentStatus('failed')
    } finally {
      setProcessing(false)
    }
  }

  if (loading) {
    return (
      <div className="flex min-h-screen items-center justify-center bg-gray-50">
        <div className="h-12 w-12 animate-spin rounded-full border-b-2 border-blue-600"></div>
      </div>
    )
  }

  if (error || !data) {
    return (
      <div className="flex min-h-screen items-center justify-center bg-gray-50">
        <div className="text-center">
          <AlertCircle className="mx-auto mb-4 h-12 w-12 text-red-600" />
          <h2 className="text-xl font-semibold text-gray-900">
            {error || 'Transacci√≥n no encontrada'}
          </h2>
          <p className="mt-2 text-gray-600">
            {error === 'Transaction not found'
              ? 'La transacci√≥n solicitada no existe o ha expirado.'
              : 'Ocurri√≥ un error al cargar los datos de pago.'}
          </p>
          <button
            onClick={() => { router.push('/') }}
            className="mt-4 rounded-lg bg-blue-600 px-6 py-2 text-white hover:bg-blue-700"
          >
            Volver al inicio
          </button>
        </div>
      </div>
    )
  }

  const {
    transaction,
    order,
    orderItems,
    customer,
    shippingAddress,
    paymentMethod
  } = data

  return (
    <div className="mx-auto max-w-6xl px-4 py-8">
      {/* Header */}
      <div className="mb-6">
        <button
          onClick={() => { router.back() }}
          className="mb-4 flex items-center text-blue-600 hover:text-blue-700"
        >
          <ArrowLeft className="mr-2 h-4 w-4" />
          Volver
        </button>
        <h1 className="text-3xl font-bold text-gray-900">Completa tu Pago</h1>
        <p className="text-gray-600">Confirma tu pedido #{order.orderNumber}</p>
      </div>

      {/* Status Alerts */}
      {paymentStatus === 'processing' && (
        <div className="mb-6 rounded-lg border border-blue-200 bg-blue-50 p-4">
          <div className="flex items-center">
            <div className="mr-3 h-5 w-5 animate-spin rounded-full border-b-2 border-blue-600"></div>
            <div>
              <h3 className="font-semibold text-blue-800">
                Procesando Pago...
              </h3>
              <p className="text-blue-700">
                Tu pago est√° siendo procesado con {data.paymentMethod.name}. Por
                favor espera.
              </p>
            </div>
          </div>
        </div>
      )}

      {paymentStatus === 'completed' && (
        <div className="mb-6 rounded-lg border border-green-200 bg-green-50 p-4">
          <div className="flex items-center">
            <CheckCircle className="mr-3 h-5 w-5 text-green-600" />
            <div>
              <h3 className="font-semibold text-green-800">
                ¬°Pago Completado!
              </h3>
              <p className="text-green-700">
                Tu pedido ha sido confirmado. Ser√°s redirigido en breve...
              </p>
            </div>
          </div>
        </div>
      )}

      {paymentStatus === 'failed' && (
        <div className="mb-6 rounded-lg border border-red-200 bg-red-50 p-4">
          <div className="flex items-center">
            <AlertCircle className="mr-3 h-5 w-5 text-red-600" />
            <div>
              <h3 className="font-semibold text-red-800">Pago Rechazado</h3>
              <p className="text-red-700">
                El pago no pudo ser procesado. Por favor, intenta nuevamente.
              </p>
            </div>
          </div>
        </div>
      )}

      <div className="grid grid-cols-1 gap-6 lg:grid-cols-3">
        {/* Payment Section */}
        <div className="space-y-6 lg:col-span-2">
          {/* Payment Method Card */}
          <div className="rounded-lg border bg-white p-6 shadow-sm">
            <div className="mb-6 flex items-center justify-between">
              <h2 className="flex items-center text-xl font-semibold text-gray-900">
                <CreditCard className="mr-2 h-5 w-5" />
                M√©todo de Pago
              </h2>
              {countdown !== null && countdown > 0 && (
                <div className="flex items-center text-orange-600">
                  <Clock className="mr-1 h-4 w-4" />
                  <span className="font-mono text-sm">
                    {formatTime(countdown)}
                  </span>
                </div>
              )}
            </div>

            <div className="mb-6 rounded-lg border p-4">
              <div className="flex items-center justify-between">
                <div>
                  <h3 className="font-medium text-gray-900">
                    {paymentMethod.name}
                  </h3>
                  <p className="text-sm text-gray-600">
                    {paymentMethod.description}
                  </p>
                  <p className="mt-1 text-xs text-gray-500">
                    Ref: {transaction.referenceNumber}
                  </p>
                </div>
                <div className="text-right">
                  <p className="text-2xl font-bold text-gray-900">
                    S/ {Number(transaction.amount).toFixed(2)}
                  </p>
                  <p className="text-sm text-gray-600">
                    {transaction.currency}
                  </p>
                  {transaction.processingFee &&
                    transaction.processingFee > 0 && (
                      <p className="text-xs text-gray-500">
                        + S/ {Number(transaction.processingFee).toFixed(2)}{' '}
                        comisi√≥n
                      </p>
                    )}
                </div>
              </div>
            </div>

            {/* Estado de procesamiento durante transacci√≥n */}
            {processing && (
              <div className="mb-6 rounded-lg border border-blue-200 bg-blue-50 p-4">
                <div className="flex items-center justify-center">
                  <div className="mr-3 h-6 w-6 animate-spin rounded-full border-b-2 border-blue-600"></div>
                  <div className="text-center">
                    <h4 className="font-medium text-blue-800">
                      Procesando con {paymentMethod.name}
                    </h4>
                    <p className="text-sm text-blue-700">
                      {paymentMethod.code === 'bank_transfer' &&
                        'Verificando transferencia bancaria...'}
                      {paymentMethod.code === 'card' &&
                        'Validando tarjeta con el banco...'}
                      {paymentMethod.code === 'yape' &&
                        'Conectando con Yape...'}
                      {paymentMethod.code === 'plin' &&
                        'Procesando con Plin...'}
                      {!['bank_transfer', 'card', 'yape', 'plin'].includes(
                        paymentMethod.code
                      ) && 'Procesando pago...'}
                    </p>
                  </div>
                </div>
              </div>
            )}

            {/* Sandbox Payment Simulation */}
            {transaction.status === 'pending' && !processing && (
              <div className="mb-6 rounded-lg border border-yellow-200 bg-yellow-50 p-4">
                <h4 className="mb-2 font-medium text-yellow-800">
                  üß™ Sandbox de Pagos
                </h4>
                <p className="mb-4 text-sm text-yellow-700">
                  Simula diferentes estados de pago para{' '}
                  <strong>{paymentMethod.name}</strong>
                </p>

                {/* Simulaciones espec√≠ficas por m√©todo de pago */}
                {paymentMethod.code === 'bank_transfer' && (
                  <BankTransferSandbox
                    onPaymentAction={handlePayment}
                    processing={processing}
                    amount={transaction.amount}
                  />
                )}

                {paymentMethod.code === 'card' && (
                  <CardSandbox
                    onPaymentAction={handlePayment}
                    processing={processing}
                    amount={transaction.amount}
                  />
                )}

                {paymentMethod.code === 'yape' && (
                  <YapeSandbox
                    onPaymentAction={handlePayment}
                    processing={processing}
                    amount={transaction.amount}
                  />
                )}

                {paymentMethod.code === 'plin' && (
                  <PlinSandbox
                    onPaymentAction={handlePayment}
                    processing={processing}
                    amount={transaction.amount}
                  />
                )}

                {/* M√©todo gen√©rico para otros tipos */}
                {!['bank_transfer', 'card', 'yape', 'plin'].includes(
                  paymentMethod.code
                ) && (
                  <GenericSandbox
                    onPaymentAction={handlePayment}
                    processing={processing}
                    amount={transaction.amount}
                    paymentMethod={paymentMethod.name}
                  />
                )}
              </div>
            )}

            {/* Payment Details */}
            <div className="space-y-3">
              <div className="flex justify-between">
                <span className="text-gray-600">Subtotal:</span>
                <span>S/ {order.subtotal.toFixed(2)}</span>
              </div>

              {order.discountAmount && order.discountAmount > 0 && (
                <div className="flex justify-between text-green-600">
                  <span>Descuento:</span>
                  <span>-S/ {order.discountAmount.toFixed(2)}</span>
                </div>
              )}

              <div className="flex justify-between">
                <span className="text-gray-600">Env√≠o:</span>
                <span>S/ {(order.shippingCost || 0).toFixed(2)}</span>
              </div>

              <div className="flex justify-between">
                <span className="text-gray-600">IGV (18%):</span>
                <span>S/ {(order.taxAmount || 0).toFixed(2)}</span>
              </div>

              {transaction.processingFee && transaction.processingFee > 0 && (
                <div className="flex justify-between text-gray-600">
                  <span>Comisi√≥n de procesamiento:</span>
                  <span>S/ {Number(transaction.processingFee).toFixed(2)}</span>
                </div>
              )}

              <div className="border-t pt-3">
                <div className="flex justify-between text-lg font-semibold">
                  <span>Total a pagar:</span>
                  <span>S/ {Number(transaction.amount).toFixed(2)}</span>
                </div>
              </div>
            </div>
          </div>

          {/* Customer Info */}
          <div className="rounded-lg border bg-white p-6 shadow-sm">
            <h3 className="mb-4 flex items-center text-lg font-semibold text-gray-900">
              <User className="mr-2 h-5 w-5" />
              Informaci√≥n del Cliente
            </h3>

            <div className="grid grid-cols-2 gap-4">
              <div>
                <p className="text-sm text-gray-600">Nombre completo</p>
                <p className="font-medium">
                  {customer.name || ''} {customer.lastname}
                </p>
              </div>
              <div>
                <p className="text-sm text-gray-600">DNI</p>
                <p className="font-medium">{customer.dni}</p>
              </div>
              <div>
                <p className="text-sm text-gray-600">Email</p>
                <p className="font-medium">{customer.email}</p>
              </div>
              <div>
                <p className="text-sm text-gray-600">Tel√©fono</p>
                <p className="font-medium">{customer.phone}</p>
              </div>
            </div>
          </div>

          {/* Shipping Address */}
          <div className="rounded-lg border bg-white p-6 shadow-sm">
            <h3 className="mb-4 flex items-center text-lg font-semibold text-gray-900">
              <MapPin className="mr-2 h-5 w-5" />
              Direcci√≥n de Env√≠o
            </h3>

            <div className="space-y-2">
              <p className="font-medium">{shippingAddress.alias}</p>
              <p className="text-gray-700">
                {shippingAddress.streetName} {shippingAddress.streetNumber}
                {shippingAddress.apartment && `, ${shippingAddress.apartment}`}
              </p>
              <p className="text-gray-700">
                {shippingAddress.district}, {shippingAddress.province}
              </p>
              <p className="text-gray-700">{shippingAddress.department}</p>
              <p className="text-sm text-gray-600">
                M√©todo de env√≠o: {order.shippingMethod || 'No especificado'}
              </p>
              <p className="text-sm text-gray-600">
                Entrega estimada:{' '}
                {order.estimatedDelivery
                  ? new Date(order.estimatedDelivery).toLocaleDateString(
                      'es-PE'
                    )
                  : 'Por determinar'}
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/layout/TopBar.tsx
------------------------------------------------------------------------------------
import { siteConfig } from '@/config'

export default function TopBar() {
  return (
    <div className="bg-slate-700 py-2 text-white">
      <div className="mx-auto flex max-w-7xl items-center justify-between px-4 text-sm">
        <div className="flex items-center gap-6">
          <a href="#" className="hover:underline">
            Sobre Nosotros
          </a>
          <a href="#" className="hover:underline">
            Mi Cuenta
          </a>
          <a href="#" className="hover:underline">
            Wishlist
          </a>
          <a href="#" className="hover:underline">
            Rastrear Pedido
          </a>
        </div>
        <div className="flex items-center gap-4">
          <span>Necesitas ayuda? Llama: {siteConfig.contact.phone}</span>
          <select className="border-none bg-transparent text-white">
            <option>Espa√±ol</option>
            <option>English</option>
          </select>
          <select className="border-none bg-transparent text-white">
            <option>PEN</option>
            <option>USD</option>
          </select>
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/layout/Footer.tsx
------------------------------------------------------------------------------------
import { siteConfig } from '@/config'
import { Clock, MapPin, Monitor } from 'lucide-react'
import Link from 'next/link'

interface FooterSection {
  title: string
  links: Array<{
    name: string
    href: string
  }>
}

interface SocialLink {
  name: string
  icon: string
  href: string
}

interface FooterProps {
  sections: FooterSection[]
  socialLinks: SocialLink[]
}

const Footer = async ({ sections, socialLinks }: FooterProps) => {
  // Aqu√≠ podr√≠as hacer fetch de datos adicionales si fuera necesario
  // const additionalData = await fetchAdditionalData();

  return (
    <footer className="border-t border-gray-300 bg-white">
      <div className="mx-auto max-w-screen-4xl px-12 py-12">
        <div className="grid grid-cols-5 gap-8">
          {/* Company Info */}
          <div className="col-span-2">
            <Link href="/" className="mb-4 flex items-center gap-2">
              <Monitor className="h-8 w-8 text-primary" />
              <span className="text-2xl font-bold text-primary">
                {siteConfig.name}
              </span>
            </Link>
            <p className="mb-4 text-gray-600">{siteConfig.description}</p>
            <div className="mb-6 space-y-2">
              <p className="flex items-center gap-2 text-gray-600">
                <MapPin className="h-4 w-4" />
                {siteConfig.contact.address}
              </p>
              <p className="flex items-center gap-2 text-gray-600">
                <Clock className="h-4 w-4" />
                Atenci√≥n: Lun-Vie 9:00-20:00
              </p>
            </div>
            <div className="flex gap-4">
              {socialLinks.map((link) => (
                <a
                  key={link.name}
                  href={link.href}
                  className="flex h-10 w-10 items-center justify-center rounded-full bg-secondary text-white hover:bg-opacity-90"
                  aria-label={link.name}
                  dangerouslySetInnerHTML={{ __html: link.icon }}
                />
              ))}
            </div>
          </div>

          {/* Footer Sections */}
          {sections.map((section) => (
            <div key={section.title}>
              <h3 className="mb-4 font-bold text-gray-900">{section.title}</h3>
              <ul className="space-y-2">
                {section.links.map((link) => (
                  <li key={link.name}>
                    <Link
                      href={link.href}
                      className="text-gray-600 transition-colors duration-300 hover:text-primary"
                    >
                      {link.name}
                    </Link>
                  </li>
                ))}
              </ul>
            </div>
          ))}

          {/* Install App */}
          <div>
            <h3 className="mb-4 font-bold text-gray-900">Instalar App</h3>
            <p className="mb-4 text-gray-600">Desde App Store o Google Play</p>
            <div className="mb-6 space-y-3">
              <a href="#" className="block">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/3/3c/Download_on_the_App_Store_Badge.svg"
                  alt="App Store"
                  className="h-10"
                />
              </a>
              <a href="#" className="block">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/7/78/Google_Play_Store_badge_EN.svg"
                  alt="Google Play"
                  className="h-10"
                />
              </a>
            </div>
            <p className="mb-2 text-gray-600">Medios de pago seguros</p>
            <div className="flex gap-2">
              <img
                src="https://upload.wikimedia.org/wikipedia/commons/0/04/Visa.svg"
                alt="Visa"
                className="h-8"
              />
              <img
                src="https://upload.wikimedia.org/wikipedia/commons/a/a4/Mastercard_2019_logo.svg"
                alt="Mastercard"
                className="h-8"
              />
              <img
                src="https://upload.wikimedia.org/wikipedia/commons/b/b5/PayPal.svg"
                alt="PayPal"
                className="h-8"
              />
            </div>
          </div>
        </div>
      </div>
      {/* Bottom Footer */}
      <div className="border-t border-gray-300">
        <div className="mx-auto max-w-screen-4xl px-12 py-4">
          <div className="flex flex-col items-center justify-between md:flex-row">
            <p className="mb-4 text-gray-600 md:mb-0">
              ¬© {new Date().getFullYear()} {siteConfig.name}. Todos los
              derechos reservados
            </p>
            <div className="flex items-center gap-4">
              <p className="text-gray-600">
                L√≠nea de atenci√≥n: {siteConfig.contact.phone}
              </p>
              <p className="text-gray-600">Soporte 24/7</p>
            </div>
          </div>
        </div>
      </div>
    </footer>
  )
}

export default Footer



üìÅ ARCHIVO: src/components/layout/Layout.tsx
------------------------------------------------------------------------------------
import { getFooter } from '@/services/footer'
import React from 'react'
import Footer from './Footer'

interface LayoutProps {
  children: React.ReactNode
}

const Layout: React.FC<LayoutProps> = async ({ children }) => {
  const footer = await getFooter()

  return (
    <>
      {children}
      <Footer sections={footer.sections} socialLinks={footer.socialLinks} />
    </>
  )
}

export default Layout



üìÅ ARCHIVO: src/components/layout/LayoutContent.tsx
------------------------------------------------------------------------------------
import { cn } from '@/lib/utils'
import { type FC, type ReactNode } from 'react'

interface LayoutContentProps {
  children: ReactNode
  className?: string
}
export const LayoutContent: FC<LayoutContentProps> = ({
  children,
  className
}) => {
  return (
    <div
      className="min-h-screen bg-white transition-all duration-300 ease-in-out"
      id="content-page"
    >
      <div className={cn('px-12 py-4', className)}>{children}</div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/layout/Header.tsx
------------------------------------------------------------------------------------
import { Heart } from 'lucide-react'
import { type ReactNode } from 'react'
import CartButton from '../ui/CartButton'
import Logo from '../ui/Logo'
import SearchBar from '../ui/SearchBar'
import ServerAuthButton from '../ui/ServerAuthButton'

interface HeaderProps {
  children?: ReactNode
  navigationType?: 'mini' | 'normal'
}

const Header = async ({ children, navigationType = 'normal' }: HeaderProps) => {
  return (
    <header className="sticky top-0 z-50 border-b border-none border-gray-200 bg-white">
      <div className="mx-auto max-w-screen-4xl px-12 py-4">
        <div className="flex items-center justify-between gap-6">
          <Logo />
          {navigationType === 'mini' && children}

          {/* Search */}
          <SearchBar />

          {/* Actions */}
          <div className="flex items-center gap-6">
            <button className="flex flex-col items-center">
              <Heart className="h-6 w-6" />
              <span className="mt-1 text-xs">Wishlist</span>
            </button>
            <CartButton />
            <ServerAuthButton />
          </div>
        </div>
      </div>
      {navigationType === 'normal' && children}

      {/* <Navigation categories={categories} /> */}
    </header>
  )
}

export default Header



üìÅ ARCHIVO: src/components/RegisterCustomerForm/register-customer-form.hook.ts
------------------------------------------------------------------------------------
import { signIn } from 'next-auth/react'
import { useState } from 'react'
import z from 'zod'
import { RegisterCustomerSchema } from './RegisterCustomer.schema'
import { type RegisterFormData } from './RegisterCustomer.types'

// Definimos un tipo para los criterios de contrase√±a
type PasswordCriterion =
  | 'length'
  | 'uppercase'
  | 'lowercase'
  | 'number'
  | 'special'

interface UseRegisterCustomerFormProps {
  onSuccess?: () => void
  onClose?: () => void
}

interface useRegisterCustomerFormReturn {
  formData: RegisterFormData
  errors: Partial<Record<keyof RegisterFormData, string>>
  message: string
  isLoading: boolean
  showPasswords: {
    password: boolean
    confirmPassword: boolean
  }
  getPasswordCriteriaStatus: (criteria: PasswordCriterion) => boolean
  togglePasswordVisibility: (field: 'password' | 'confirmPassword') => void
  handleInputChange: (field: keyof RegisterFormData, value: string) => void
  handleSubmit: () => Promise<{
    success: boolean
    error?: string
  }>
}

export const useRegisterCustomerForm = ({
  onSuccess,
  onClose
}: UseRegisterCustomerFormProps): useRegisterCustomerFormReturn => {
  const [formData, setFormData] = useState<RegisterFormData>({
    username: '',
    name: '',
    lastname: '',
    email: '',
    password: '',
    confirmPassword: ''
  })

  const [errors, setErrors] = useState<
    Partial<Record<keyof RegisterFormData, string>>
  >({})
  const [isLoading, setIsLoading] = useState(false)
  const [message, setMessage] = useState('')
  const [showPasswords, setShowPasswords] = useState({
    password: false,
    confirmPassword: false
  })

  // Funci√≥n para verificar los criterios de la contrase√±a con tipado seguro
  const getPasswordCriteriaStatus = (criteria: PasswordCriterion): boolean => {
    switch (criteria) {
      case 'length':
        return formData.password.length >= 8
      case 'uppercase':
        return /[A-Z]/.test(formData.password)
      case 'lowercase':
        return /[a-z]/.test(formData.password)
      case 'number':
        return /[0-9]/.test(formData.password)
      case 'special':
        return /[!@#$%^&*]/.test(formData.password)
      default: {
        const exhaustiveCheck: never = criteria
        return exhaustiveCheck
      }
    }
  }

  const togglePasswordVisibility = (
    field: 'password' | 'confirmPassword'
  ): void => {
    setShowPasswords((prev) => ({
      ...prev,
      [field]: !prev[field]
    }))
  }

  const handleInputChange = (
    field: keyof RegisterFormData,
    value: string
  ): void => {
    setFormData((prev) => ({
      ...prev,
      [field]: value
    }))

    // Limpiar error cuando el usuario escribe
    if (errors[field] !== undefined) {
      setErrors((prev) => ({
        ...prev,
        [field]: ''
      }))
    }
  }

  const validateForm = (): boolean => {
    try {
      RegisterCustomerSchema.parse(formData)
      setErrors({})
      return true
    } catch (error) {
      if (error instanceof z.ZodError) {
        const newErrors: Partial<Record<keyof RegisterFormData, string>> = {}
        error.errors.forEach((err) => {
          if (err.path.length > 0 && typeof err.path[0] === 'string') {
            const field = err.path[0] as keyof RegisterFormData
            newErrors[field] = err.message
          }
        })
        setErrors(newErrors)
      }
      return false
    }
  }

  const handleSubmit = async (): Promise<{
    success: boolean
    error?: string
  }> => {
    setMessage('')

    if (!validateForm()) {
      return { success: false }
    }

    setIsLoading(true)

    try {
      const response = await fetch('/api/register', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          username: formData.username,
          name: formData.name,
          lastname: formData.lastname,
          email: formData.email,
          password: formData.password
        })
      })

      const data = await response.json()

      if (!response.ok) {
        const errorMessage =
          'error' in data ? data.error : 'Error al registrar usuario'

        throw new Error(`Error al registrar customer data: ${errorMessage}`)
      }

      // Iniciar sesi√≥n autom√°ticamente
      const result = await signIn('credentials', {
        redirect: false,
        email: formData.email,
        password: formData.password
      })

      if (result?.error != null) {
        throw new Error(result?.error)
      }

      setMessage('Registro exitoso! Redirigiendo...')
      onSuccess?.()
      onClose?.()

      return { success: true }
    } catch (error) {
      const errorMessage =
        error instanceof Error
          ? error.message
          : 'Ocurri√≥ un error al procesar la solicitud'
      setMessage(`Error: ${errorMessage}`)
      return { success: false, error: errorMessage }
    } finally {
      setIsLoading(false)
    }
  }

  return {
    formData,
    errors,
    message,
    isLoading,
    showPasswords,
    getPasswordCriteriaStatus,
    togglePasswordVisibility,
    handleInputChange,
    handleSubmit
  }
}



üìÅ ARCHIVO: src/components/RegisterCustomerForm/RegisterCustomer.schema.ts
------------------------------------------------------------------------------------
import { z } from 'zod'

// Esquema de validaci√≥n extendido
export const RegisterCustomerSchema = z
  .object({
    username: z
      .string()
      .min(3, { message: 'El usuario debe tener al menos 3 caracteres' }),
    name: z.string().min(1, { message: 'El nombre es requerido' }),
    lastname: z.string().min(1, { message: 'El apellido es requerido' }),
    email: z.string().email({ message: 'Correo electr√≥nico inv√°lido' }),
    password: z
      .string()
      .min(8, { message: 'La contrase√±a debe tener al menos 8 caracteres' })
      .regex(/[A-Z]/, { message: 'Debe contener al menos una may√∫scula' })
      .regex(/[a-z]/, { message: 'Debe contener al menos una min√∫scula' })
      .regex(/[0-9]/, { message: 'Debe contener al menos un n√∫mero' })
      .regex(/[!@#$%^&*]/, {
        message: 'Debe contener un car√°cter especial (!@#$%^&*)'
      }),
    confirmPassword: z.string()
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: 'Las contrase√±as no coinciden',
    path: ['confirmPassword']
  })



üìÅ ARCHIVO: src/components/RegisterCustomerForm/index.ts
------------------------------------------------------------------------------------
export { default } from './RegisterCustomerForm'



üìÅ ARCHIVO: src/components/RegisterCustomerForm/RegisterCustomer.types.ts
------------------------------------------------------------------------------------
import type z from 'zod'
import { type RegisterCustomerSchema } from './RegisterCustomer.schema'

export type RegisterFormData = z.infer<typeof RegisterCustomerSchema>



üìÅ ARCHIVO: src/components/RegisterCustomerForm/RegisterCustomerForm.tsx
------------------------------------------------------------------------------------
'use client'
import { Button } from '@/components/ui/Button'
import { InputField } from '@/components/ui/InputField'
import { PasswordField } from '@/components/ui/PasswordField'
import { Loader2 } from 'lucide-react'
import { useRegisterCustomerForm } from './register-customer-form.hook'

interface RegisterCustomerFormProps {
  onSuccess?: () => void
  onClose?: () => void
  onSwitchToLogin?: () => void
}

const RegisterCustomerForm: React.FC<RegisterCustomerFormProps> = ({
  onSuccess,
  onClose,
  onSwitchToLogin
}) => {
  const {
    formData,
    errors,
    message,
    isLoading,
    showPasswords,
    getPasswordCriteriaStatus,
    togglePasswordVisibility,
    handleInputChange,
    handleSubmit
  } = useRegisterCustomerForm({ onSuccess, onClose })

  const handleFormSubmit = async (e: React.FormEvent): Promise<void> => {
    e.preventDefault()
    await handleSubmit()
  }

  return (
    <div className="w-full">
      {message !== '' && (
        <div
          className={`mb-4 rounded-lg p-4 ${
            message.includes('Error')
              ? 'border border-red-200 bg-red-50 text-red-700'
              : 'border border-green-200 bg-green-50 text-green-700'
          }`}
        >
          <div className="flex items-center gap-2">
            <div
              className={`h-2 w-2 rounded-full ${
                message.includes('Error') ? 'bg-red-600' : 'bg-green-600'
              }`}
            ></div>
            {message}
          </div>
        </div>
      )}

      <form onSubmit={handleFormSubmit} className="space-y-4">
        <InputField
          id="username"
          label="Nombre de usuario"
          value={formData.username}
          onChange={(e) => {
            handleInputChange('username', e.target.value)
          }}
          placeholder="juanperez"
          disabled={isLoading}
          error={errors.username}
        />

        <InputField
          id="name"
          label="Nombre"
          value={formData.name}
          onChange={(e) => {
            handleInputChange('name', e.target.value)
          }}
          placeholder="Juan"
          disabled={isLoading}
          error={errors.name}
        />

        <InputField
          id="lastname"
          label="Apellido"
          value={formData.lastname}
          onChange={(e) => {
            handleInputChange('lastname', e.target.value)
          }}
          placeholder="P√©rez"
          disabled={isLoading}
          error={errors.lastname}
        />

        <InputField
          id="email"
          label="Email"
          type="email"
          value={formData.email}
          onChange={(e) => {
            handleInputChange('email', e.target.value)
          }}
          placeholder="usuario@ejemplo.com"
          disabled={isLoading}
          error={errors.email}
        />

        <PasswordField
          id="password"
          label="Contrase√±a"
          value={formData.password}
          onChange={(value) => {
            handleInputChange('password', value)
          }}
          showPassword={showPasswords.password}
          onToggleVisibility={() => {
            togglePasswordVisibility('password')
          }}
          error={errors.password}
          disabled={isLoading}
          showRequirements
          criteriaStatus={getPasswordCriteriaStatus}
        />

        <PasswordField
          id="confirmPassword"
          label="Confirmar contrase√±a"
          value={formData.confirmPassword}
          onChange={(value) => {
            handleInputChange('confirmPassword', value)
          }}
          showPassword={showPasswords.confirmPassword}
          onToggleVisibility={() => {
            togglePasswordVisibility('confirmPassword')
          }}
          error={errors.confirmPassword}
          disabled={isLoading}
          confirmField
          matchingPassword={formData.password}
        />

        <Button
          type="submit"
          disabled={isLoading}
          className="w-full bg-black px-6 py-3 font-medium text-white transition-colors duration-200 hover:bg-gray-800 disabled:cursor-not-allowed disabled:opacity-50"
        >
          {isLoading ? (
            <div className="flex items-center gap-2">
              <Loader2 className="h-4 w-4 animate-spin" />
              Registrando...
            </div>
          ) : (
            'Crear cuenta'
          )}
        </Button>
      </form>

      <div className="mt-6 text-center text-sm text-gray-600">
        ¬øYa tienes una cuenta?{' '}
        <button
          onClick={onSwitchToLogin}
          className="font-medium text-blue-600 hover:text-blue-500"
        >
          Iniciar sesi√≥n
        </button>
      </div>
    </div>
  )
}

export default RegisterCustomerForm



üìÅ ARCHIVO: src/components/product/ProductVariant.helpers.ts
------------------------------------------------------------------------------------
import { type ItemImage } from '@/shared'
import { type ProductVariants, type PromotionVariants } from '@/types/domain'

export interface CleanImage {
  id: number
  imageUrlNormal: string
  imageUrlThumb: string
  imageUrlZoom: string
  altText: string
  imageType: string
  isPrimary?: boolean
  displayOrder: number // ‚úÖ Agregado
}

/**
 * Limpia y valida las im√°genes para el ProductImageSlider
 * @param images Array de im√°genes sin procesar
 * @param productName Nombre del producto para generar alt text
 * @returns Array de im√°genes limpias y validadas
 */
export const cleanAndValidateImages = (
  images: ItemImage[],
  productName: string
): CleanImage[] => {
  if (!images || images.length === 0) {
    return []
  }

  return (
    images
      .filter((image) => image && image.imageUrlNormal) // Filtrar im√°genes v√°lidas
      .map((image, index) => ({
        id: image.id,
        imageUrlNormal: image.imageUrlNormal || '/no-image.webp',
        imageUrlThumb:
          image.imageUrlThumb || image.imageUrlNormal || '/no-image.webp',
        imageUrlZoom:
          image.imageUrlZoom || image.imageUrlNormal || '/no-image.webp',
        altText: image.altText || `${productName} - Imagen ${index + 1}`,
        imageType: image.imageType || 'front',
        isPrimary: Boolean(image.isPrimary),
        displayOrder: image.displayOrder
      }))
      // ordenar por displayOrder
      .sort((a, b) => a.displayOrder - b.displayOrder)
  )
}

/**
 * Encuentra el √≠ndice de la imagen principal
 * @param images Array de im√°genes limpias
 * @returns √çndice de la imagen principal o 0 si no se encuentra
 */
export const findPrimaryImageIndex = (images: CleanImage[]): number => {
  const primaryIndex = images.findIndex((img) => img.isPrimary)
  return primaryIndex !== -1 ? primaryIndex : 0
}

/**
 * Obtiene el texto del tipo de imagen en espa√±ol
 * @param imageType Tipo de imagen
 * @returns Texto en espa√±ol del tipo de imagen
 */
export const getImageTypeLabel = (imageType?: string): string => {
  if (!imageType) return ''
  const labels: Record<string, string> = {
    front: 'Frontal',
    back: 'Trasera',
    left: 'Lateral Izq.',
    right: 'Lateral Der.',
    top: 'Superior',
    bottom: 'Inferior',
    detail: 'Detalle',
    lifestyle: 'Lifestyle',
    packaging: 'Empaque'
  }

  return labels[imageType || 'front'] || 'Imagen'
}

export const getPriceIfHasPromotion = (
  variant: Omit<
    ProductVariants,
    'productId' | 'sku' | 'createdAt' | 'updatedAt'
  >
): {
  hasPromotion: boolean
  finalPrice: number
  originalPrice: number
  currentPromotion?: PromotionVariants | null
} => {
  // Obtener promoci√≥n activa de la variante actual
  const currentPromotion = variant?.promotionVariants?.[0]

  // Calcular precio con promoci√≥n
  const originalPrice = Number(variant?.price || 0)
  const promotionPrice = currentPromotion
    ? Number(currentPromotion.promotionPrice)
    : null
  const finalPrice = promotionPrice || originalPrice

  return {
    finalPrice,
    hasPromotion: Boolean(currentPromotion),
    originalPrice,
    currentPromotion
  }
}



üìÅ ARCHIVO: src/components/product/ProductVariantAttributeSelector.tsx
------------------------------------------------------------------------------------
'use client'
import { type ProductVariantData } from '@/services/product/productVariant'
import { type ProductVariants } from '@/types/domain'
import Image from 'next/image'
import { useRouter } from 'next/navigation'
import React, { useMemo, useState } from 'react'

interface ProductVariantAttributeSelectorProps {
  data: ProductVariantData
  allVariants: ProductVariants[]
  variant?: ProductVariants
  onVariantChange?: (newData: ProductVariantData) => void
  handleVariantChangePreview?: (attributeId: number, optionId: number) => void
  preview?: boolean
}

interface AttributeGroup {
  attributeId: number
  name: string
  displayType: string
  selectedValue: string
  selectedOptionId: number
  availableOptions: Array<{
    optionId: number
    value: string
    variantId: number
    image?: {
      imageUrlThumb: string
      altText?: string
    }
  }>
}

const ProductVariantAttributeSelector: React.FC<
  ProductVariantAttributeSelectorProps
> = ({
  allVariants,
  variant,
  onVariantChange,
  preview = false,
  handleVariantChangePreview
}) => {
  const router = useRouter()

  // Obtener la variante actual desde las variantes del producto usando el ID pasado como prop
  const currentVariant = variant || allVariants[0]

  const [loading, setLoading] = useState(false)

  // Calcular grupos de atributos inmediatamente usando useMemo
  const attributeGroups = useMemo(() => {
    const groups: Record<number, AttributeGroup> = {}

    if (!allVariants || allVariants.length === 0 || !currentVariant) {
      return groups
    }

    // Primero, identificar todos los atributos √∫nicos desde la variante actual
    currentVariant?.variantAttributeOptions?.forEach((vao) => {
      if (vao?.attributeOption?.attribute) {
        const attr = vao.attributeOption.attribute
        const attributeId = attr.id

        if (!groups[attributeId]) {
          groups[attributeId] = {
            attributeId,
            name: attr.name,
            displayType: attr.displayType,
            selectedValue: vao.attributeOption.value,
            selectedOptionId: vao.attributeOption.id,
            availableOptions: []
          }
        }
      }
    })

    // Llenar opciones disponibles para cada atributo desde todas las variantes
    Object.keys(groups).forEach((attrIdStr) => {
      const attributeId = parseInt(attrIdStr)
      const optionsSet = new Set<string>()

      allVariants.forEach((v) => {
        if (!v?.variantAttributeOptions) {
          return
        }

        // Buscar si esta variante tiene este atributo
        const vao = v.variantAttributeOptions.find(
          (vao) => vao?.attributeOption?.attributeId === attributeId
        )

        if (vao?.attributeOption) {
          const optionKey = `${vao.attributeOption.id}-${vao.attributeOption.value}`
          if (!optionsSet.has(optionKey)) {
            optionsSet.add(optionKey)

            // Buscar imagen para esta opci√≥n desde attributeOptionImages
            const optionImage = vao.attributeOption.attributeOptionImages?.[0]

            groups[attributeId].availableOptions.push({
              optionId: vao.attributeOption.id,
              value: vao.attributeOption.value,
              variantId: v.id,
              image: optionImage
                ? {
                    imageUrlThumb: optionImage.imageUrlThumb,
                    altText: optionImage.altText || undefined
                  }
                : undefined
            })
          }
        }
      })
    })

    return groups
  }, [allVariants, currentVariant?.id])

  // Manejar cambio de atributo
  const handleAttributeChange = async (
    attributeId: number,
    optionId: number
  ) => {
    if (preview) {
      handleVariantChangePreview?.(attributeId, optionId)
      return
    }

    // Encontrar la variante que tiene esta opci√≥n espec√≠fica
    const targetVariant = allVariants.find((v) => {
      return v?.variantAttributeOptions?.some(
        (vao) => vao?.attributeOption?.id === optionId
      )
    })

    if (targetVariant && targetVariant.id !== currentVariant?.id) {
      try {
        setLoading(true)

        // Obtener datos completos de la nueva variante
        const response = await fetch(
          `/api/productos/variante/${targetVariant.id}`
        )

        if (response.ok) {
          const newVariantData = await response.json()

          // Actualizar URL sin recargar la p√°gina
          router.push(`/productos/variante/${targetVariant.id}`, {
            scroll: false
          })

          // Notificar al componente padre para actualizar los datos
          onVariantChange?.(newVariantData)
        } else {
          console.error('Error loading variant data:', response.statusText)
        }
      } catch (error) {
        console.error('Error loading variant:', error)
      } finally {
        setLoading(false)
      }
    }
  }

  // Verificar si una opci√≥n est√° disponible considerando las combinaciones v√°lidas
  const isOptionAvailable = (
    attributeId: number,
    optionId: number
  ): boolean => {
    if (!allVariants || allVariants.length === 0 || !currentVariant) {
      return true
    }

    // Obtener los otros atributos de la variante actual (excluyendo el atributo que estamos evaluando)
    const currentOtherAttributes =
      currentVariant.variantAttributeOptions
        ?.filter((vao) => vao?.attributeOption?.attributeId !== attributeId)
        ?.map((vao) => vao?.attributeOption?.id)
        ?.filter(Boolean) || []

    // Buscar si existe alguna variante que tenga esta opci√≥n Y todos los otros atributos actuales
    return allVariants.some((variant) => {
      if (!variant?.variantAttributeOptions) return false

      // Verificar si esta variante tiene la opci√≥n que estamos evaluando
      const hasTargetOption = variant.variantAttributeOptions.some(
        (vao) => vao?.attributeOption?.id === optionId
      )

      if (!hasTargetOption) return false

      // Verificar si esta variante tambi√©n tiene todos los otros atributos actuales
      const variantOptionIds =
        variant.variantAttributeOptions
          ?.map((vao) => vao?.attributeOption?.id)
          ?.filter(Boolean) || []

      return currentOtherAttributes.every((optionId) =>
        variantOptionIds.includes(optionId)
      )
    })
  }

  // Renderizar selector seg√∫n el tipo de display
  const renderAttributeSelector = (group: AttributeGroup) => {
    switch (group.displayType.toLowerCase()) {
      case 'color':
        return (
          <div key={group.attributeId} className="mb-6">
            <h3 className="mb-3 text-sm font-medium text-gray-900">
              {group.name}:{' '}
              <span className="font-normal text-gray-600">
                {group.selectedValue}
              </span>
            </h3>
            <div className="flex flex-wrap gap-3">
              {group.availableOptions.map((option) => {
                const isSelected = group.selectedOptionId === option.optionId
                // const isAvailable = isOptionAvailable(group.attributeId, option.optionId);
                const isAvailable = true

                return (
                  <button
                    key={option.optionId}
                    onClick={async () => {
 await (isAvailable &&
                      handleAttributeChange(group.attributeId, option.optionId))
}
                    }
                    disabled={!isAvailable || loading}
                    className={`relative h-16 w-16 overflow-hidden border-2 ${
                      isSelected
                        ? 'border-primary'
                        : 'border-gray-200 hover:border-gray-500'
                    } ${!isAvailable ? 'cursor-not-allowed opacity-50' : ''} ${loading ? 'opacity-50' : ''}`}
                    title={option.value}
                  >
                    {option.image ? (
                      <Image
                        src={option.image.imageUrlThumb}
                        alt={option.image.altText || option.value}
                        fill
                        sizes="64px"
                        className="object-cover"
                      />
                    ) : (
                      <div className="flex h-full w-full items-center justify-center bg-gray-100 text-xs text-gray-500">
                        {option.value}
                      </div>
                    )}
                  </button>
                )
              })}
            </div>
          </div>
        )

      case 'pills':
        return (
          <div key={group.attributeId} className="mb-6">
            <h3 className="mb-3 text-sm font-medium text-gray-900">
              {group.name}:{' '}
              <span className="font-normal text-gray-600">
                {group.selectedValue}
              </span>
            </h3>
            <div className="flex flex-wrap gap-2">
              {group.availableOptions.map((option) => {
                const isSelected = group.selectedOptionId === option.optionId
                const isAvailable = isOptionAvailable(
                  group.attributeId,
                  option.optionId
                )

                return (
                  <button
                    key={option.optionId}
                    onClick={async () =>
                      await (isAvailable &&
                      handleAttributeChange(group.attributeId, option.optionId))
                    }
                    disabled={!isAvailable || loading}
                    className={`border px-4 py-2 text-sm font-medium ${
                      isSelected
                        ? 'border-primary bg-primary text-white'
                        : 'border-gray-300 bg-white text-gray-700 hover:bg-gray-50'
                    } ${!isAvailable ? 'cursor-not-allowed opacity-50' : ''} ${loading ? 'opacity-50' : ''}`}
                  >
                    {option.value}
                  </button>
                )
              })}
            </div>
          </div>
        )

      case 'radio':
        return (
          <div key={group.attributeId} className="mb-6">
            <h3 className="mb-3 text-sm font-medium text-gray-900">
              {group.name}:{' '}
              <span className="font-normal text-gray-600">
                {group.selectedValue}
              </span>
            </h3>
            <div className="grid grid-cols-3 gap-2">
              {group.availableOptions.map((option) => {
                const isSelected = group.selectedOptionId === option.optionId
                const isAvailable = isOptionAvailable(
                  group.attributeId,
                  option.optionId
                )

                return (
                  <button
                    key={option.optionId}
                    onClick={async () =>
                      await (isAvailable &&
                      handleAttributeChange(group.attributeId, option.optionId))
                    }
                    disabled={!isAvailable || loading}
                    className={`rounded border px-3 py-2 text-sm ${
                      isSelected
                        ? 'border-primary bg-black text-white'
                        : 'border-gray-300 bg-white text-gray-700 hover:bg-gray-50'
                    } ${!isAvailable ? 'cursor-not-allowed opacity-50' : ''} ${loading ? 'opacity-50' : ''}`}
                  >
                    {option.value}
                  </button>
                )
              })}
            </div>
          </div>
        )

      default:
        return (
          <div key={group.attributeId} className="mb-6">
            <label className="mb-2 block text-sm font-medium text-gray-900">
              {group.name}
            </label>
            <select
              value={group.selectedOptionId}
              onChange={async (e) => {
 await handleAttributeChange(
                  group.attributeId,
                  parseInt(e.target.value)
                )
}
              }
              disabled={loading}
              className="block w-full border border-gray-300 bg-white px-3 py-2 shadow-sm focus:border-black focus:outline-none focus:ring-black disabled:opacity-50"
            >
              {group.availableOptions.map((option) => {
                const isAvailable = isOptionAvailable(
                  group.attributeId,
                  option.optionId
                )
                return (
                  <option
                    key={option.optionId}
                    value={option.optionId}
                    disabled={!isAvailable}
                  >
                    {option.value} {!isAvailable && '(No disponible)'}
                  </option>
                )
              })}
            </select>
          </div>
        )
    }
  }

  if (loading && Object.keys(attributeGroups).length === 0) {
    return (
      <div className="space-y-6">
        <div className="animate-pulse">
          <div className="mb-3 h-4 w-1/4 rounded bg-gray-200"></div>
          <div className="flex gap-3">
            <div className="h-16 w-16 rounded-lg bg-gray-200"></div>
            <div className="h-16 w-16 rounded-lg bg-gray-200"></div>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      {Object.values(attributeGroups).map(renderAttributeSelector)}
    </div>
  )
}

export default ProductVariantAttributeSelector



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatings/RatingList.tsx
------------------------------------------------------------------------------------
import { type VariantRatings } from '@/types/domain'
import { RatingItem } from './RatingItem'
import { RatingPagination } from './RatingPagination'

interface RatingListProps {
  ratings: VariantRatings[]
  currentPage: number
  totalPages: number
  onPageChange: (page: number) => void
  activeTab: 'variant' | 'product'
}

export const RatingList: React.FC<RatingListProps> = ({
  ratings,
  currentPage,
  totalPages,
  onPageChange,
  activeTab
}) => {
  if (ratings.length === 0) {
    return (
      <p className="py-4 text-center text-gray-500">
        No hay valoraciones disponibles para{' '}
        {activeTab === 'variant' ? 'esta variante' : 'este producto'}.
      </p>
    )
  }

  return (
    <div className="space-y-4">
      <div className="space-y-0">
        {ratings.map((rating) => (
          <RatingItem key={rating.id} rating={rating} />
        ))}
      </div>

      <RatingPagination
        currentPage={currentPage}
        totalPages={totalPages}
        onPageChange={onPageChange}
      />
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatings/types/ratings.ts
------------------------------------------------------------------------------------
import { type VariantRatings } from '@/types/domain'

// Interfaces para el resumen de valoraciones
export interface RatingSummary {
  averageRating: number
  totalRatings: number
  oneStar: number
  twoStar: number
  threeStar: number
  fourStar: number
  fiveStar: number
}

export interface RatingSearchResultDTO {
  ratings: VariantRatings[]
  summary: RatingSummary
  totalPages: number
  currentPage: number
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatings/RatingPagination.tsx
------------------------------------------------------------------------------------
interface RatingPaginationProps {
  currentPage: number
  totalPages: number
  onPageChange: (page: number) => void
}

export const RatingPagination: React.FC<RatingPaginationProps> = ({
  currentPage,
  totalPages,
  onPageChange
}) => {
  if (totalPages <= 1) return null

  return (
    <div className="mt-6 flex justify-center">
      <nav className="flex items-center space-x-2">
        <button
          onClick={() => { onPageChange(currentPage - 1) }}
          disabled={currentPage === 1}
          className={`rounded border px-3 py-1 ${
            currentPage === 1
              ? 'cursor-not-allowed border-gray-200 text-gray-400'
              : 'border-gray-300 text-gray-700 hover:bg-gray-50'
          }`}
        >
          Anterior
        </button>

        {Array.from({ length: totalPages }, (_, i) => i + 1).map((pageNum) => (
          <button
            key={pageNum}
            onClick={() => { onPageChange(pageNum) }}
            className={`rounded border px-3 py-1 ${
              currentPage === pageNum
                ? 'border-indigo-600 bg-indigo-600 text-white'
                : 'border-gray-300 text-gray-700 hover:bg-gray-50'
            }`}
          >
            {pageNum}
          </button>
        ))}

        <button
          onClick={() => { onPageChange(currentPage + 1) }}
          disabled={currentPage === totalPages}
          className={`rounded border px-3 py-1 ${
            currentPage === totalPages
              ? 'cursor-not-allowed border-gray-200 text-gray-400'
              : 'border-gray-300 text-gray-700 hover:bg-gray-50'
          }`}
        >
          Siguiente
        </button>
      </nav>
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatings/EmptyRatings.tsx
------------------------------------------------------------------------------------
export const EmptyRatings: React.FC = () => {
  return (
    <div className="py-8 text-center">
      <p className="mb-4 text-gray-500">
        Este producto a√∫n no tiene valoraciones.
      </p>
      <p className="text-sm text-gray-400">
        ¬°S√© el primero en valorar este producto!
      </p>
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatings/RatingTabs.tsx
------------------------------------------------------------------------------------
interface RatingTabsProps {
  activeTab: 'variant' | 'product'
  onTabChange: (tab: 'variant' | 'product') => void
  variantCount: number
  productCount: number
}

export const RatingTabs: React.FC<RatingTabsProps> = ({
  activeTab,
  onTabChange,
  variantCount,
  productCount
}) => {
  return (
    <div className="mb-4 border-b border-gray-200">
      <div className="flex">
        <button
          className={`px-4 py-2 text-sm font-medium ${
            activeTab === 'variant'
              ? 'border-b-2 border-indigo-600 text-indigo-600'
              : 'text-gray-500 hover:text-gray-700'
          }`}
          onClick={() => { onTabChange('variant') }}
        >
          Esta variante ({variantCount})
        </button>
        <button
          className={`px-4 py-2 text-sm font-medium ${
            activeTab === 'product'
              ? 'border-b-2 border-indigo-600 text-indigo-600'
              : 'text-gray-500 hover:text-gray-700'
          }`}
          onClick={() => { onTabChange('product') }}
        >
          Todas las variantes ({productCount})
        </button>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatings/RatingSummary.tsx
------------------------------------------------------------------------------------
import { useRatingDisplay } from './hooks/useRatingDisplay'
import { type RatingSummary as IRatingSummary } from './types/ratings'

interface RatingSummaryProps {
  summary: IRatingSummary
}

export const RatingSummary: React.FC<RatingSummaryProps> = ({ summary }) => {
  const { renderStars, renderRatingBar } = useRatingDisplay()

  return (
    <div className="mb-6 bg-gray-50 p-4">
      <div className="flex flex-col gap-6 md:flex-row">
        {/* Puntuaci√≥n promedio */}
        <div className="text-center md:w-1/4">
          <div className="mb-2 text-5xl font-bold text-gray-800">
            {summary.averageRating.toFixed(1)}
          </div>
          <div className="mb-1 flex justify-center">
            {renderStars(summary.averageRating)}
          </div>
          <p className="text-sm text-gray-500">
            {summary.totalRatings} valoraciones
          </p>
        </div>

        {/* Distribuci√≥n de estrellas */}
        <div className="space-y-2 md:w-3/4">
          {renderRatingBar(summary.fiveStar, summary.totalRatings, 5)}
          {renderRatingBar(summary.fourStar, summary.totalRatings, 4)}
          {renderRatingBar(summary.threeStar, summary.totalRatings, 3)}
          {renderRatingBar(summary.twoStar, summary.totalRatings, 2)}
          {renderRatingBar(summary.oneStar, summary.totalRatings, 1)}
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatings/ProductVariantRatings.tsx
------------------------------------------------------------------------------------
'use client'
import { type Products, type ProductVariants } from '@/types/domain'
import React from 'react'
import { ProductVariantRatingAdd } from '../ProductVariantRatingAdd/ProductVariantRatingAdd'
import { EmptyRatings } from './EmptyRatings'
import { useRatingsData } from './hooks/useRatingsData'
import { LoadingState } from './LoadingState'
import { RatingList } from './RatingList'
import { RatingSummary } from './RatingSummary'
import { RatingTabs } from './RatingTabs'

interface ProductVariantRatingsProps {
  variant: ProductVariants
  product: Products
}

export const ProductVariantRatings: React.FC<ProductVariantRatingsProps> = ({
  variant,
  product
}) => {
  const {
    ratings,
    loading,
    activeTab,
    page,
    hasNoRatings,
    handleTabChange,
    handlePageChange,
    handleRatingAdded
  } = useRatingsData({
    variantId: variant.id,
    productId: variant.productId
  })

  const renderContent = () => {
    if (loading && !ratings) {
      return <LoadingState />
    }

    if (hasNoRatings) {
      return <EmptyRatings />
    }

    if (!ratings) return null

    return (
      <>
        <RatingSummary summary={ratings.summary} />

        <RatingTabs
          activeTab={activeTab}
          onTabChange={handleTabChange}
          variantCount={
            activeTab === 'variant' ? ratings.summary.totalRatings : 0
          }
          productCount={
            activeTab === 'product' ? ratings.summary.totalRatings : 0
          }
        />

        <RatingList
          ratings={ratings.ratings}
          currentPage={page}
          totalPages={ratings.totalPages}
          onPageChange={handlePageChange}
          activeTab={activeTab}
        />
      </>
    )
  }

  return (
    <div className="mt-8 border-t border-gray-200 pt-8">
      <h2 className="mb-6 text-xl font-bold">Valoraciones</h2>

      {renderContent()}

      {/* Formulario para a√±adir valoraci√≥n - SIEMPRE se muestra */}
      <ProductVariantRatingAdd
        variant={variant}
        product={product}
        onRatingAdded={handleRatingAdded}
      />
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatings/hooks/useRatingsData.ts
------------------------------------------------------------------------------------
import { useEffect, useState } from 'react'
import { type RatingSearchResultDTO } from './../types/ratings'

interface UseRatingsDataProps {
  variantId: number
  productId: number
}

export const useRatingsData = ({
  variantId,
  productId
}: UseRatingsDataProps) => {
  const [ratings, setRatings] = useState<RatingSearchResultDTO | null>(null)
  const [loading, setLoading] = useState(true)
  const [activeTab, setActiveTab] = useState<'variant' | 'product'>('variant')
  const [page, setPage] = useState(1)

  const fetchRatings = async () => {
    setLoading(true)
    try {
      const response = await fetch(
        `/api/ratings/${activeTab === 'variant' ? 'variant' : 'product'}/${
          activeTab === 'variant' ? variantId : productId
        }?page=${page}`
      )
      if (response.ok) {
        const data = await response.json()
        setRatings(data)
      } else {
        console.error('Error fetching ratings')
      }
    } catch (error) {
      console.error('Error fetching ratings:', error)
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchRatings()
  }, [variantId, productId, activeTab, page])

  const handleTabChange = (tab: 'variant' | 'product') => {
    setActiveTab(tab)
    setPage(1)
  }

  const handlePageChange = (newPage: number) => {
    setPage(newPage)
  }

  const handleRatingAdded = () => {
    setPage(1)
    setLoading(true)
    fetchRatings()
  }

  const hasNoRatings =
    !ratings ||
    (ratings.ratings.length === 0 && ratings.summary.totalRatings === 0)

  return {
    ratings,
    loading,
    activeTab,
    page,
    hasNoRatings,
    handleTabChange,
    handlePageChange,
    handleRatingAdded,
    fetchRatings
  }
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatings/hooks/useRatingDisplay.tsx
------------------------------------------------------------------------------------
import { Star } from 'lucide-react'

export const useRatingDisplay = () => {
  const renderStars = (rating: number) => {
    return (
      <div className="flex">
        {[1, 2, 3, 4, 5].map((star) => (
          <Star
            key={star}
            className={`h-4 w-4 ${
              star <= rating
                ? 'fill-yellow-400 text-yellow-400'
                : 'text-gray-300'
            }`}
          />
        ))}
      </div>
    )
  }

  const renderRatingBar = (count: number, total: number, stars: number) => {
    const percentage = total > 0 ? (count / total) * 100 : 0

    return (
      <div className="flex items-center gap-2">
        <div className="flex w-16 items-center gap-1">
          <span className="text-sm">{stars}</span>
          <Star className="h-3 w-3 fill-yellow-400 text-yellow-400" />
        </div>
        <div className="h-2 flex-1 overflow-hidden rounded-full bg-gray-200">
          <div
            className="h-full rounded-full bg-yellow-400"
            style={{ width: `${percentage}%` }}
          ></div>
        </div>
        <div className="w-10 text-xs text-gray-500">{count}</div>
      </div>
    )
  }

  return {
    renderStars,
    renderRatingBar
  }
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatings/index.ts
------------------------------------------------------------------------------------
export * from './ProductVariantRatings'



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatings/RatingItem.tsx
------------------------------------------------------------------------------------
import { type RatingImages, type VariantRatings } from '@/types/domain'
import { Check, User } from 'lucide-react'
import Image from 'next/image'
import { useRatingDisplay } from './hooks/useRatingDisplay'

interface RatingItemProps {
  rating: VariantRatings
}

export const RatingItem: React.FC<RatingItemProps> = ({ rating }) => {
  const { renderStars } = useRatingDisplay()

  const customer = rating.customer
  const customerName = customer
    ? `${customer.name || ''} ${customer.lastname || ''}`.trim() ||
      customer.username
    : 'Usuario an√≥nimo'

  return (
    <div className="border-b border-gray-200 py-4">
      <div className="mb-2 flex items-start justify-between">
        <div className="flex items-center gap-2">
          {customer?.photo ? (
            <Image
              src={customer.photo}
              alt={customerName}
              width={32}
              height={32}
              className="rounded-full"
            />
          ) : (
            <div className="flex h-8 w-8 items-center justify-center rounded-full bg-gray-200">
              <User className="h-4 w-4 text-gray-500" />
            </div>
          )}
          <div>
            <p className="font-medium">{customerName}</p>
            <div className="flex items-center gap-1">
              {renderStars(rating.rating)}
              <span className="ml-1 text-xs text-gray-500">
                {new Date(rating.createdAt).toLocaleDateString()}
              </span>
            </div>
          </div>
        </div>
        {rating.verifiedPurchase === 1 && (
          <div className="flex items-center text-xs text-green-600">
            <Check className="mr-1 h-3 w-3" />
            Compra verificada
          </div>
        )}
      </div>

      {rating.title && (
        <h4 className="mb-1 font-medium text-gray-800">{rating.title}</h4>
      )}

      {rating.review && (
        <p className="mb-3 text-sm text-gray-700">{rating.review}</p>
      )}

      {rating.ratingImages && rating.ratingImages.length > 0 && (
        <div className="mt-2 flex gap-2 overflow-x-auto pb-2">
          {rating.ratingImages
            .filter((image): image is RatingImages => !!image)
            .map((image) => (
              <div
                key={image.id}
                className="relative h-16 w-16 flex-shrink-0 overflow-hidden rounded-md"
              >
                <Image
                  src={image.imageUrl}
                  alt="Imagen de valoraci√≥n"
                  fill
                  sizes="64px"
                  className="object-cover"
                />
              </div>
            ))}
        </div>
      )}
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatings/LoadingState.tsx
------------------------------------------------------------------------------------
interface LoadingStateProps {
  message?: string
}

export const LoadingState: React.FC<LoadingStateProps> = ({
  message = 'Cargando valoraciones...'
}) => {
  return (
    <div className="py-8 text-center">
      <p className="text-gray-500">{message}</p>
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRating/ProductVariantRating.tsx
------------------------------------------------------------------------------------
import { type ProductVariants as ProductVariant } from '@/types/domain'
import { type FC } from 'react'

interface ProductVariantRatingProps {
  variant: ProductVariant
}

export const ProductVariantRating: FC<ProductVariantRatingProps> = ({
  variant
}) => {
  const calculateAverageRating = () => {
    const ratings = variant?.variantRatings || []
    if (ratings.length === 0) return null

    const sum = ratings.reduce(
      (acc: number, rating: any) => acc + rating.rating,
      0
    )
    return {
      averageRating: sum / ratings.length,
      totalRatings: ratings.length
    }
  }

  const ratingData = calculateAverageRating()

  return (
    <>
      {/* Ratings */}
      {ratingData && (
        <div className="flex items-center space-x-2">
          <div className="flex items-center">
            {[...Array(5)].map((_, i) => (
              <svg
                key={i}
                className={`h-5 w-5 ${i < Math.floor(ratingData.averageRating) ? 'text-yellow-400' : 'text-gray-300'}`}
                fill="currentColor"
                viewBox="0 0 20 20"
              >
                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
              </svg>
            ))}
          </div>
          <span className="text-sm text-gray-600">
            {ratingData.averageRating.toFixed(1)} ({ratingData.totalRatings}{' '}
            rese√±as)
          </span>
        </div>
      )}
    </>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRating/index.ts
------------------------------------------------------------------------------------
export * from './ProductVariantRating'



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatingAdd/RatingStars.tsx
------------------------------------------------------------------------------------
import { Star } from 'lucide-react'

interface RatingStarsProps {
  rating: number
  hoverRating: number
  onRatingClick: (rating: number) => void
  onMouseEnter: (rating: number) => void
  onMouseLeave: () => void
  getRatingText: () => string
}

export const RatingStars: React.FC<RatingStarsProps> = ({
  rating,
  hoverRating,
  onRatingClick,
  onMouseEnter,
  onMouseLeave,
  getRatingText
}) => {
  return (
    <div>
      <label className="mb-1 block text-sm font-medium text-gray-700">
        ¬øC√≥mo valorar√≠as este producto?*
      </label>
      <div className="flex">
        {[1, 2, 3, 4, 5].map((star) => (
          <button
            key={star}
            type="button"
            onClick={() => { onRatingClick(star) }}
            onMouseEnter={() => { onMouseEnter(star) }}
            onMouseLeave={onMouseLeave}
            className="p-1"
          >
            <Star
              className={`h-8 w-8 ${
                (hoverRating || rating) >= star
                  ? 'fill-yellow-400 text-yellow-400'
                  : 'text-gray-300'
              }`}
            />
          </button>
        ))}
      </div>
      {rating > 0 && (
        <div className="mt-1 text-sm text-gray-600">{getRatingText()}</div>
      )}
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatingAdd/ImageUpload.tsx
------------------------------------------------------------------------------------
import { Upload, X } from 'lucide-react'
import Image from 'next/image'

interface ImageUploadProps {
  images: string[]
  onImageUpload: (e: React.ChangeEvent<HTMLInputElement>) => void
  onRemoveImage: (index: number) => void
  maxImages?: number
}

export const ImageUpload: React.FC<ImageUploadProps> = ({
  images,
  onImageUpload,
  onRemoveImage,
  maxImages = 5
}) => {
  return (
    <div>
      <label className="mb-1 block text-sm font-medium text-gray-700">
        A√±adir im√°genes
      </label>
      <div className="mb-2 flex flex-wrap gap-2">
        {images.map((image, index) => (
          <div
            key={index}
            className="relative h-20 w-20 overflow-hidden rounded-md border border-gray-200"
          >
            <Image
              src={image}
              alt={`Imagen ${index + 1}`}
              fill
              className="object-cover"
            />
            <button
              type="button"
              onClick={() => { onRemoveImage(index) }}
              className="absolute right-1 top-1 flex h-5 w-5 items-center justify-center rounded-full bg-white shadow-sm hover:bg-gray-100"
            >
              <X className="h-3 w-3" />
            </button>
          </div>
        ))}
        {images.length < maxImages && (
          <label className="flex h-20 w-20 cursor-pointer flex-col items-center justify-center rounded-md border-2 border-dashed border-gray-300 hover:bg-gray-50">
            <Upload className="h-6 w-6 text-gray-400" />
            <span className="mt-1 text-xs text-gray-500">Subir</span>
            <input
              type="file"
              accept="image/*"
              multiple
              onChange={onImageUpload}
              className="hidden"
            />
          </label>
        )}
      </div>
      <p className="text-xs text-gray-500">
        Puedes subir hasta {maxImages} im√°genes (opcional)
      </p>
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatingAdd/AuthPrompt.tsx
------------------------------------------------------------------------------------
'use client'
import { useAuthModal } from '@/providers/auth-modal'
import { User } from 'lucide-react'

export const AuthPrompt: React.FC = () => {
  const { openLogin, openRegister } = useAuthModal()

  const handleLoginClick = () => {
    console.log('üîê Opening login from rating prompt')
    openLogin({
      onLoginSuccess: () => {
        console.log('‚úÖ Login successful, user can now rate product')
        // La UI se actualizar√° autom√°ticamente porque useSession detectar√° el cambio
      },
      onClose: () => {
        console.log('‚ùå Login cancelled from rating prompt')
      }
    })
    openLogin()
  }

  const handleRegisterClick = () => {
    console.log('üìù Opening register from rating prompt')
    openRegister({
      onRegisterSuccess: () => {
        console.log('‚úÖ Registration successful, user can now rate product')
        // La UI se actualizar√° autom√°ticamente
      },
      onClose: () => {
        console.log('‚ùå Registration cancelled from rating prompt')
      }
    })
  }

  return (
    <div className="border border-blue-200 bg-blue-50 p-6 text-center">
      <User className="mx-auto mb-4 h-12 w-12 text-blue-500" />
      <h3 className="mb-2 text-lg font-semibold text-gray-900">
        Inicia sesi√≥n para valorar este producto
      </h3>
      <p className="mb-4 text-gray-600">
        Necesitas tener una cuenta para poder dejar tu valoraci√≥n y ayudar a
        otros usuarios.
      </p>
      <div className="flex flex-col justify-center gap-3 sm:flex-row">
        <button
          onClick={handleLoginClick}
          className="bg-indigo-600 px-6 py-2 font-medium text-white transition-colors hover:bg-indigo-700"
        >
          Iniciar sesi√≥n
        </button>
        <button
          onClick={handleRegisterClick}
          className="border border-indigo-600 bg-white px-6 py-2 font-medium text-indigo-600 transition-colors hover:bg-gray-50"
        >
          Crear cuenta
        </button>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatingAdd/ProductVariantRatingAdd.tsx
------------------------------------------------------------------------------------
'use client'
import { type ProductVariants, type Products } from '@/types/domain'
import { useSession } from 'next-auth/react'
import React from 'react'
import { AuthPrompt } from './AuthPrompt'
import { useVariantDisplay } from './hooks/useVariantDisplay'
import { RatingForm } from './RatingForm'

interface ProductVariantRatingAddProps {
  variant: ProductVariants
  product: Products
  onRatingAdded: () => void
}

export const ProductVariantRatingAdd: React.FC<
  ProductVariantRatingAddProps
> = ({ variant, product, onRatingAdded }) => {
  const { data: session, status } = useSession()
  const { getVariantDisplayName } = useVariantDisplay(variant, product)

  const isAuthenticated = !!session
  const isLoading = status === 'loading'

  const renderContent = () => {
    if (isLoading) {
      return (
        <div className="rounded-lg bg-gray-50 p-4 text-center">
          <p className="text-gray-500">Cargando...</p>
        </div>
      )
    }

    if (!isAuthenticated) {
      return <AuthPrompt />
      {
        /* üëà Sin props, usa el provider interno */
      }
    }

    return (
      <RatingForm
        variant={variant}
        productName={product.name}
        onRatingAdded={onRatingAdded}
      />
    )
  }

  return (
    <div className="mt-8 pt-6">
      <div className="mb-4">
        <h2 className="mb-2 text-xl font-bold">Deja tu valoraci√≥n</h2>
        <div className="text-sm text-gray-600">
          Producto:{' '}
          <span className="font-medium">{getVariantDisplayName()}</span>
        </div>
      </div>
      {renderContent()}
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatingAdd/RatingForm.tsx
------------------------------------------------------------------------------------
import { type ProductVariants } from '@/types/domain'
import { useRatingForm } from './hooks/useRatingForm'
import { ImageUpload } from './ImageUpload'
import { RatingStars } from './RatingStars'

interface RatingFormProps {
  variant: ProductVariants
  productName: string
  onRatingAdded: () => void
}

export const RatingForm: React.FC<RatingFormProps> = ({
  variant,
  productName,
  onRatingAdded
}) => {
  const {
    rating,
    hoverRating,
    title,
    review,
    images,
    isSubmitting,
    error,
    success,
    setRating,
    setHoverRating,
    setTitle,
    setReview,
    handleImageUpload,
    removeImage,
    handleSubmit,
    getRatingText
  } = useRatingForm({
    onRatingAdded,
    variantId: variant.id,
    productId: variant.productId,
    productName,
    variantSku: variant.sku
  })

  if (success) {
    return (
      <div className="mb-6 rounded-lg bg-green-50 p-4 text-green-700">
        ¬°Gracias por tu valoraci√≥n! Tu opini√≥n es muy importante para nosotros.
      </div>
    )
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <RatingStars
        rating={rating}
        hoverRating={hoverRating}
        onRatingClick={setRating}
        onMouseEnter={setHoverRating}
        onMouseLeave={() => { setHoverRating(0) }}
        getRatingText={getRatingText}
      />

      {/* T√≠tulo */}
      <div>
        <label
          htmlFor="rating-title"
          className="mb-1 block text-sm font-medium text-gray-700"
        >
          T√≠tulo
        </label>
        <input
          type="text"
          id="rating-title"
          value={title}
          onChange={(e) => { setTitle(e.target.value) }}
          placeholder="Resume tu experiencia en una frase"
          maxLength={100}
          className="w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-indigo-500"
        />
        <div className="mt-1 text-xs text-gray-500">
          {title.length}/100 caracteres
        </div>
      </div>

      {/* Comentario */}
      <div>
        <label
          htmlFor="rating-review"
          className="mb-1 block text-sm font-medium text-gray-700"
        >
          Comentario
        </label>
        <textarea
          id="rating-review"
          value={review}
          onChange={(e) => { setReview(e.target.value) }}
          rows={4}
          placeholder="¬øQu√© te gust√≥ o no te gust√≥? ¬øPara qu√© usaste este producto?"
          maxLength={500}
          className="w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-indigo-500"
        />
        <div className="mt-1 text-xs text-gray-500">
          {review.length}/500 caracteres
        </div>
      </div>

      <ImageUpload
        images={images}
        onImageUpload={handleImageUpload}
        onRemoveImage={removeImage}
      />

      {/* Mensaje de error */}
      {error && (
        <div className="rounded-md bg-red-50 p-3 text-sm text-red-600">
          {error}
        </div>
      )}

      {/* Informaci√≥n de stock */}
      {variant.stock !== undefined && (
        <div className="rounded bg-gray-50 p-2 text-xs text-gray-500">
          Stock disponible: {variant.stock} unidades
        </div>
      )}

      {/* Bot√≥n de env√≠o */}
      <div>
        <button
          type="submit"
          disabled={isSubmitting}
          className="w-full rounded-md bg-indigo-600 px-4 py-2 text-white shadow-sm hover:bg-indigo-700 disabled:cursor-not-allowed disabled:opacity-50"
        >
          {isSubmitting ? 'Enviando...' : 'Enviar valoraci√≥n'}
        </button>
      </div>
    </form>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatingAdd/hooks/useRatingForm.ts
------------------------------------------------------------------------------------
import { useState } from 'react'

export interface UseRatingFormProps {
  onRatingAdded: () => void
  variantId: number
  productId: number
  productName: string
  variantSku: string
}

export const useRatingForm = ({
  onRatingAdded,
  variantId,
  productId,
  productName,
  variantSku
}: UseRatingFormProps) => {
  const [rating, setRating] = useState(0)
  const [hoverRating, setHoverRating] = useState(0)
  const [title, setTitle] = useState('')
  const [review, setReview] = useState('')
  const [images, setImages] = useState<string[]>([])
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [error, setError] = useState('')
  const [success, setSuccess] = useState(false)

  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      const newImages = Array.from(e.target.files).map((file) => {
        return URL.createObjectURL(file)
      })
      setImages([...images, ...newImages])
    }
  }

  const removeImage = (index: number) => {
    const newImages = [...images]
    newImages.splice(index, 1)
    setImages(newImages)
  }

  const resetForm = () => {
    setRating(0)
    setTitle('')
    setReview('')
    setImages([])
    setError('')
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    if (rating === 0) {
      setError('Por favor, selecciona una valoraci√≥n')
      return
    }

    setIsSubmitting(true)
    setError('')

    try {
      const response = await fetch('/api/ratings', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          variantId,
          productId,
          rating,
          title: title.trim() || undefined,
          review: review.trim() || undefined,
          verifiedPurchase: 1,
          images: images.length > 0 ? images : undefined,
          productName,
          variantSku
        })
      })

      if (!response.ok) {
        const data = await response.json()
        throw new Error(data.error || 'Error al enviar la valoraci√≥n')
      }

      resetForm()
      setSuccess(true)
      onRatingAdded()

      setTimeout(() => {
        setSuccess(false)
      }, 3000)
    } catch (error) {
      if (error instanceof Error) {
        setError(error.message)
      } else {
        setError('Error al enviar la valoraci√≥n')
      }
    } finally {
      setIsSubmitting(false)
    }
  }

  const getRatingText = () => {
    const ratingTexts = {
      1: 'Muy malo',
      2: 'Malo',
      3: 'Regular',
      4: 'Bueno',
      5: 'Excelente'
    }
    return ratingTexts[rating as keyof typeof ratingTexts] || ''
  }

  return {
    // State
    rating,
    hoverRating,
    title,
    review,
    images,
    isSubmitting,
    error,
    success,

    // Actions
    setRating,
    setHoverRating,
    setTitle,
    setReview,
    handleImageUpload,
    removeImage,
    handleSubmit,
    resetForm,

    // Computed
    getRatingText
  }
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatingAdd/hooks/useVariantDisplay.ts
------------------------------------------------------------------------------------
import { type ProductVariants, type Products } from '@/types/domain'

export const useVariantDisplay = (
  variant: ProductVariants,
  product: Products
) => {
  const getVariantDisplayName = () => {
    let displayName = product.name

    if (
      variant.variantAttributeOptions &&
      variant.variantAttributeOptions.length > 0
    ) {
      const attributes = variant.variantAttributeOptions
        .filter((attr) => attr?.attributeOption?.value)
        .map((attr) => attr!.attributeOption!.value)
        .join(', ')

      if (attributes) {
        displayName += ` - ${attributes}`
      }
    }

    return displayName
  }

  return {
    getVariantDisplayName
  }
}



üìÅ ARCHIVO: src/components/product/ProductVariantRating/ProductVariantRatingAdd/index.ts
------------------------------------------------------------------------------------
export * from './ProductVariantRatingAdd'



üìÅ ARCHIVO: src/components/product/ProductVariantRating/index.ts
------------------------------------------------------------------------------------
export * from './ProductVariantRating/ProductVariantRating'
export * from './ProductVariantRatingAdd/ProductVariantRatingAdd'
export * from './ProductVariantRatings/ProductVariantRatings'



üìÅ ARCHIVO: src/components/product/ProductVariantView.tsx
------------------------------------------------------------------------------------
import { type ProductVariantData } from '@/services/product/productVariant'
import { type ProductVariants } from '@/types/domain'
import React from 'react'
import ProductVariantInteractive from './ProductVariantInteractive'

interface ProductVariantViewProps {
  data: ProductVariantData
  allVariants: ProductVariants[]
  variant: ProductVariants
}

const ProductVariantView: React.FC<ProductVariantViewProps> = ({
  data,
  allVariants,
  variant
}) => {
  return (
    <main className="mx-auto py-6">
      <ProductVariantInteractive
        initialData={data}
        allVariants={allVariants}
        variant={variant}
      />
    </main>
  )
}

export default ProductVariantView



üìÅ ARCHIVO: src/components/product/ProductVariantInteractive.tsx
------------------------------------------------------------------------------------
'use client'
import { getVariantImages } from '@/components/product/ProductImageSlider/ProductImageSlider.helpers'
import ProductVariantAttributeSelector from '@/components/product/ProductVariantAttributeSelector'
import { ProductVariantInfo } from '@/components/product/ProductVariantInfo'
import { ProductVariantPurchase } from '@/components/product/ProductVariantPurchase'
import { ProductVariantRatings } from '@/components/product/ProductVariantRating'
import { type ProductVariantData } from '@/services/product/productVariant'
import { type ProductVariants } from '@/types/domain'
import React, { useState } from 'react'
import {
  ProductImageSlider,
  ProductImageSliderModal
} from './ProductImageSlider' // Nuevo import

interface ProductVariantInteractiveProps {
  initialData: ProductVariantData
  allVariants: ProductVariants[]
  variant: ProductVariants
  preview?: boolean
  handleVariantChangePreview?: (attributeId: number, optionId: number) => void
  onCartAction?: () => void
}

const ProductVariantInteractive: React.FC<ProductVariantInteractiveProps> = ({
  initialData,
  allVariants,
  variant,
  preview = false,
  handleVariantChangePreview,
  onCartAction
}) => {
  const [data, setData] = useState<ProductVariantData>(initialData)
  const { product } = data
  const [isGalleryModalOpen, setIsGalleryModalOpen] = useState(false)
  const [initialModalImageIndex, setInitialModalImageIndex] = useState(0)

  // Manejar cambio de variante
  const handleVariantChange = (newData: ProductVariantData) => {
    setData(newData)
  }

  // Manejar click en imagen para abrir galer√≠a completa
  const handleImageClick = (imageIndex: number) => {
    setInitialModalImageIndex(imageIndex)
    setIsGalleryModalOpen(true)
  }

  // Cerrar modal de galer√≠a
  const closeGalleryModal = () => {
    setIsGalleryModalOpen(false)
  }

  return (
    <div className="grid grid-cols-1 gap-8 xl:grid-cols-12">
      <div className="xl:col-span-9">
        <div className="grid grid-cols-1 gap-8 lg:grid-cols-2">
          <div className="xl:col-span-1">
            <ProductImageSlider
              images={getVariantImages(variant)}
              productName={product.name}
              onImageClick={handleImageClick}
            />
          </div>
          <div className="space-y-5 xl:col-span-1">
            <ProductVariantInfo product={product} variant={variant} />
            <div className="border-t border-gray-200 pt-6">
              <ProductVariantAttributeSelector
                data={data}
                preview={preview}
                allVariants={allVariants}
                variant={variant}
                onVariantChange={handleVariantChange}
                handleVariantChangePreview={handleVariantChangePreview}
              />
            </div>
          </div>
        </div>
        {!preview && (
          <div>
            <ProductVariantRatings product={product} variant={variant} />
          </div>
        )}
      </div>

      <div className="xl:col-span-3">
        <ProductVariantPurchase
          onCartAction={onCartAction}
          preview={preview}
          product={product}
          variant={variant}
        />
      </div>

      {/* Modal de galer√≠a de im√°genes */}
      {!preview && (
        <ProductImageSliderModal
          isOpen={isGalleryModalOpen}
          onClose={closeGalleryModal}
          images={getVariantImages(variant)}
          productName={product.name}
          initialImageIndex={initialModalImageIndex}
        />
      )}
    </div>
  )
}

export default ProductVariantInteractive



üìÅ ARCHIVO: src/components/product/ProductVariantPurchase.tsx
------------------------------------------------------------------------------------
import { getPriceIfHasPromotion } from '@/components/product/ProductVariant.helpers'
import ProductVariantButtonAddToCart from '@/components/product/ProductVariantButtonAddToCart'
import { ProductVariantShipping } from '@/components/product/ProductVariantShipping/ProductVariantShipping'
import { PlusMinusButton } from '@/components/ui/PlusMinusButton'
import { getVariantImages } from '@/helpers/image.helpers'
import { getVariantTitle } from '@/helpers/productVariant.helpers'
import { cn } from '@/lib/utils'
import { useCartContext } from '@/providers/cart'
import { type Products, type ProductVariants as ProductVariant } from '@/types/domain'
import { type FC, useMemo, useState } from 'react'

interface ProductVariantPurchaseProps {
  variant: ProductVariant
  product: Products
  preview: boolean
  onCartAction?: () => void
}

export const ProductVariantPurchase: FC<ProductVariantPurchaseProps> = ({
  product,
  variant,
  preview = false,
  onCartAction
}) => {
  const [quantity, setQuantity] = useState(1)
  const { originalPrice } = getPriceIfHasPromotion(variant)
  const { items } = useCartContext()

  // Informaci√≥n del carrito
  const existingItem = items.find((item) => item.id === variant.id)
  const currentCartQuantity = existingItem?.quantity || 0

  const baseShippingCost = 21.65
  const shippingCost = baseShippingCost * quantity

  const handleQuantityChange = (newQuantity: number) => {
    setQuantity(newQuantity)
  }

  // Calcular valor total del pedido para env√≠o
  const orderValue = useMemo(() => {
    return originalPrice * quantity
  }, [originalPrice, quantity])

  const images = getVariantImages(variant)

  const thumbImage = images.sort((a, b) => a.displayOrder - b.displayOrder)[0]
    .imageUrlThumb

  return (
    <div
      className={cn(
        'sticky top-24 w-full overflow-hidden border border-gray-200 bg-white shadow-sm xl:max-w-96',
        { 'top-0': preview }
      )}
    >
      <ProductVariantShipping
        productVariantId={variant.id}
        quantity={quantity}
        orderValue={orderValue}
      />
      <div className="px-6 py-4">
        <h3 className="mb-2 text-sm font-medium text-gray-900">Cantidad</h3>
        <div className="mb-3 flex items-center space-x-4">
          <PlusMinusButton
            stock={variant.stock}
            maxQuantity={variant.stock} // üëà Puedes seleccionar hasta el stock total
            initialQuantity={quantity}
            onQuantityChange={handleQuantityChange}
            disabled={variant.stock === 0}
            size="md"
          />
        </div>
        <div className="mb-6 text-sm text-gray-600">
          {variant.stock} en stock
        </div>

        {/* Botones de acci√≥n */}
        <div className="mb-6 space-y-3">
          <button
            className="w-full bg-secondary px-4 py-3 font-medium text-white transition-colors hover:bg-secondary-800 disabled:cursor-not-allowed disabled:opacity-50"
            disabled={variant.stock === 0}
          >
            {variant.stock === 0 ? 'Sin stock' : 'Comprar'}
          </button>
          <ProductVariantButtonAddToCart
            quantity={quantity}
            stock={variant.stock}
            price={originalPrice}
            id={variant.id}
            name={getVariantTitle(product.name, variant)}
            image={thumbImage}
            promotionVariants={variant.promotionVariants}
            onCartAction={onCartAction}
          />
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantPrice.tsx
------------------------------------------------------------------------------------
import { getPriceIfHasPromotion } from '@/components/product/ProductVariant.helpers'
import { formatPrice } from '@/helpers/utils'
import { type ProductVariants } from '@/types/domain'
import { type FC } from 'react'

interface ProductVariantPriceProps {
  variant: ProductVariants
}

export const ProductVariantPrice: FC<ProductVariantPriceProps> = ({
  variant
}) => {
  const { finalPrice, hasPromotion, originalPrice, currentPromotion } =
    getPriceIfHasPromotion(variant)

  return (
    <div className="ml-1 flex flex-col gap-1">
      <div className="text-4xl font-bold">
        {formatPrice(Number(finalPrice))}
      </div>
      {hasPromotion && (
        <div className="flex items-center">
          <span className="text-lg leading-5 text-gray-500 line-through">
            {formatPrice(originalPrice)}
          </span>
          <span className="flex flex-col items-center px-2 text-base font-semibold leading-4 text-red-600">
            {currentPromotion?.promotion?.discountType === 'percentage'
              ? `-${Number(currentPromotion.promotion.discountValue)}%`
              : `- ${formatPrice(Number(currentPromotion?.promotion?.discountValue))}`}{' '}
            dscto.
          </span>
        </div>
      )}
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantInteractiveShimmer.tsx
------------------------------------------------------------------------------------
// üëà COMPONENTE BASE DE SHIMMER
const ShimmerBox = ({
  className = '',
  children
}: {
  className?: string
  children?: React.ReactNode
}) => (
  <div className={`animate-pulse rounded bg-gray-200 ${className}`}>
    {children}
  </div>
)

const ShimmerText = ({ className = '' }: { className?: string }) => (
  <ShimmerBox className={`h-4 ${className}`} />
)

const ShimmerButton = ({ className = '' }: { className?: string }) => (
  <ShimmerBox className={`h-12 ${className}`} />
)

// üëà SHIMMER PRINCIPAL DEL PRODUCTO (Estructura correcta)
export const ProductVariantInteractiveShimmer = () => {
  return (
    <div className="grid grid-cols-1 gap-8 xl:grid-cols-12">
      {/* üëà CONTENIDO PRINCIPAL - 9 columnas */}
      <div className="xl:col-span-9">
        <div className="grid grid-cols-1 gap-8 lg:grid-cols-2">
          {/* üëà IMAGEN DEL PRODUCTO */}
          <div className="xl:col-span-1">
            <ShimmerBox className="mb-4 aspect-square w-full" />
          </div>

          {/* üëà INFORMACI√ìN DEL PRODUCTO */}
          <div className="space-y-5 xl:col-span-1">
            {/* ProductVariantInfo */}
            <div className="space-y-4">
              {/* Precio */}
              <ShimmerText className="h-8 w-32" />

              {/* T√≠tulo y descripci√≥n */}
              <div className="space-y-2">
                <ShimmerText className="h-6 w-full" />
                <ShimmerText className="h-4 w-3/4" />
              </div>
            </div>

            {/* Separador */}
            <div className="border-t border-gray-200 pt-6">
              {/* ProductVariantAttributeSelector */}
              <div className="space-y-6">
                {/* Color */}
                <div className="space-y-3">
                  <ShimmerText className="h-4 w-16" />
                  <div className="flex gap-2">
                    <ShimmerBox className="h-12 w-16" />
                    <ShimmerBox className="h-12 w-16" />
                  </div>
                </div>

                {/* Tama√±o */}
                <div className="space-y-3">
                  <ShimmerText className="h-4 w-20" />
                  <ShimmerBox className="h-12 w-32" />
                </div>

                {/* Almacenamiento */}
                <div className="space-y-3">
                  <ShimmerText className="h-4 w-28" />
                  <div className="flex gap-2">
                    <ShimmerBox className="h-10 w-20" />
                    <ShimmerBox className="h-10 w-20" />
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* üëà RATINGS SECTION (solo si no es preview) */}
        {/* <div className="mt-8">
          <div className="space-y-4">
            <ShimmerText className="w-32 h-6" />
            <div className="flex gap-1">
              <ShimmerBox className="w-5 h-5" />
              <ShimmerBox className="w-5 h-5" />
              <ShimmerBox className="w-5 h-5" />
              <ShimmerBox className="w-5 h-5" />
              <ShimmerBox className="w-5 h-5" />
              <ShimmerText className="w-20 h-4 ml-2" />
            </div>
            <div className="space-y-3">
              <ShimmerText className="w-full h-4" />
              <ShimmerText className="w-3/4 h-4" />
              <ShimmerText className="w-1/2 h-4" />
            </div>
          </div>
        </div> */}
      </div>

      {/* üëà SIDEBAR DE COMPRA - 3 columnas */}
      <div className="xl:col-span-3">
        <div className="sticky top-4 space-y-4 rounded-lg border p-6">
          {/* Env√≠o */}
          <div className="space-y-2">
            <div className="flex items-center justify-between">
              <ShimmerText className="h-4 w-16" />
              <ShimmerText className="h-4 w-12" />
            </div>
            <ShimmerText className="h-4 w-full" />
          </div>

          {/* Pol√≠tica de env√≠o */}
          {/* <div className="space-y-2">
            <ShimmerBox className="w-6 h-6 rounded-full" />
            <ShimmerText className="w-32 h-4" />
          </div> */}

          {/* Pol√≠tica de devoluciones */}
          <div className="space-y-2">
            <ShimmerBox className="h-6 w-6 rounded-full" />
            <ShimmerText className="h-4 w-40" />
          </div>

          {/* Seguridad */}
          <div className="space-y-2">
            <ShimmerBox className="h-6 w-6 rounded-full" />
            <ShimmerText className="h-4 w-36" />
          </div>

          {/* Cantidad */}
          <div className="space-y-3">
            <ShimmerText className="h-4 w-20" />
            <div className="flex items-center justify-between rounded-lg border p-2">
              <ShimmerBox className="h-6 w-6" />
              <ShimmerText className="h-4 w-6" />
              <ShimmerBox className="h-6 w-6" />
            </div>
            <ShimmerText className="h-4 w-24" />
          </div>

          {/* Botones */}
          <div className="space-y-3">
            <ShimmerButton className="w-full bg-blue-200" />
            <ShimmerButton className="w-full" />
          </div>
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantInfo.tsx
------------------------------------------------------------------------------------
import { ProductVariantPrice } from '@/components/product/ProductVariantPrice'
import { ProductVariantPromotion } from '@/components/product/ProductVariantPromotion'
import { ProductVariantRating } from '@/components/product/ProductVariantRating'
import { getVariantTitle } from '@/helpers/productVariant.helpers'
import {
  type Products as Product,
  type ProductVariants as ProductVariant
} from '@/types/domain'
import { type FC } from 'react'

interface ProductVariantInfoProps {
  product: Product
  variant: ProductVariant
}

export const ProductVariantInfo: FC<ProductVariantInfoProps> = ({
  product,
  variant
}) => {
  return (
    <>
      <div className="flex flex-col gap-2.5">
        <ProductVariantPromotion variant={variant} />
        <ProductVariantPrice variant={variant} />
      </div>

      <div className="flex flex-col gap-4">
        <div className="flex flex-col gap-0.5">
          <h1 className="text-base font-bold leading-4 text-gray-900">
            {getVariantTitle(product.name, variant)}
          </h1>

          {product.description && (
            <p className="text-sm leading-relaxed text-gray-900">
              {product.description}
            </p>
          )}
        </div>
        <ProductVariantRating variant={variant} />
      </div>
    </>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantNotFound.tsx
------------------------------------------------------------------------------------
import Layout from '@/components/layout/Layout'
import Link from 'next/link'

export const ProductVariantNotFound = () => {
  return (
    <Layout>
      <main className="py-8">
        <div className="py-12 text-center">
          <h1 className="mb-4 text-2xl font-bold text-gray-800">
            Producto no encontrado
          </h1>
          <p className="mb-6 text-gray-600">
            El producto o variante que est√°s buscando no existe o ha sido
            eliminado.
          </p>
          <div className="space-x-4">
            <Link
              href="/"
              className="inline-block rounded-lg bg-primary px-4 py-2 text-white transition-colors hover:bg-primary/90"
            >
              Volver al inicio
            </Link>
            <Link
              href="/search"
              className="inline-block rounded-lg bg-gray-200 px-4 py-2 text-gray-800 transition-colors hover:bg-gray-300"
            >
              Buscar productos
            </Link>
          </div>
        </div>
      </main>
    </Layout>
  )
}



üìÅ ARCHIVO: src/components/product/AddressSelectionModal.tsx
------------------------------------------------------------------------------------
// üìÑ components/product/AddressSelectionModal.tsx
'use client'

import { Modal } from '@/components/ui/Modal'
import { formatPrice } from '@/helpers/utils'
import { Check, MapPin, Package, Plus, X } from 'lucide-react'
import { type FC } from 'react'

// Usar los tipos compartidos
import { type ShippingOptionForAddress } from '@/types/shipping'

interface AddressSelectionModalProps {
  isOpen: boolean
  onClose: () => void
  addressOptions: ShippingOptionForAddress[]
  selectedAddressId: number
  onSelectAddress: (addressOption: ShippingOptionForAddress) => void
}

export const AddressSelectionModal: FC<AddressSelectionModalProps> = ({
  isOpen,
  onClose,
  addressOptions,
  selectedAddressId,
  onSelectAddress
}) => {
  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      className="max-h-[80vh] max-w-2xl overflow-hidden"
    >
      {/* Header */}
      <div className="mb-6 flex items-center justify-between">
        <div>
          <h3 className="text-lg font-semibold text-gray-900">
            Seleccionar direcci√≥n de env√≠o
          </h3>
          <p className="mt-1 text-sm text-gray-600">
            Elige la direcci√≥n donde quieres recibir tu pedido
          </p>
        </div>
        <button
          onClick={onClose}
          className="text-gray-400 transition-colors hover:text-gray-600"
        >
          <X className="h-6 w-6" />
        </button>
      </div>

      {/* Content - Scrollable */}
      <div className="mb-6 max-h-96 overflow-y-auto">
        <div className="space-y-4">
          {addressOptions.map((addressOption) => (
            <div key={addressOption.addressId} className="space-y-3">
              {/* Address Info */}
              <div
                className={`cursor-pointer rounded-lg border p-4 transition-all hover:border-blue-300 ${
                  addressOption.addressId === selectedAddressId
                    ? 'border-blue-500 bg-blue-50'
                    : 'border-gray-200'
                }`}
                onClick={() => { onSelectAddress(addressOption) }}
              >
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    <div className="mb-2 flex items-center space-x-2">
                      <MapPin className="h-4 w-4 text-gray-600" />
                      <span className="font-medium text-gray-900">
                        {addressOption.address.alias}
                      </span>
                      {addressOption.addressId === selectedAddressId && (
                        <Check className="h-4 w-4 text-blue-600" />
                      )}
                    </div>
                    <p className="ml-6 text-sm text-gray-700">
                      {addressOption.address.streetName}{' '}
                      {addressOption.address.streetNumber}
                      {addressOption.address.apartment &&
                        `, ${addressOption.address.apartment}`}
                    </p>
                    <p className="ml-6 text-sm text-gray-600">
                      {addressOption.address.district},{' '}
                      {addressOption.address.province},{' '}
                      {addressOption.address.department}
                    </p>
                  </div>
                </div>

                {/* Shipping Options for this address */}
                <div className="ml-6 mt-4 space-y-2">
                  <h4 className="text-sm font-medium text-gray-900">
                    Opciones de env√≠o disponibles:
                  </h4>

                  {addressOption.shippingOptions.map((shipping, index) => {
                    const isDefault =
                      shipping === addressOption.defaultShippingOption
                    const deliveryText = `${shipping.estimatedDays.min}-${shipping.estimatedDays.max} d√≠as`

                    return (
                      <div
                        key={`${shipping.methodId}-${shipping.zoneId}`}
                        className={`flex items-center justify-between rounded-md border p-3 ${
                          isDefault
                            ? 'border-green-200 bg-green-50'
                            : 'border-gray-100 bg-gray-50'
                        }`}
                      >
                        <div className="flex items-center space-x-3">
                          <Package className="h-4 w-4 text-gray-600" />
                          <div>
                            <p className="text-sm font-medium text-gray-900">
                              {shipping.methodName}
                              {isDefault && (
                                <span className="ml-2 rounded bg-green-100 px-2 py-1 text-xs text-green-700">
                                  Recomendado
                                </span>
                              )}
                            </p>
                            <p className="text-xs text-gray-600">
                              Entrega en {deliveryText}
                            </p>
                          </div>
                        </div>
                        <div className="text-right">
                          {shipping.isFree ? (
                            <span className="text-sm font-semibold text-green-600">
                              GRATIS
                            </span>
                          ) : (
                            <span className="text-sm font-medium text-gray-900">
                              {formatPrice(shipping.finalCost)}
                            </span>
                          )}
                        </div>
                      </div>
                    )
                  })}
                </div>
              </div>
            </div>
          ))}

          {/* Add New Address Button */}
          <button className="group w-full rounded-lg border-2 border-dashed border-gray-300 p-6 text-center transition-colors hover:border-gray-400">
            <Plus className="mx-auto mb-2 h-8 w-8 text-gray-400 group-hover:text-gray-600" />
            <span className="text-sm font-medium text-gray-600 group-hover:text-gray-900">
              Agregar nueva direcci√≥n
            </span>
          </button>
        </div>
      </div>

      {/* Footer */}
      <div className="flex items-center justify-end space-x-3 border-t border-gray-200 pt-4">
        <button
          onClick={onClose}
          className="rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition-colors hover:bg-gray-50"
        >
          Cancelar
        </button>
        <button
          onClick={onClose}
          className="rounded-md border border-transparent bg-blue-600 px-4 py-2 text-sm font-medium text-white transition-colors hover:bg-blue-700"
        >
          Confirmar selecci√≥n
        </button>
      </div>
    </Modal>
  )
}



üìÅ ARCHIVO: src/components/product/ProductImageSlider/useImageNavigation.ts
------------------------------------------------------------------------------------
'use client'

import { useState } from 'react'
import { type CleanImage } from '../ProductVariant.helpers'

interface UseImageNavigationProps {
  images: CleanImage[]
  initialIndex?: number
}

export const useImageNavigation = ({
  images,
  initialIndex = 0
}: UseImageNavigationProps) => {
  const [currentImageIndex, setCurrentImageIndex] = useState(initialIndex)

  const goToNextImage = () => {
    setCurrentImageIndex((prevIndex) =>
      prevIndex === images.length - 1 ? 0 : prevIndex + 1
    )
  }

  const goToPrevImage = () => {
    setCurrentImageIndex((prevIndex) =>
      prevIndex === 0 ? images.length - 1 : prevIndex - 1
    )
  }

  const selectImage = (index: number) => {
    if (index >= 0 && index < images.length) {
      setCurrentImageIndex(index)
    }
  }

  const currentImage = images[currentImageIndex]
  const hasMultipleImages = images.length > 1

  return {
    currentImageIndex,
    currentImage,
    hasMultipleImages,
    goToNextImage,
    goToPrevImage,
    selectImage
  }
}



üìÅ ARCHIVO: src/components/product/ProductImageSlider/ProductImageSlider.helpers.ts
------------------------------------------------------------------------------------
import { type ItemImage } from '@/shared'
import { type ProductVariants } from '@/types/domain'

// Obtener im√°genes de la variante actual (desde attributeOptionImages)
export const getVariantImages = (variant: ProductVariants) => {
  const images: ItemImage[] = []

  // Buscar im√°genes en las opciones de atributos de la variante actual
  variant?.variantAttributeOptions?.forEach((vao) => {
    if (vao?.attributeOption?.attributeOptionImages) {
      vao.attributeOption.attributeOptionImages.forEach((img) => {
        if (!img) return

        images.push({
          id: img.id,
          imageUrlThumb: img.imageUrlThumb,
          imageUrlNormal: img.imageUrlNormal || '',
          imageUrlZoom: img.imageUrlZoom || '',
          altText: img.altText || '',
          imageType: img.imageType,
          displayOrder: Number(img.displayOrder),
          isPrimary: img.isPrimary
        })
      })
    }
  })

  // Ordenar por displayOrder
  return images.sort((a, b) => a.displayOrder - b.displayOrder)
}



üìÅ ARCHIVO: src/components/product/ProductImageSlider/ProductImageSlider.tsx
------------------------------------------------------------------------------------
'use client'
import { ImageGalleryThumbs } from '@/components/ui/ImageGalleryThumbs'
import { type ItemImage } from '@/shared'
import React from 'react'
import { cleanAndValidateImages } from '../ProductVariant.helpers'

interface ProductImageSliderProps {
  images: ItemImage[]
  productName: string
  onImageZoom?: (imageUrl: string) => void
  onImageClick?: (imageIndex: number) => void
  initialImageIndex?: number
  isInModal?: boolean
  showImageType?: boolean
  thumbsPosition?: 'left' | 'bottom'
  className?: string
}

export const ProductImageSlider: React.FC<ProductImageSliderProps> = ({
  images,
  productName,
  onImageZoom,
  onImageClick,
  initialImageIndex,
  isInModal = false,
  showImageType = true,
  thumbsPosition = 'left',
  className
}) => {
  // Limpiar y validar im√°genes usando el helper
  const cleanImages = cleanAndValidateImages(images, productName)

  return (
    <ImageGalleryThumbs
      images={cleanImages}
      productName={productName}
      onImageClick={onImageClick}
      onImageZoom={onImageZoom}
      initialImageIndex={initialImageIndex}
      isInModal={isInModal}
      showImageType={showImageType}
      thumbsPosition={thumbsPosition}
      className={className}
    />
  )
}



üìÅ ARCHIVO: src/components/product/ProductImageSlider/ProductImageSliderModal.tsx
------------------------------------------------------------------------------------
'use client'
import { Modal } from '@/components/ui/Modal' // üëà USAR TU MODAL
import { type ItemImage } from '@/shared'
import { X } from 'lucide-react'
import React from 'react'
import { ProductImageSlider } from './ProductImageSlider'

interface ProductImageSliderModalProps {
  isOpen: boolean
  onClose: () => void
  images: ItemImage[]
  productName: string
  initialImageIndex?: number
}

export const ProductImageSliderModal: React.FC<
  ProductImageSliderModalProps
> = ({ isOpen, onClose, images, productName, initialImageIndex = 0 }) => {
  // const handleImageZoom = (imageUrl: string) => {
  //   // Abrir imagen en nueva ventana para zoom m√°ximo
  //   // window.open(imageUrl, '_blank');
  // };

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      // üëà CLASES PERSONALIZADAS PARA ESTE MODAL ESPEC√çFICO
      className="max-h-[95vh] max-w-7xl overflow-hidden rounded-lg p-0"
    >
      {/* üëà CONTENIDO DEL MODAL SIN EL BACKDROP (YA LO MANEJA Modal) */}
      <>
        {/* Header con bot√≥n de cerrar */}
        <div className="flex items-center justify-between border-b bg-white p-4">
          <h2 className="text-lg font-semibold text-gray-900">
            Galer√≠a de {productName}
          </h2>
          <button
            onClick={onClose}
            className="rounded-full p-2 transition-colors hover:bg-gray-100"
            aria-label="Cerrar galer√≠a"
          >
            <X className="h-6 w-6" />
          </button>
        </div>

        {/* Contenido del modal con el slider */}
        <div className="max-h-[calc(95vh-80px)] overflow-y-auto bg-white p-6">
          <ProductImageSlider
            images={images}
            productName={productName}
            initialImageIndex={initialImageIndex}
            isInModal={true}
            showImageType={true}
            thumbsPosition="left"
          />
        </div>

        {/* Footer con informaci√≥n adicional */}
        <div className="border-t bg-gray-50 px-6 py-3">
          <p className="text-sm text-gray-600">
            Usa las flechas de navegaci√≥n o haz clic en las miniaturas para
            cambiar de imagen. Haz clic en la imagen principal para zoom
            completo.
          </p>
        </div>
      </>
    </Modal>
  )
}



üìÅ ARCHIVO: src/components/product/ProductImageSlider/index.ts
------------------------------------------------------------------------------------
export * from './ProductImageSlider'
export * from './ProductImageSliderModal'
export { useImageNavigation } from './useImageNavigation'



üìÅ ARCHIVO: src/components/product/ProductVariantButtonAddToCart.tsx
------------------------------------------------------------------------------------
'use client'
import { getPromotions } from '@/helpers/utils'
import { useCartContext } from '@/providers/cart'
import { type PromotionVariants } from '@/types/domain'
import React from 'react'

interface ProductVariantButtonAddToCartProps {
  id: number
  name: string
  image: string
  price: number
  stock: number
  quantity: number
  promotionVariants?: Array<PromotionVariants | null> | null
  onCartAction?: () => void
}

const ProductVariantButtonAddToCart: React.FC<
  ProductVariantButtonAddToCartProps
> = ({
  id,
  quantity,
  image,
  name,
  price,
  stock,
  promotionVariants: pvs,
  onCartAction
}) => {
  const { updateQuantity, items, addItem, openCart } = useCartContext()

  const promotionVariants = getPromotions(pvs)

  // Encontrar el item en el carrito si existe
  const existingItem = items.find((item) => item.id === id)
  // const currentCartQuantity = existingItem?.quantity || 0;

  // Verificaciones
  const isOutOfStock = stock === 0
  const exceedsStock = quantity > stock
  // const sameAsCart = existingItem && currentCartQuantity === quantity;

  // El bot√≥n se deshabilita si no hay stock, excede stock, o ya tiene esa cantidad
  const isDisabled = isOutOfStock || exceedsStock

  const handleAddToCart = (e: React.MouseEvent<HTMLButtonElement>) => {
    e.preventDefault()

    if (isDisabled) return

    if (existingItem) {
      // Establecer la cantidad total (no sumar)
      updateQuantity(id, quantity)
    } else {
      // Agregar nuevo item
      addItem(
        {
          id,
          image,
          name,
          price,
          stock,
          promotionVariants
        },
        quantity
      )
      openCart()
    }
    onCartAction?.()
  }

  return (
    <button
      onClick={handleAddToCart}
      className={'w-full border border-gray-300 px-4 py-3 font-medium text-gray-700 transition-colors hover:bg-gray-50 disabled:cursor-not-allowed disabled:opacity-50'}
      disabled={isDisabled}
    >
      Agregar al carrito
    </button>
  )
}

export default ProductVariantButtonAddToCart



üìÅ ARCHIVO: src/components/product/ProductVariantShipping/use-product-variant-shipping.hook.ts
------------------------------------------------------------------------------------
// üìÑ hooks/useProductVariantShipping.ts
import {
  type ShippingCalculationResponse,
  type ShippingOptionForAddress
} from '@/types/shipping'
import { useSession } from 'next-auth/react'
import { useEffect, useState } from 'react'

interface ShippingData {
  selectedAddress: ShippingOptionForAddress | null
  allAddresses: ShippingOptionForAddress[]
  loading: boolean
  error: string | null
  isInitialized: boolean
}

interface UseProductVariantShippingProps {
  productVariantId: number
  quantity: number
  orderValue: number
}

interface UseProductVariantShippingReturn extends ShippingData {
  selectAddress: (addressOption: ShippingOptionForAddress) => void
  retry: () => void
}

export const useProductVariantShipping = ({
  productVariantId,
  quantity,
  orderValue
}: UseProductVariantShippingProps): UseProductVariantShippingReturn => {
  const { data: session, status } = useSession()

  const [shippingData, setShippingData] = useState<ShippingData>({
    selectedAddress: null,
    allAddresses: [],
    loading: true,
    error: null,
    isInitialized: false
  })

  const loadShippingData = async () => {
    // No hacer nada hasta que la sesi√≥n est√© resuelta
    if (status === 'loading') return

    try {
      if (session?.user?.id) {
        // Usuario logueado: obtener todas las direcciones y calcular env√≠o
        const response = await fetch('/api/shipping/calculate-user', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            productVariantId,
            quantity,
            orderValue
          })
        })

        if (!response.ok) {
          throw new Error('Error al calcular env√≠o')
        }

        const data: ShippingCalculationResponse = await response.json()

        setShippingData({
          selectedAddress: data.defaultAddress,
          allAddresses: data.allAddresses || [],
          loading: false,
          error: null,
          isInitialized: true
        })
      } else {
        // Usuario no logueado: mostrar env√≠o gen√©rico
        setShippingData({
          selectedAddress: null,
          allAddresses: [],
          loading: false,
          error: null,
          isInitialized: true
        })
      }
    } catch (error) {
      console.error('Error loading shipping data:', error)
      setShippingData({
        selectedAddress: null,
        allAddresses: [],
        loading: false,
        error:
          error instanceof Error
            ? error.message
            : 'Error al cargar informaci√≥n de env√≠o',
        isInitialized: true
      })
    }
  }

  // Efecto principal para cargar datos
  useEffect(() => {
    loadShippingData()
  }, [session, status, productVariantId, quantity, orderValue])

  // Funci√≥n para seleccionar direcci√≥n
  const selectAddress = (addressOption: ShippingOptionForAddress) => {
    setShippingData((prev) => ({
      ...prev,
      selectedAddress: addressOption
    }))
  }

  // Funci√≥n para reintentar
  const retry = () => {
    setShippingData((prev) => ({
      ...prev,
      loading: true,
      error: null,
      isInitialized: false
    }))
    loadShippingData()
  }

  return {
    ...shippingData,
    selectAddress,
    retry
  }
}



üìÅ ARCHIVO: src/components/product/ProductVariantShipping/ProductVariantShippingLogout.tsx
------------------------------------------------------------------------------------
import { formatPrice } from '@/helpers/utils'
import { ChevronRight, MapPin, Package, RotateCcw, Shield } from 'lucide-react'

export const ProductVariantShippingLogout = () => {
  return (
    <div className="border-b border-gray-200 px-6 py-4">
      <div className="mb-4 flex items-center justify-between">
        <span className="text-sm font-medium text-gray-900">Env√≠o a</span>
        <div className="flex items-center space-x-1 text-gray-600">
          <MapPin className="h-4 w-4" />
          <span className="text-sm">Per√∫</span>
        </div>
      </div>

      <div className="space-y-3 bg-gray-50 p-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <Package className="h-4 w-4 text-gray-600" />
            <div>
              <div className="text-sm font-medium text-gray-900">
                Env√≠o: Desde {formatPrice(15.0)}
              </div>
              <div className="text-xs text-gray-600">
                <span className="font-medium">
                  Inicia sesi√≥n para ver costo exacto
                </span>
              </div>
            </div>
          </div>
          <ChevronRight className="h-4 w-4 text-gray-400" />
        </div>

        <div className="space-y-2 border-t border-gray-200 pt-3">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2">
              <RotateCcw className="h-4 w-4 text-gray-600" />
              <span className="text-xs font-medium text-gray-700">
                Pol√≠tica de devoluciones y reembolsos
              </span>
            </div>
            <ChevronRight className="h-3 w-3 text-gray-400" />
          </div>

          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2">
              <Shield className="h-4 w-4 text-gray-600" />
              <span className="text-xs font-medium text-gray-700">
                Seguridad & Privacidad
              </span>
            </div>
            <ChevronRight className="h-3 w-3 text-gray-400" />
          </div>
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantShipping/ProductVariantShippingNotAvailable.tsx
------------------------------------------------------------------------------------
import { AlertCircle } from 'lucide-react'

export const ProductVariantShippingNotAvailable = () => {
  return (
    <div className="border-b border-gray-200 px-6 py-4">
      <div className="py-4 text-center">
        <AlertCircle className="mx-auto mb-2 h-8 w-8 text-orange-400" />
        <p className="text-sm text-gray-600">
          No hay env√≠o disponible a esta direcci√≥n
        </p>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantShipping/ProductVariantShipping.tsx
------------------------------------------------------------------------------------
// üìÑ components/product/ProductVariantShipping.tsx
'use client'

import { formatPrice } from '@/helpers/utils'
import {
  AlertCircle,
  ChevronRight,
  MapPin,
  Package,
  RotateCcw,
  Shield
} from 'lucide-react'
import { useSession } from 'next-auth/react'
import { type FC, useState } from 'react'
import { AddressSelectionModal } from '../AddressSelectionModal'

// Usar los tipos compartidos
import { deliveryDates } from '@/components/product/ProductVariantShipping/ProductVariantShipping.helpers'
import { type ShippingOptionForAddress } from '@/types/shipping'
import { type ProductVariantShippingProps } from './ProductVariantShipping.interfaces'
import { ProductVariantShippingLogout } from './ProductVariantShippingLogout'
import { ProductVariantShippingNotAddress } from './ProductVariantShippingNotAddress'
import { ProductVariantShippingNotAvailable } from './ProductVariantShippingNotAvailable'
import { ProductVariantShippingShimmer } from './ProductVariantShippingShimmer'
import { useProductVariantShipping } from './use-product-variant-shipping.hook'

export const ProductVariantShipping: FC<ProductVariantShippingProps> = ({
  productVariantId,
  quantity,
  orderValue
}) => {
  const { data: session, status } = useSession()
  const [isModalOpen, setIsModalOpen] = useState(false)

  // Usar el hook personalizado
  const {
    selectedAddress,
    allAddresses,
    loading,
    error,
    isInitialized,
    selectAddress
  } = useProductVariantShipping({
    productVariantId,
    quantity,
    orderValue
  })

  // Manejar cambio de direcci√≥n
  const handleAddressChange = (addressOption: ShippingOptionForAddress) => {
    selectAddress(addressOption)
    setIsModalOpen(false)
  }

  // Mostrar shimmer hasta que TODO est√© listo
  if (status === 'loading' || !isInitialized || loading) {
    return <ProductVariantShippingShimmer />
  }

  // Renderizar error
  if (error) {
    return (
      <div className="border-b border-gray-200 px-6 py-4">
        <div className="flex items-center justify-center py-4 text-red-600">
          <AlertCircle className="mr-2 h-5 w-5" />
          <span className="text-sm">{error}</span>
        </div>
      </div>
    )
  }

  // Renderizar para usuario no logueado
  if (!session) {
    return <ProductVariantShippingLogout />
  }

  // Renderizar sin direcciones
  if (!selectedAddress) {
    return <ProductVariantShippingNotAddress />
  }

  const { selectedAddress: selectedAddressArg } = { selectedAddress }
  const defaultShipping = selectedAddressArg.defaultShippingOption

  if (!defaultShipping) {
    return <ProductVariantShippingNotAvailable />
  }

  return (
    <>
      <div className="border-b border-gray-200 px-6 py-4">
        <div className="mb-4 flex items-center justify-between">
          <span className="text-sm font-medium text-gray-900">Env√≠o a</span>
          <button
            onClick={() => {
              setIsModalOpen(true)
            }}
            className="flex items-center space-x-1 text-blue-600 transition-colors hover:text-blue-700"
          >
            <MapPin className="h-4 w-4" />
            <span className="text-sm">{selectedAddress.address.district}</span>
            <ChevronRight className="h-3 w-3" />
          </button>
        </div>

        <div className="space-y-3 bg-gray-50 p-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-3">
              <Package className="h-4 w-4 text-gray-600" />
              <div>
                <div className="text-sm font-medium text-gray-900">
                  {defaultShipping.isFree ? (
                    <span className="font-semibold text-green-600">
                      Env√≠o GRATIS
                    </span>
                  ) : (
                    <>Env√≠o: {formatPrice(defaultShipping.finalCost)}</>
                  )}
                </div>
                <div className="text-xs text-gray-600">
                  Entrega:{' '}
                  <span className="font-medium">
                    {deliveryDates(defaultShipping).min} -{' '}
                    {deliveryDates(defaultShipping).max}
                  </span>
                </div>
                <div className="text-xs text-gray-500">
                  {defaultShipping.methodName} ‚Ä¢ {selectedAddress.address.alias}
                </div>
              </div>
            </div>
            <button
              onClick={() => {
                setIsModalOpen(true)
              }}
              className="text-gray-400 hover:text-gray-600"
            >
              <ChevronRight className="h-4 w-4" />
            </button>
          </div>

          {/* Opciones adicionales de env√≠o */}
          {selectedAddress.shippingOptions.length > 1 && (
            <div className="border-t border-gray-200 pt-3">
              <button
                onClick={() => {
                  setIsModalOpen(true)
                }}
                className="text-xs font-medium text-blue-600 hover:text-blue-700"
              >
                Ver m√°s opciones de env√≠o (
                {selectedAddress.shippingOptions.length - 1} m√°s)
              </button>
            </div>
          )}

          <div className="space-y-2 border-t border-gray-200 pt-3">
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-2">
                <RotateCcw className="h-4 w-4 text-gray-600" />
                <span className="text-xs font-medium text-gray-700">
                  Pol√≠tica de devoluciones y reembolsos
                </span>
              </div>
              <ChevronRight className="h-3 w-3 text-gray-400" />
            </div>

            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-2">
                <Shield className="h-4 w-4 text-gray-600" />
                <span className="text-xs font-medium text-gray-700">
                  Seguridad & Privacidad
                </span>
              </div>
              <ChevronRight className="h-3 w-3 text-gray-400" />
            </div>
          </div>
        </div>
      </div>

      {/* Modal de selecci√≥n de direcci√≥n */}
      <AddressSelectionModal
        isOpen={isModalOpen}
        onClose={() => {
          setIsModalOpen(false)
        }}
        addressOptions={allAddresses}
        selectedAddressId={selectedAddress.address.id}
        onSelectAddress={handleAddressChange}
      />
    </>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantShipping/ProductVariantShipping.helpers.ts
------------------------------------------------------------------------------------
import { type ShippingCalculation } from '@/backend/shipping-zone-method'

export const deliveryDates = (defaultShipping: ShippingCalculation) => {
  const today = new Date()
  const minDate = new Date(today)
  minDate.setDate(today.getDate() + defaultShipping.estimatedDays.min)

  const maxDate = new Date(today)
  maxDate.setDate(today.getDate() + defaultShipping.estimatedDays.max)

  const formatOptions: Intl.DateTimeFormatOptions = {
    day: '2-digit',
    month: 'short'
  }

  return {
    min: minDate.toLocaleDateString('es-PE', formatOptions).toUpperCase(),
    max: maxDate.toLocaleDateString('es-PE', formatOptions).toUpperCase()
  }
}



üìÅ ARCHIVO: src/components/product/ProductVariantShipping/ProductVariantShipping.interfaces.ts
------------------------------------------------------------------------------------
import { type ShippingOptionForAddress } from '@/types/shipping'

export interface ProductVariantShippingProps {
  productVariantId: number
  quantity: number
  orderValue: number
}

export interface ShippingData {
  selectedAddress: ShippingOptionForAddress | null
  allAddresses: ShippingOptionForAddress[]
  loading: boolean
  error: string | null
}



üìÅ ARCHIVO: src/components/product/ProductVariantShipping/ProductVariantShippingNotAddress.tsx
------------------------------------------------------------------------------------
import { MapPin } from 'lucide-react'

export const ProductVariantShippingNotAddress = () => {
  return (
    <div className="border-b border-gray-200 px-6 py-4">
      <div className="py-4 text-center">
        <MapPin className="mx-auto mb-2 h-8 w-8 text-gray-400" />
        <p className="mb-3 text-sm text-gray-600">
          No tienes direcciones registradas
        </p>
        <button className="text-sm font-medium text-blue-600 hover:text-blue-700">
          Agregar direcci√≥n
        </button>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantShipping/index.ts
------------------------------------------------------------------------------------
export * from './ProductVariantShipping'



üìÅ ARCHIVO: src/components/product/ProductVariantShipping/ProductVariantShippingShimmer.tsx
------------------------------------------------------------------------------------
export const ProductVariantShippingShimmer = () => {
  return (
    <div className="border-b border-gray-200 px-6 py-4">
      <div className="mb-4 flex items-center justify-between">
        <div className="h-4 w-20 animate-pulse rounded bg-gray-200"></div>
        <div className="flex items-center space-x-2">
          <div className="h-4 w-4 animate-pulse rounded bg-gray-200"></div>
          <div className="h-4 w-16 animate-pulse rounded bg-gray-200"></div>
          <div className="h-3 w-3 animate-pulse rounded bg-gray-200"></div>
        </div>
      </div>

      <div className="space-y-3 bg-gray-50 p-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <div className="h-4 w-4 animate-pulse rounded bg-gray-200"></div>
            <div className="space-y-2">
              <div className="h-4 w-32 animate-pulse rounded bg-gray-200"></div>
              <div className="h-3 w-28 animate-pulse rounded bg-gray-200"></div>
              <div className="h-3 w-24 animate-pulse rounded bg-gray-200"></div>
            </div>
          </div>
          <div className="h-4 w-4 animate-pulse rounded bg-gray-200"></div>
        </div>

        <div className="space-y-2 border-t border-gray-200 pt-3">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2">
              <div className="h-4 w-4 animate-pulse rounded bg-gray-200"></div>
              <div className="h-3 w-40 animate-pulse rounded bg-gray-200"></div>
            </div>
            <div className="h-3 w-3 animate-pulse rounded bg-gray-200"></div>
          </div>

          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2">
              <div className="h-4 w-4 animate-pulse rounded bg-gray-200"></div>
              <div className="h-3 w-36 animate-pulse rounded bg-gray-200"></div>
            </div>
            <div className="h-3 w-3 animate-pulse rounded bg-gray-200"></div>
          </div>
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/product/ProductVariantPromotion.tsx
------------------------------------------------------------------------------------
import { getPriceIfHasPromotion } from '@/components/product/ProductVariant.helpers'
import { type ProductVariants } from '@/types/domain'
import { type FC } from 'react'

interface ProductVariantPromotionProps {
  variant: ProductVariants
}
export const ProductVariantPromotion: FC<ProductVariantPromotionProps> = ({
  variant
}) => {
  const { hasPromotion, currentPromotion } = getPriceIfHasPromotion(variant)

  return (
    <>
      {hasPromotion && (
        <div className="flex items-center bg-gradient-to-r from-red-500 to-red-700 p-3 text-sm">
          <p className="line-clamp-1 text-[17px] font-bold leading-[17px] text-white">
            {currentPromotion?.promotion?.name}:{' '}
            {currentPromotion?.promotion?.description}
          </p>
        </div>
      )}
    </>
  )
}



üìÅ ARCHIVO: src/components/checkout/ReviewStep.tsx
------------------------------------------------------------------------------------
// üìÑ app/checkout/components/ReviewStep.tsx
import { type CheckoutData, type CheckoutSummary, type CheckoutUser } from '@/types/checkout'
import { useState } from 'react'

interface ReviewStepProps {
  user: CheckoutUser
  summary: CheckoutSummary
  checkoutData?: Partial<CheckoutData>
  onProcess: () => void
  onPrev: () => void
  loading: boolean
}

export default function ReviewStep({
  user,
  summary,
  checkoutData,
  onProcess,
  onPrev,
  loading
}: ReviewStepProps) {
  const [couponCode, setCouponCode] = useState('')
  const [customerNotes, setCustomerNotes] = useState('')
  const [acceptTerms, setAcceptTerms] = useState(false)

  const selectedAddress = summary.selectedAddress
  const selectedShipping = summary.selectedShipping
  const selectedPayment = summary.selectedPayment

  const handleApplyCoupon = async () => {
    // TODO: Implementar aplicaci√≥n de cup√≥n
    console.log('Aplicar cup√≥n:', couponCode)
  }

  const canProceed =
    acceptTerms && selectedAddress && selectedShipping && selectedPayment

  return (
    <div className="space-y-6">
      {/* Resumen del pedido */}
      <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm">
        <h2 className="mb-6 text-xl font-semibold text-gray-900">
          Revisar pedido
        </h2>

        {/* Items del pedido */}
        <div className="mb-6">
          <h3 className="mb-4 text-lg font-medium text-gray-900">
            Productos ({summary.itemCount})
          </h3>

          <div className="space-y-4">
            {summary.items.map((item) => {
              let displayPrice = item.price

              // Mostrar precio promocional si existe
              if (item.promotionVariants && item.promotionVariants.length > 0) {
                const activePromotion = item.promotionVariants.find(
                  (pv: any) =>
                    pv.promotion.isActive === 1 &&
                    new Date() >= new Date(pv.promotion.startDate) &&
                    new Date() <= new Date(pv.promotion.endDate)
                )

                if (activePromotion) {
                  displayPrice = parseFloat(activePromotion.promotionPrice)
                }
              }

              return (
                <div key={item.id} className="flex items-center space-x-4">
                  <div className="h-20 w-20 flex-shrink-0">
                    <img
                      src={item.image}
                      alt={item.name}
                      className="h-20 w-20 rounded-md object-cover object-center"
                    />
                  </div>
                  <div className="min-w-0 flex-1">
                    <h4 className="line-clamp-2 text-sm font-medium text-gray-900">
                      {item.name}
                    </h4>
                    <div className="mt-1 flex items-center space-x-2">
                      {displayPrice < item.price && (
                        <span className="text-sm text-gray-500 line-through">
                          S/ {item.price.toFixed(2)}
                        </span>
                      )}
                      <span className="text-sm font-medium text-gray-900">
                        S/ {displayPrice.toFixed(2)}
                      </span>
                    </div>
                    <p className="text-sm text-gray-500">
                      Cantidad: {item.quantity}
                    </p>
                  </div>
                  <div className="text-right">
                    <p className="text-sm font-medium text-gray-900">
                      S/ {(displayPrice * item.quantity).toFixed(2)}
                    </p>
                  </div>
                </div>
              )
            })}
          </div>
        </div>

        {/* Informaci√≥n de env√≠o */}
        {selectedAddress && selectedShipping && (
          <div className="mb-6 border-t border-gray-200 pt-6">
            <h3 className="mb-4 text-lg font-medium text-gray-900">
              Informaci√≥n de env√≠o
            </h3>

            <div className="grid grid-cols-1 gap-6 md:grid-cols-2">
              <div>
                <h4 className="mb-2 text-sm font-medium text-gray-900">
                  Direcci√≥n de entrega
                </h4>
                <div className="text-sm text-gray-600">
                  <p className="font-medium">{selectedAddress.alias}</p>
                  <p>
                    {selectedAddress.streetName} {selectedAddress.streetNumber}
                    {selectedAddress.apartment &&
                      `, ${selectedAddress.apartment}`}
                  </p>
                  <p>
                    {selectedAddress.district}, {selectedAddress.province}
                  </p>
                  <p>{selectedAddress.department}</p>
                </div>
              </div>

              <div>
                <h4 className="mb-2 text-sm font-medium text-gray-900">
                  M√©todo de env√≠o
                </h4>
                <div className="text-sm text-gray-600">
                  <p className="font-medium">{selectedShipping.methodName}</p>
                  <p>
                    Entrega en {selectedShipping.estimatedDays.min}-
                    {selectedShipping.estimatedDays.max} d√≠as
                  </p>
                  <p className="font-medium">
                    {selectedShipping.isFree
                      ? 'Gratis'
                      : `S/ ${selectedShipping.cost.toFixed(2)}`}
                  </p>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Informaci√≥n de pago */}
        {selectedPayment && (
          <div className="mb-6 border-t border-gray-200 pt-6">
            <h3 className="mb-4 text-lg font-medium text-gray-900">
              M√©todo de pago
            </h3>

            <div className="text-sm text-gray-600">
              <p className="font-medium">{selectedPayment.methodName}</p>
              {selectedPayment.processingFee > 0 && (
                <p className="text-orange-600">
                  Incluye comisi√≥n de S/{' '}
                  {Number(selectedPayment.processingFee).toFixed(2)}
                </p>
              )}
            </div>
          </div>
        )}

        {/* Cup√≥n de descuento */}
        <div className="mb-6 border-t border-gray-200 pt-6">
          <h3 className="mb-4 text-lg font-medium text-gray-900">
            Cup√≥n de descuento
          </h3>

          <div className="flex space-x-4">
            <div className="flex-1">
              <input
                type="text"
                value={couponCode}
                onChange={(e) => { setCouponCode(e.target.value) }}
                placeholder="Ingresa tu c√≥digo de cup√≥n"
                className="block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
              />
            </div>
            <button
              type="button"
              onClick={handleApplyCoupon}
              disabled={!couponCode.trim()}
              className="focus:outline-focus:ring-2 rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50 focus:ring-indigo-500 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
            >
              Aplicar
            </button>
          </div>
        </div>

        {/* Notas del cliente */}
        <div className="mb-6 border-t border-gray-200 pt-6">
          <h3 className="mb-4 text-lg font-medium text-gray-900">
            Notas del pedido (opcional)
          </h3>

          <textarea
            value={customerNotes}
            onChange={(e) => { setCustomerNotes(e.target.value) }}
            rows={3}
            placeholder="Instrucciones especiales para la entrega..."
            className="block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          />
        </div>

        {/* Resumen de totales */}
        <div className="border-t border-gray-200 pt-6">
          <div className="space-y-2">
            <div className="flex justify-between text-sm">
              <span className="text-gray-600">Subtotal</span>
              <span>S/ {Number(summary.calculation.subtotal).toFixed(2)}</span>
            </div>

            {summary.calculation.discountAmount > 0 && (
              <div className="flex justify-between text-sm">
                <span className="text-gray-600">Descuento</span>
                <span className="text-green-600">
                  -S/ {Number(summary.calculation.discountAmount).toFixed(2)}
                </span>
              </div>
            )}

            <div className="flex justify-between text-sm">
              <span className="text-gray-600">Env√≠o</span>
              <span>
                {summary.calculation.shippingCost === 0
                  ? 'Gratis'
                  : `S/ ${Number(summary.calculation.shippingCost).toFixed(2)}`}
              </span>
            </div>

            {selectedPayment?.processingFee > 0 && (
              <div className="flex justify-between text-sm">
                <span className="text-gray-600">Comisi√≥n de pago</span>
                <span className="text-orange-600">
                  S/ {Number(selectedPayment.processingFee).toFixed(2)}
                </span>
              </div>
            )}

            <div className="flex justify-between text-sm">
              <span className="text-gray-600">IGV (18%)</span>
              <span>S/ {Number(summary.calculation.taxAmount).toFixed(2)}</span>
            </div>

            <div className="border-t border-gray-200 pt-2">
              <div className="flex justify-between text-lg font-semibold">
                <span>Total</span>
                <span>
                  S/ {Number(summary.calculation.totalAmount).toFixed(2)}
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* T√©rminos y condiciones */}
      <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm">
        <div className="flex items-center">
          <input
            id="accept-terms"
            type="checkbox"
            checked={acceptTerms}
            onChange={(e) => { setAcceptTerms(e.target.checked) }}
            className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
          />
          <label htmlFor="accept-terms" className="ml-3 text-sm text-gray-600">
            Acepto los{' '}
            <a
              href="/terms"
              className="font-medium text-indigo-600 hover:text-indigo-500"
            >
              t√©rminos y condiciones
            </a>{' '}
            y la{' '}
            <a
              href="/privacy"
              className="font-medium text-indigo-600 hover:text-indigo-500"
            >
              pol√≠tica de privacidad
            </a>
          </label>
        </div>
      </div>

      {/* Botones de navegaci√≥n */}
      <div className="flex justify-between">
        <button
          type="button"
          onClick={onPrev}
          className="rounded-md border border-gray-300 bg-white px-6 py-3 text-sm font-semibold text-gray-900 shadow-sm hover:bg-gray-50 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-gray-600"
        >
          Volver al pago
        </button>

        <button
          type="button"
          onClick={onProcess}
          disabled={!canProceed || loading}
          className="rounded-md bg-indigo-600 px-8 py-3 text-sm font-semibold text-white shadow-sm hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600 disabled:cursor-not-allowed disabled:opacity-50"
        >
          {loading ? 'Procesando...' : 'Confirmar pedido'}
        </button>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/checkout/ShippingStep.tsx
------------------------------------------------------------------------------------
// üìÑ app/checkout/components/ShippingStep.tsx
import { type CheckoutSummary, type CheckoutUser, type ShippingOption } from '@/types/checkout'
import { useState } from 'react'

interface ShippingStepProps {
  user: CheckoutUser
  summary: CheckoutSummary
  selectedAddressId?: number
  onAddressChange: (addressId: number) => void
  onShippingMethodChange: (option: ShippingOption) => void
  onNext: () => void
  loading: boolean
}

export default function ShippingStep({
  user,
  summary,
  selectedAddressId,
  onAddressChange,
  onShippingMethodChange,
  onNext,
  loading
}: ShippingStepProps) {
  const [selectedShippingMethod, setSelectedShippingMethod] = useState<
    number | null
  >(null)
  const currentAddressId =
    selectedAddressId || user.defaultAddressId || user.addresses[0]?.id

  const handleShippingMethodSelect = (option: ShippingOption) => {
    setSelectedShippingMethod(option.methodId)
    onShippingMethodChange(option)
  }

  const canProceed = currentAddressId && selectedShippingMethod

  console.log('summary.shippingOptions', summary.shippingOptions)

  return (
    <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm">
      <h2 className="mb-6 text-xl font-semibold text-gray-900">
        Informaci√≥n de env√≠o
      </h2>

      {/* Direcciones */}
      <div className="mb-8">
        <h3 className="mb-4 text-lg font-medium text-gray-900">
          Direcci√≥n de entrega
        </h3>

        <div className="space-y-4">
          {user.addresses.map((address) => (
            <div
              key={address.id}
              className={`relative cursor-pointer rounded-lg border p-4 transition-colors ${
                currentAddressId === address.id
                  ? 'border-indigo-600 bg-indigo-50'
                  : 'border-gray-200 hover:border-gray-300'
              } `}
              onClick={() => { onAddressChange(address.id) }}
            >
              <div className="flex items-center">
                <input
                  type="radio"
                  name="shipping-address"
                  value={address.id}
                  checked={currentAddressId === address.id}
                  onChange={() => { onAddressChange(address.id) }}
                  className="h-4 w-4 border-gray-300 text-indigo-600 focus:ring-indigo-500"
                />
                <div className="ml-3 flex-1">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium text-gray-900">
                      {address.alias}
                    </h4>
                    {address.isDefault === 1 && (
                      <span className="inline-flex items-center rounded-full bg-green-100 px-2.5 py-0.5 text-xs font-medium text-green-800">
                        Por defecto
                      </span>
                    )}
                  </div>
                  <p className="mt-1 text-sm text-gray-600">
                    {address.streetName} {address.streetNumber}
                    {address.apartment && `, ${address.apartment}`}
                  </p>
                  <p className="text-sm text-gray-600">
                    {address.district}, {address.province}, {address.department}
                  </p>
                </div>
              </div>
            </div>
          ))}
        </div>

        <button
          type="button"
          className="mt-4 text-sm font-medium text-indigo-600 hover:text-indigo-500"
        >
          + Agregar nueva direcci√≥n
        </button>
      </div>

      {/* M√©todos de env√≠o */}
      {summary.shippingOptions.length > 0 && (
        <div className="mb-8">
          <h3 className="mb-4 text-lg font-medium text-gray-900">
            M√©todo de env√≠o
          </h3>

          <div className="space-y-4">
            {summary.shippingOptions.map((option) => (
              <div
                key={option.methodId}
                className={`relative cursor-pointer rounded-lg border p-4 transition-colors ${
                  selectedShippingMethod === option.methodId
                    ? 'border-indigo-600 bg-indigo-50'
                    : 'border-gray-200 hover:border-gray-300'
                } `}
                onClick={() => { handleShippingMethodSelect(option) }}
              >
                <div className="flex items-center">
                  <input
                    type="radio"
                    name="shipping-method"
                    value={option.methodId}
                    checked={selectedShippingMethod === option.methodId}
                    onChange={() => { handleShippingMethodSelect(option) }}
                    className="h-4 w-4 border-gray-300 text-indigo-600 focus:ring-indigo-500"
                  />
                  <div className="ml-3 flex-1">
                    <div className="flex items-center justify-between">
                      <h4 className="text-sm font-medium text-gray-900">
                        {option.methodName}
                      </h4>
                      <div className="text-right">
                        {option.isFree ? (
                          <span className="text-sm font-medium text-green-600">
                            Gratis
                          </span>
                        ) : (
                          <span className="text-sm font-medium text-gray-900">
                            S/ {Number(option.cost).toFixed(2)}
                          </span>
                        )}
                      </div>
                    </div>
                    <div className="mt-1 flex items-center justify-between">
                      <p className="text-sm text-gray-600">
                        Entrega estimada: {option.estimatedDays.min}-
                        {option.estimatedDays.max} d√≠as
                      </p>
                      {option.description && (
                        <span className="text-xs text-green-600">
                          {option.description}
                        </span>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Bot√≥n continuar */}
      <div className="flex justify-end">
        <button
          type="button"
          onClick={onNext}
          disabled={!canProceed || loading}
          className="rounded-md bg-indigo-600 px-6 py-3 text-sm font-semibold text-white shadow-sm hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600 disabled:cursor-not-allowed disabled:opacity-50"
        >
          {loading ? 'Cargando...' : 'Continuar al pago'}
        </button>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/checkout/ProcessingStep.tsx
------------------------------------------------------------------------------------
export default function ProcessingStep() {
  return (
    <div className="py-12 text-center">
      <div className="mx-auto h-12 w-12 animate-spin rounded-full border-4 border-gray-300 border-t-indigo-600"></div>
      <h2 className="mt-4 text-lg font-medium text-gray-900">
        Procesando tu pedido...
      </h2>
      <p className="mt-2 text-gray-600">
        Por favor espera mientras procesamos tu compra de forma segura.
      </p>
    </div>
  )
}



üìÅ ARCHIVO: src/components/checkout/useStockValidation.ts
------------------------------------------------------------------------------------
'use client'
import { useRouter } from 'next/navigation'
import { useState } from 'react'

interface StockError {
  variantId: number
  productName: string
  requestedQuantity: number
  availableStock: number
  message: string
}

interface ValidationResult {
  isValid: boolean
  errors: StockError[]
  hasOutOfStock: boolean
  hasReducedStock: boolean
}

interface StockValidationModal {
  isOpen: boolean
  result: ValidationResult | null
  onConfirm: (() => void) | null
  onCancel: (() => void) | null
}

export function useStockValidation() {
  const router = useRouter()
  const [isValidating, setIsValidating] = useState(false)
  const [modal, setModal] = useState<StockValidationModal>({
    isOpen: false,
    result: null,
    onConfirm: null,
    onCancel: null
  })

  // ‚úÖ Funci√≥n para validar stock (solo informativa)
  const validateAndProceedToCheckout = async (
    items: Array<{ id: number, name: string, quantity: number }>,
    onStockInfoReceived?: (
      stockInfo: Array<{ id: number, availableStock: number }>
    ) => void
  ): Promise<boolean> => {
    setIsValidating(true)

    try {
      console.log('üîç Validating stock for cart items:', items)

      const response = await fetch('/api/checkout/validate-stock', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ items })
      })

      if (!response.ok) {
        throw new Error('Error validating stock')
      }

      const validation = await response.json()
      console.log('üìä Stock validation result:', validation)

      if (validation.isValid) {
        // ‚úÖ Todo est√° bien, proceder al checkout
        console.log('‚úÖ Stock validation passed, proceeding to checkout')
        router.push('/checkout')
        return true
      } else {
        // ‚úÖ Hay problemas de stock - SOLO informar, no cambiar
        console.log('‚ö†Ô∏è Stock validation failed, showing informational modal')
        const result = processValidationErrors(validation.errors, items)

        // ‚úÖ Enviar informaci√≥n de stock actualizada para mostrar en carrito
        if (onStockInfoReceived) {
          const stockInfo = validation.errors.map((error: any) => ({
            id: error.variantId,
            availableStock: error.availableStock
          }))
          console.log('üì¶ Sending stock info to cart:', stockInfo)
          onStockInfoReceived(stockInfo)
        }

        return new Promise((resolve) => {
          setModal({
            isOpen: true,
            result,
            onConfirm: () => {
              // ‚úÖ Solo cerrar modal - NO hacer cambios autom√°ticos
              console.log('‚úÖ User acknowledged stock issues, closing modal')
              closeModal()
              resolve(false) // No proceder al checkout
            },
            onCancel: () => {
              console.log('‚ùå User cancelled stock validation')
              closeModal()
              resolve(false)
            }
          })
        })
      }
    } catch (error) {
      console.error('‚ùå Error validating stock:', error)
      // En caso de error de red, permitir continuar (fallback)
      router.push('/checkout')
      return true
    } finally {
      setIsValidating(false)
    }
  }

  // Procesar errores de validaci√≥n
  const processValidationErrors = (
    errors: any[],
    originalItems: Array<{ id: number, name: string, quantity: number }>
  ): ValidationResult => {
    const stockErrors: StockError[] = errors.map((error) => {
      const originalItem = originalItems.find(
        (item) => item.id === error.variantId
      )
      return {
        variantId: error.variantId,
        productName: originalItem?.name || 'Producto desconocido',
        requestedQuantity: error.requestedQuantity,
        availableStock: error.availableStock,
        message: error.message
      }
    })

    const hasOutOfStock = stockErrors.some(
      (error) => error.availableStock === 0
    )
    const hasReducedStock = stockErrors.some(
      (error) =>
        error.availableStock > 0 &&
        error.availableStock < error.requestedQuantity
    )

    return {
      isValid: false,
      errors: stockErrors,
      hasOutOfStock,
      hasReducedStock
    }
  }

  const closeModal = () => {
    setModal({
      isOpen: false,
      result: null,
      onConfirm: null,
      onCancel: null
    })
  }

  return {
    isValidating,
    modal,
    validateAndProceedToCheckout,
    closeModal
  }
}

export function useCheckoutNavigation() {
  const { validateAndProceedToCheckout, ...rest } = useStockValidation()

  // ‚úÖ Para usar desde el carrito (solo informativo)
  const proceedFromCart = async (
    cartItems: Array<{ id: number, name: string, quantity: number }>,
    onStockInfoReceived: (
      stockInfo: Array<{ id: number, availableStock: number }>
    ) => void
  ) => {
    return await validateAndProceedToCheckout(cartItems, onStockInfoReceived)
  }

  // Para usar desde PDP (compra directa)
  const proceedFromPDP = async (
    productId: number,
    productName: string,
    quantity: number
  ) => {
    return await validateAndProceedToCheckout([
      {
        id: productId,
        name: productName,
        quantity
      }
    ])
  }

  return {
    ...rest,
    proceedFromCart,
    proceedFromPDP
  }
}



üìÅ ARCHIVO: src/components/checkout/PaymentStep.tsx
------------------------------------------------------------------------------------
// üìÑ app/checkout/components/PaymentStep.tsx
import { type PaymentOption } from '@/types/checkout'
import { type PaymentMethods } from '@/types/domain'
import { useState } from 'react'

interface PaymentStepProps {
  paymentMethods: PaymentMethods[]
  paymentOptions: PaymentOption[]
  selectedPayment?: PaymentOption
  onPaymentMethodChange: (option: PaymentOption) => void
  onNext: () => void
  onPrev: () => void
  loading: boolean
}

export default function PaymentStep({
  paymentMethods,
  paymentOptions,
  selectedPayment,
  onPaymentMethodChange,
  onNext,
  onPrev,
  loading
}: PaymentStepProps) {
  const [selectedMethodId, setSelectedMethodId] = useState<number | null>(
    selectedPayment?.methodId || null
  )

  const handlePaymentMethodSelect = (methodId: number) => {
    setSelectedMethodId(methodId)

    // Buscar el m√©todo completo
    const method = paymentMethods.find((m) => m.id === methodId)
    const option = paymentOptions.find((o) => o.methodId === methodId)

    if (method && option) {
      onPaymentMethodChange({
        ...option,
        methodName: method.name,
        methodCode: method.code,
        iconUrl: method.iconUrl || undefined,
        description: method.description || undefined,
        requiresVerification: method.requiresVerification === 1
      })
    }
  }

  const canProceed = selectedMethodId !== null

  // Obtener m√©todos de pago disponibles combinando ambas fuentes
  const availableMethods = paymentMethods.filter(
    (method) =>
      method.isActive === 1 &&
      paymentOptions.some((option) => option.methodId === method.id)
  )

  return (
    <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm">
      <h2 className="mb-6 text-xl font-semibold text-gray-900">
        M√©todo de pago
      </h2>

      <div className="mb-8 space-y-4">
        {availableMethods.map((method) => {
          const option = paymentOptions.find((o) => o.methodId === method.id)
          if (!option) return null

          return (
            <div
              key={method.id}
              className={`relative cursor-pointer rounded-lg border p-4 transition-colors ${
                selectedMethodId === method.id
                  ? 'border-indigo-600 bg-indigo-50'
                  : 'border-gray-200 hover:border-gray-300'
              } `}
              onClick={() => { handlePaymentMethodSelect(method.id) }}
            >
              <div className="flex items-center">
                <input
                  type="radio"
                  name="payment-method"
                  value={method.id}
                  checked={selectedMethodId === method.id}
                  onChange={() => { handlePaymentMethodSelect(method.id) }}
                  className="h-4 w-4 border-gray-300 text-indigo-600 focus:ring-indigo-500"
                />

                <div className="ml-3 flex-1">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center space-x-3">
                      {method.iconUrl && (
                        <img
                          src={method.iconUrl}
                          alt={method.name}
                          className="h-8 w-auto"
                        />
                      )}
                      <div>
                        <h4 className="text-sm font-medium text-gray-900">
                          {method.name}
                        </h4>
                        {method.description && (
                          <p className="text-xs text-gray-600">
                            {method.description}
                          </p>
                        )}
                      </div>
                    </div>

                    <div className="text-right">
                      {option.processingFee > 0 ? (
                        <div>
                          <p className="text-sm text-gray-900">
                            S/ {Number(option.baseAmount).toFixed(2)}
                          </p>
                          <p className="text-xs text-orange-600">
                            + S/ {Number(option.processingFee).toFixed(2)}{' '}
                            comisi√≥n
                          </p>
                          <p className="text-sm font-medium text-gray-900">
                            Total: S/ {Number(option.finalAmount).toFixed(2)}
                          </p>
                        </div>
                      ) : (
                        <p className="text-sm font-medium text-gray-900">
                          S/ {Number(option.finalAmount).toFixed(2)}
                        </p>
                      )}
                    </div>
                  </div>

                  {/* L√≠mites de monto */}
                  {(method.minAmount || method.maxAmount) && (
                    <div className="mt-2 text-xs text-gray-500">
                      {method.minAmount && method.maxAmount
                        ? `Monto entre S/ ${method.minAmount} - S/ ${method.maxAmount}`
                        : method.minAmount
                          ? `Monto m√≠nimo: S/ ${method.minAmount}`
                          : method.maxAmount
                            ? `Monto m√°ximo: S/ ${method.maxAmount}`
                            : null}
                    </div>
                  )}

                  {/* Verificaci√≥n requerida */}
                  {method.requiresVerification === 1 && (
                    <div className="mt-2 flex items-center space-x-1">
                      <svg
                        className="h-4 w-4 text-yellow-500"
                        fill="currentColor"
                        viewBox="0 0 20 20"
                      >
                        <path
                          fillRule="evenodd"
                          d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z"
                          clipRule="evenodd"
                        />
                      </svg>
                      <span className="text-xs text-yellow-700">
                        Requiere verificaci√≥n adicional
                      </span>
                    </div>
                  )}
                </div>
              </div>

              {/* Formulario espec√≠fico del m√©todo de pago */}
              {selectedMethodId === method.id && (
                <div className="mt-4 border-t border-gray-200 pt-4">
                  {renderPaymentForm(method)}
                </div>
              )}
            </div>
          )
        })}
      </div>

      {/* Informaci√≥n de seguridad */}
      <div className="mb-6 rounded-md bg-green-50 p-4">
        <div className="flex">
          <svg
            className="h-5 w-5 text-green-400"
            viewBox="0 0 20 20"
            fill="currentColor"
          >
            <path
              fillRule="evenodd"
              d="M10 1L5 6v6l5 5 5-5V6l-5-5zM8.5 6L10 4.5 11.5 6 13 7.5 11.5 9 10 7.5 8.5 6z"
              clipRule="evenodd"
            />
          </svg>
          <div className="ml-3">
            <h3 className="text-sm font-medium text-green-800">Pago seguro</h3>
            <p className="mt-1 text-sm text-green-700">
              Tu informaci√≥n de pago est√° protegida con encriptaci√≥n SSL de 256
              bits.
            </p>
          </div>
        </div>
      </div>

      {/* Botones de navegaci√≥n */}
      <div className="flex justify-between">
        <button
          type="button"
          onClick={onPrev}
          className="rounded-md border border-gray-300 bg-white px-6 py-3 text-sm font-semibold text-gray-900 shadow-sm hover:bg-gray-50 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-gray-600"
        >
          Volver al env√≠o
        </button>

        <button
          type="button"
          onClick={onNext}
          disabled={!canProceed || loading}
          className="rounded-md bg-indigo-600 px-6 py-3 text-sm font-semibold text-white shadow-sm hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600 disabled:cursor-not-allowed disabled:opacity-50"
        >
          {loading ? 'Cargando...' : 'Revisar pedido'}
        </button>
      </div>
    </div>
  )
}

// Funci√≥n para renderizar formularios espec√≠ficos por m√©todo de pago
function renderPaymentForm(method: PaymentMethods) {
  switch (method.code) {
    case 'card':
      return (
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700">
              N√∫mero de tarjeta
            </label>
            <input
              type="text"
              placeholder="1234 5678 9012 3456"
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            />
          </div>
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-700">
                Fecha de expiraci√≥n
              </label>
              <input
                type="text"
                placeholder="MM/AA"
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700">
                CVV
              </label>
              <input
                type="text"
                placeholder="123"
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
              />
            </div>
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700">
              Nombre del titular
            </label>
            <input
              type="text"
              placeholder="Juan P√©rez"
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            />
          </div>
        </div>
      )

    case 'yape':
    case 'plin':
      return (
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700">
              N√∫mero de tel√©fono
            </label>
            <input
              type="tel"
              placeholder="999 999 999"
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            />
          </div>
          <div className="rounded-md bg-blue-50 p-3">
            <p className="text-sm text-blue-700">
              Recibir√°s una notificaci√≥n en tu app de {method.name} para
              confirmar el pago.
            </p>
          </div>
        </div>
      )

    case 'bank_transfer':
      return (
        <div className="rounded-md bg-yellow-50 p-4">
          <div className="flex">
            <svg
              className="h-5 w-5 text-yellow-400"
              viewBox="0 0 20 20"
              fill="currentColor"
            >
              <path
                fillRule="evenodd"
                d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z"
                clipRule="evenodd"
              />
            </svg>
            <div className="ml-3">
              <h3 className="text-sm font-medium text-yellow-800">
                Transferencia bancaria
              </h3>
              <p className="mt-1 text-sm text-yellow-700">
                Recibir√°s los datos bancarios por email despu√©s de confirmar el
                pedido. Tienes 24 horas para realizar la transferencia.
              </p>
            </div>
          </div>
        </div>
      )

    case 'cash_on_delivery':
      return (
        <div className="rounded-md bg-green-50 p-4">
          <div className="flex">
            <svg
              className="h-5 w-5 text-green-400"
              viewBox="0 0 20 20"
              fill="currentColor"
            >
              <path d="M4 4a2 2 0 00-2 2v1h16V6a2 2 0 00-2-2H4z" />
              <path
                fillRule="evenodd"
                d="M18 9H2v5a2 2 0 002 2h12a2 2 0 002-2V9zM4 13a1 1 0 011-1h1a1 1 0 110 2H5a1 1 0 01-1-1zm5-1a1 1 0 100 2h1a1 1 0 100-2H9z"
                clipRule="evenodd"
              />
            </svg>
            <div className="ml-3">
              <h3 className="text-sm font-medium text-green-800">
                Pago contra entrega
              </h3>
              <p className="mt-1 text-sm text-green-700">
                Pagar√°s en efectivo al recibir tu pedido. Aseg√∫rate de tener el
                monto exacto.
              </p>
            </div>
          </div>
        </div>
      )

    default:
      return (
        <div className="rounded-md bg-gray-50 p-4">
          <p className="text-sm text-gray-600">
            Ser√°s redirigido para completar el pago con {method.name}.
          </p>
        </div>
      )
  }
}



üìÅ ARCHIVO: src/components/checkout/StockValidationModal.tsx
------------------------------------------------------------------------------------
// components/StockValidationModal.tsx - Adaptado para usar tu Modal
'use client'
import { Modal, ModalContent, ModalTitle } from '@/components/ui/Modal' // Ajusta la ruta seg√∫n tu estructura

interface StockError {
  variantId: number
  productName: string
  requestedQuantity: number
  availableStock: number
  message: string
}

interface ValidationResult {
  isValid: boolean
  errors: StockError[]
  hasOutOfStock: boolean
  hasReducedStock: boolean
}

interface StockValidationModalProps {
  isOpen: boolean
  result: ValidationResult | null
  onConfirm: (() => void) | null
  onCancel: (() => void) | null
}

export default function StockValidationModal({
  isOpen,
  result,
  onConfirm,
  onCancel
}: StockValidationModalProps) {
  if (!result) return null

  const { errors, hasOutOfStock, hasReducedStock } = result

  const outOfStockItems = errors.filter((error) => error.availableStock === 0)
  const reducedStockItems = errors.filter(
    (error) =>
      error.availableStock > 0 && error.availableStock < error.requestedQuantity
  )

  const getModalTitle = () => {
    if (hasOutOfStock && hasReducedStock) {
      return 'Problemas con el stock'
    } else if (hasOutOfStock) {
      return 'Productos no disponibles'
    } else {
      return 'Stock insuficiente'
    }
  }

  const getModalMessage = () => {
    if (hasOutOfStock && hasReducedStock) {
      return 'Algunos productos no est√°n disponibles y otros tienen stock limitado. Por favor, ajusta las cantidades en tu carrito.'
    } else if (hasOutOfStock) {
      return 'Algunos productos ya no est√°n disponibles. Por favor, ret√≠ralos de tu carrito.'
    } else {
      return 'Algunos productos tienen menos stock del solicitado. Por favor, reduce las cantidades en tu carrito.'
    }
  }

  const handleClose = () => {
    onCancel?.()
  }

  const handleUnderstood = () => {
    // ‚úÖ Solo informar al usuario, NO hacer cambios autom√°ticos
    onConfirm?.()
  }

  return (
    <Modal
      isOpen={isOpen}
      onClose={handleClose}
      className="max-w-lg p-4 pt-4" // Un poco m√°s ancho para el contenido
    >
      {/* Header con icono de advertencia */}
      <ModalTitle onClose={handleClose} className="mb-5 p-0">
        <div className="flex items-center gap-3">
          <div className="flex h-10 w-10 flex-shrink-0 items-center justify-center rounded-full bg-yellow-100">
            <svg
              className="h-5 w-5 text-yellow-600"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z"
              />
            </svg>
          </div>
          <p className="font-bold text-gray-900">{getModalTitle()}</p>
        </div>
      </ModalTitle>

      <ModalContent className="p-0">
        <div className="space-y-4">
          {/* Mensaje explicativo */}
          <div className="mb-4">
            <p className="text-sm text-gray-600">{getModalMessage()}</p>
          </div>

          {/* Lista de problemas de stock */}
          <div className="max-h-80 space-y-4 overflow-y-auto">
            {' '}
            {/* Scroll si hay muchos productos */}
            {/* Productos sin stock */}
            {outOfStockItems.length > 0 && (
              <div>
                <h4 className="mb-3 text-sm font-semibold text-red-800">
                  Sin stock disponible:
                </h4>
                <div className="space-y-2">
                  {outOfStockItems.map((error) => (
                    <div
                      key={error.variantId}
                      className="rounded-md border border-red-200 bg-red-50 p-3"
                    >
                      <p className="mb-1 text-sm font-medium text-red-800">
                        {error.productName}
                      </p>
                      <p className="mb-1 text-xs text-red-600">
                        Solicitado:{' '}
                        <span className="font-medium">
                          {error.requestedQuantity}
                        </span>{' '}
                        ‚Ä¢ Disponible:{' '}
                        <span className="font-medium">
                          {error.availableStock}
                        </span>
                      </p>
                      <p className="text-xs text-red-600">
                        ‚ùå Por favor, remueve este producto del carrito
                      </p>
                    </div>
                  ))}
                </div>
              </div>
            )}
            {/* Productos con stock reducido */}
            {reducedStockItems.length > 0 && (
              <div>
                <h4 className="mb-3 text-sm font-semibold text-orange-800">
                  Stock limitado:
                </h4>
                <div className="space-y-2">
                  {reducedStockItems.map((error) => (
                    <div
                      key={error.variantId}
                      className="rounded-md border border-orange-200 bg-orange-50 p-3"
                    >
                      <p className="mb-1 text-sm font-medium text-orange-800">
                        {error.productName}
                      </p>
                      <p className="mb-1 text-xs text-orange-600">
                        Solicitado:{' '}
                        <span className="font-medium">
                          {error.requestedQuantity}
                        </span>{' '}
                        ‚Ä¢ Disponible:{' '}
                        <span className="font-medium">
                          {error.availableStock}
                        </span>
                      </p>
                      <p className="text-xs text-orange-600">
                        ‚ö†Ô∏è Por favor, reduce la cantidad a m√°ximo{' '}
                        {error.availableStock} unidad
                        {error.availableStock !== 1 ? 'es' : ''}
                      </p>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>

          {/* Botones de acci√≥n */}
          <div className="flex justify-end gap-3 border-t pt-4">
            <button
              onClick={() => onCancel?.()}
              className="rounded-md border border-gray-300 px-4 py-2 text-sm font-semibold text-gray-700 transition-colors hover:bg-gray-50"
            >
              Cancelar
            </button>

            <button
              onClick={handleUnderstood}
              className="rounded-md bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition-colors hover:bg-indigo-700"
            >
              Entendido
            </button>
          </div>
        </div>
      </ModalContent>
    </Modal>
  )
}



üìÅ ARCHIVO: src/components/checkout/CartSummary.tsx
------------------------------------------------------------------------------------
import { type CartItem } from '@/hooks/useCart'
import {
  type OrderCalculation,
  type PaymentOption,
  type ShippingOption
} from '@/types/checkout'
import { type PromotionVariants } from '@/types/domain'

interface CartSummaryProps {
  items: CartItem[]
  calculation: OrderCalculation
  selectedShipping?: ShippingOption
  selectedPayment?: PaymentOption
}

export default function CartSummary({
  items,
  calculation,
  selectedShipping,
  selectedPayment
}: CartSummaryProps) {
  return (
    <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm">
      <h2 className="mb-4 text-lg font-medium text-gray-900">
        Resumen del pedido
      </h2>

      {/* Items */}
      <div className="mb-6 space-y-4">
        {items.map((item) => {
          let displayPrice = item.price

          // Mostrar precio promocional si existe
          if (item.promotionVariants && item.promotionVariants.length > 0) {
            const activePromotion = item.promotionVariants
              .filter((pv) => !!pv)
              .find(
                (pv: PromotionVariants) =>
                  pv?.promotion?.isActive === 1 &&
                  new Date() >= new Date(pv.promotion.startDate) &&
                  new Date() <= new Date(pv.promotion.endDate)
              )

            if (activePromotion) {
              displayPrice = parseFloat(activePromotion.promotionPrice)
            }
          }

          return (
            <div key={item.id} className="flex items-center space-x-4">
              <div className="h-16 w-16 flex-shrink-0">
                <img
                  src={item.image}
                  alt={item.name}
                  className="h-16 w-16 rounded-md object-cover object-center"
                />
              </div>
              <div className="min-w-0 flex-1">
                <h3 className="line-clamp-2 text-sm font-medium text-gray-900">
                  {item.name}
                </h3>
                <div className="mt-1 flex items-center space-x-2">
                  {displayPrice < item.price && (
                    <span className="text-sm text-gray-500 line-through">
                      S/ {Number(item.price.toFixed(2))}
                    </span>
                  )}
                  <span className="text-sm font-medium text-gray-900">
                    S/ {Number(displayPrice.toFixed(2))}
                  </span>
                </div>
                <p className="text-sm text-gray-500">
                  Cantidad: {item.quantity}
                </p>
              </div>
            </div>
          )
        })}
      </div>

      {/* M√©todos seleccionados */}
      {selectedShipping && (
        <div className="mb-4 rounded-md bg-gray-50 p-3">
          <div className="flex justify-between">
            <span className="text-sm text-gray-600">Env√≠o:</span>
            <span className="text-sm font-medium">
              {selectedShipping.methodName}
            </span>
          </div>
          {selectedShipping.isFree && (
            <p className="mt-1 text-xs text-green-600">¬°Env√≠o gratis!</p>
          )}
        </div>
      )}

      {selectedPayment && (
        <div className="mb-4 rounded-md bg-gray-50 p-3">
          <div className="flex justify-between">
            <span className="text-sm text-gray-600">Pago:</span>
            <span className="text-sm font-medium">
              {selectedPayment.methodName}
            </span>
          </div>
          {selectedPayment.processingFee > 0 && (
            <p className="mt-1 text-xs text-orange-600">
              Comisi√≥n: S/ {Number(selectedPayment.processingFee).toFixed(2)}
            </p>
          )}
        </div>
      )}

      {/* Totales */}
      <div className="space-y-2 border-t border-gray-200 pt-4">
        <div className="flex justify-between text-sm">
          <span className="text-gray-600">Subtotal</span>
          <span>S/ {Number(calculation.subtotal).toFixed(2)}</span>
        </div>

        {calculation.discountAmount > 0 && (
          <div className="flex justify-between text-sm">
            <span className="text-gray-600">Descuento</span>
            <span className="text-green-600">
              -S/ {Number(calculation.discountAmount).toFixed(2)}
            </span>
          </div>
        )}

        <div className="flex justify-between text-sm">
          <span className="text-gray-600">Env√≠o</span>
          <span>
            {calculation.shippingCost === 0
              ? 'Gratis'
              : `S/ ${Number(calculation.shippingCost).toFixed(2)}`}
          </span>
        </div>

        <div className="flex justify-between text-sm">
          <span className="text-gray-600">IGV (18%)</span>
          <span>S/ {Number(calculation.taxAmount).toFixed(2)}</span>
        </div>

        <div className="border-t border-gray-200 pt-2">
          <div className="flex justify-between text-lg font-semibold">
            <span>Total</span>
            <span>S/ {Number(calculation.totalAmount).toFixed(2)}</span>
          </div>
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/checkout/StepIndicator.tsx
------------------------------------------------------------------------------------
import { type CheckoutStep } from '@/types/checkout'

interface StepIndicatorProps {
  currentStep: CheckoutStep
}

const steps = [
  { key: 'shipping', label: 'Env√≠o', number: 1 },
  { key: 'payment', label: 'Pago', number: 2 },
  { key: 'review', label: 'Revisar', number: 3 },
  { key: 'processing', label: 'Procesando', number: 4 }
]

export default function StepIndicator({ currentStep }: StepIndicatorProps) {
  const getCurrentStepNumber = () => {
    return steps.find((step) => step.key === currentStep)?.number || 1
  }

  const currentStepNumber = getCurrentStepNumber()

  return (
    <div className="mb-8">
      <nav aria-label="Progress">
        <ol className="grid grid-cols-4">
          {steps.map((step) => (
            <li
              key={step.key}
              className="relative flex w-full flex-col items-center justify-center text-center"
            >
              {step.number < currentStepNumber ? (
                <div
                  className="absolute inset-0 bottom-5 flex items-center"
                  aria-hidden="true"
                >
                  <div className="h-0.5 w-full bg-indigo-600" />
                </div>
              ) : step.number === currentStepNumber ? (
                <div
                  className="absolute inset-0 bottom-5 flex items-center"
                  aria-hidden="true"
                >
                  <div className="h-0.5 w-full bg-gray-200" />
                </div>
              ) : (
                <div
                  className="absolute inset-0 bottom-5 flex items-center"
                  aria-hidden="true"
                >
                  <div className="h-0.5 w-full bg-gray-200" />
                </div>
              )}

              <div
                className={`relative flex h-8 w-8 items-center justify-center rounded-full ${
                  step.number < currentStepNumber
                    ? 'bg-indigo-600 text-white'
                    : step.number === currentStepNumber
                      ? 'border-2 border-indigo-600 bg-white text-indigo-600'
                      : 'border-2 border-gray-300 bg-white text-gray-500'
                } `}
              >
                {step.number < currentStepNumber ? (
                  <svg
                    className="h-5 w-5"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                  >
                    <path
                      fillRule="evenodd"
                      d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
                      clipRule="evenodd"
                    />
                  </svg>
                ) : (
                  <span>{step.number}</span>
                )}
              </div>

              <div className="mt-2 text-xs font-medium text-gray-900">
                {step.label}
              </div>
            </li>
          ))}
        </ol>
      </nav>
    </div>
  )
}



üìÅ ARCHIVO: src/components/checkout/CheckoutClient.tsx
------------------------------------------------------------------------------------
'use client'

// üìÑ app/checkout/CheckoutClient.tsx
import { useRouter } from 'next/navigation'
import { useEffect, useState } from 'react'

// Types
import {
  type CheckoutResponse,
  type CheckoutState,
  type CheckoutStep,
  type CheckoutSummary,
  type CheckoutUser,
  type PaymentOption,
  type ShippingOption
} from '@/types/checkout'
import { type PaymentMethods } from '@/types/domain'

// Components
import { type CartItem } from '@/hooks/useCart'
import CartSummary from './CartSummary'
import PaymentStep from './PaymentStep'
import ProcessingStep from './ProcessingStep'
import ReviewStep from './ReviewStep'
import ShippingStep from './ShippingStep'
import StepIndicator from './StepIndicator'

interface CheckoutClientProps {
  user: CheckoutUser
  paymentMethods: PaymentMethods[]
}

export default function CheckoutClient({
  user,
  paymentMethods
}: CheckoutClientProps) {
  const router = useRouter()

  const [state, setState] = useState<CheckoutState>({
    step: 'shipping',
    loading: false,
    data: {}
  })

  const [cartItems, setCartItems] = useState<CartItem[]>([])
  const [summary, setSummary] = useState<CheckoutSummary | null>(null)

  // Cargar items del carrito desde localStorage
  useEffect(() => {
    const savedCart = localStorage.getItem('cart')
    if (savedCart) {
      try {
        const items = JSON.parse(savedCart) as CartItem[]
        setCartItems(items)

        if (items.length === 0) {
          router.push('/cart')
          return
        }

        // Obtener datos iniciales del checkout
        fetchCheckoutData(items)
      } catch (error) {
        console.error('Error parsing cart:', error)
        router.push('/cart')
      }
    } else {
      router.push('/cart')
    }
  }, [router])

  // Obtener datos del checkout desde la API
  const fetchCheckoutData = async (
    items: CartItem[],
    shippingAddressId?: number
  ) => {
    setState((prev) => ({ ...prev, loading: true }))

    try {
      const response = await fetch('/api/checkout/data', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          items,
          shippingAddressId: shippingAddressId || user.defaultAddressId
        })
      })

      if (!response.ok) {
        throw new Error('Error obteniendo datos del checkout')
      }

      const data = await response.json()
      setSummary(data.summary)
    } catch (error) {
      console.error('Error fetching checkout data:', error)
      setState((prev) => ({
        ...prev,
        error: 'Error cargando datos del checkout'
      }))
    } finally {
      setState((prev) => ({ ...prev, loading: false }))
    }
  }

  // Manejar cambio de direcci√≥n de env√≠o
  const handleShippingAddressChange = (addressId: number) => {
    setState((prev) => ({
      ...prev,
      data: { ...prev.data, shippingAddressId: addressId }
    }))

    fetchCheckoutData(cartItems, addressId)
  }

  // Manejar cambio de m√©todo de env√≠o
  const handleShippingMethodChange = (option: ShippingOption) => {
    setState((prev) => ({
      ...prev,
      data: {
        ...prev.data,
        shippingMethodId: option.methodId,
        shippingMethodName: option.methodName
      }
    }))

    if (summary) {
      const updatedCalculation = {
        ...summary.calculation,
        shippingCost: option.cost,
        totalAmount:
          summary.calculation.subtotal -
          summary.calculation.discountAmount +
          option.cost +
          summary.calculation.taxAmount
      }

      setSummary({
        ...summary,
        calculation: updatedCalculation,
        selectedShipping: option
      })
    }
  }

  // Manejar cambio de m√©todo de pago
  const handlePaymentMethodChange = (option: PaymentOption) => {
    setState((prev) => ({
      ...prev,
      data: {
        ...prev.data,
        paymentMethodId: option.methodId,
        paymentMethodCode: option.methodCode
      }
    }))

    if (summary) {
      setSummary({
        ...summary,
        selectedPayment: option
      })
    }
  }

  // Avanzar al siguiente paso
  const nextStep = () => {
    const steps: CheckoutStep[] = [
      'shipping',
      'payment',
      'review',
      'processing'
    ]
    const currentIndex = steps.indexOf(state.step)

    if (currentIndex < steps.length - 1) {
      setState((prev) => ({ ...prev, step: steps[currentIndex + 1] }))
    }
  }

  // Retroceder al paso anterior
  const prevStep = () => {
    const steps: CheckoutStep[] = [
      'shipping',
      'payment',
      'review',
      'processing'
    ]
    const currentIndex = steps.indexOf(state.step)

    if (currentIndex > 0) {
      setState((prev) => ({ ...prev, step: steps[currentIndex - 1] }))
    }
  }

  // Procesar el checkout
  const processCheckout = async () => {
    console.log('summary?.selectedShipping', summary?.selectedShipping)
    console.log('summary?.selectedPayment', summary?.selectedPayment)
    console.log('state.data.shippingAddressId', state.data.shippingAddressId)

    if (
      !summary?.selectedShipping ||
      !summary?.selectedPayment ||
      !state.data.shippingAddressId
    ) {
      setState((prev) => ({ ...prev, error: 'Faltan datos requeridos' }))
      return
    }

    setState((prev) => ({ ...prev, step: 'processing', loading: true }))

    try {
      const checkoutData = {
        items: cartItems,
        shippingAddressId: state.data.shippingAddressId,
        paymentMethodId: summary.selectedPayment.methodId,
        paymentMethodCode: summary.selectedPayment.methodCode,
        shippingMethodId: summary.selectedShipping.methodId,
        shippingMethodName: summary.selectedShipping.methodName,
        couponCode: state.data.couponCode,
        customerNotes: state.data.customerNotes,
        paymentData: state.data.paymentData
      }

      console.log('checkoutData', checkoutData)

      const response = await fetch('/api/checkout', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(checkoutData)
      })

      const result: CheckoutResponse = await response.json()

      console.log('result', result)

      if (result.success) {
        // Limpiar carrito
        localStorage.removeItem('cart')

        // Redirigir seg√∫n el m√©todo de pago
        if (result.paymentUrl) {
          window.location.href = result.paymentUrl
        } else {
          router.push(`/orders/${result.orderNumber}`)
        }
      } else {
        setState((prev) => ({
          ...prev,
          error: result.error || 'Error procesando el checkout',
          step: 'review'
        }))
      }
    } catch (error) {
      console.error('Error processing checkout:', error)
      setState((prev) => ({
        ...prev,
        error: 'Error procesando el checkout',
        step: 'review'
      }))
    } finally {
      setState((prev) => ({ ...prev, loading: false }))
    }
  }

  if (cartItems.length === 0) {
    return (
      <div className="py-12 text-center">
        <p className="text-gray-600">Cargando...</p>
      </div>
    )
  }

  return (
    <div className="grid grid-cols-1 gap-8 lg:grid-cols-3">
      {/* Columna principal - Pasos del checkout */}
      <div className="lg:col-span-2">
        <StepIndicator currentStep={state.step} />

        {state.error && (
          <div className="mb-6 rounded-md bg-red-50 p-4">
            <div className="text-sm text-red-700">{state.error}</div>
          </div>
        )}

        {state.step === 'shipping' && summary && (
          <ShippingStep
            user={user}
            summary={summary}
            selectedAddressId={state.data.shippingAddressId}
            onAddressChange={handleShippingAddressChange}
            onShippingMethodChange={handleShippingMethodChange}
            onNext={nextStep}
            loading={state.loading}
          />
        )}

        {state.step === 'payment' && summary && (
          <PaymentStep
            paymentMethods={paymentMethods}
            paymentOptions={summary.paymentOptions}
            selectedPayment={summary.selectedPayment}
            onPaymentMethodChange={handlePaymentMethodChange}
            onNext={nextStep}
            onPrev={prevStep}
            loading={state.loading}
          />
        )}

        {state.step === 'review' && summary && (
          <ReviewStep
            user={user}
            summary={summary}
            checkoutData={state.data}
            onProcess={processCheckout}
            onPrev={prevStep}
            loading={state.loading}
          />
        )}

        {state.step === 'processing' && <ProcessingStep />}
      </div>

      {/* Columna lateral - Resumen del carrito */}
      <div className="lg:col-span-1">
        {summary && (
          <CartSummary
            items={cartItems}
            calculation={summary.calculation}
            selectedShipping={summary.selectedShipping}
            selectedPayment={summary.selectedPayment}
          />
        )}
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/search/BrandFilter.tsx
------------------------------------------------------------------------------------
'use client'
import CollapsibleSection from '@/components/ui/CollapsibleSection'
import { usePathname, useRouter, useSearchParams } from 'next/navigation'
import React from 'react'

import { type AvailableFilters } from '@/backend/filters'
import { type ProductSearchFilters } from '@/backend/search'

interface BrandFilterProps {
  availableFilters: AvailableFilters
  currentFilters: ProductSearchFilters
}

const BrandFilter: React.FC<BrandFilterProps> = ({
  availableFilters,
  currentFilters
}) => {
  const pathname = usePathname()
  const searchParams = useSearchParams()
  const router = useRouter()

  const updateFilter = (key: string, value: string | null) => {
    const params = new URLSearchParams(searchParams.toString())

    if (value === null || value === '') {
      params.delete(key)
    } else {
      params.set(key, value)
    }

    params.set('page', '1') // Reset to first page when filtering
    router.push(`${pathname}?${params.toString()}`)
  }

  if (!availableFilters?.brands || availableFilters.brands.length === 0) {
    return null
  }

  return (
    <CollapsibleSection title="Marcas" className="mb-0">
      <div className="space-y-2">
        {availableFilters.brands.map((brand) => (
          <label key={brand.id} className="flex items-center">
            <input
              type="radio"
              name="brand"
              value={brand.id}
              checked={currentFilters.brandId === brand.id}
              onChange={(e) => { updateFilter('brand', e.target.checked ? e.target.value : null) }
              }
              className="mr-2"
            />
            <span className="text-sm">
              {brand.name} ({brand.count})
            </span>
          </label>
        ))}
      </div>
    </CollapsibleSection>
  )
}

export default BrandFilter



üìÅ ARCHIVO: src/components/search/Pagination.tsx
------------------------------------------------------------------------------------
'use client'
import { ChevronLeft, ChevronRight } from 'lucide-react'
import Link from 'next/link'
import { usePathname, useSearchParams } from 'next/navigation'
import React from 'react'

interface PaginationProps {
  totalPages: number
  currentPage: number
}

const Pagination: React.FC<PaginationProps> = ({ totalPages, currentPage }) => {
  const pathname = usePathname()
  const searchParams = useSearchParams()

  // Funci√≥n para generar URL con par√°metros de b√∫squeda
  const createPageURL = (page: number) => {
    const params = new URLSearchParams(searchParams.toString())
    params.set('page', page.toString())
    return `${pathname}?${params.toString()}`
  }

  // Generar array de p√°ginas para mostrar en la paginaci√≥n
  const getPageNumbers = () => {
    const pageNumbers: Array<number | string> = []

    // Siempre mostrar la primera p√°gina
    pageNumbers.push(1)

    // Mostrar puntos suspensivos si la p√°gina actual est√° lejos de la primera
    if (currentPage > 3) {
      pageNumbers.push('...')
    }

    // Mostrar p√°ginas alrededor de la p√°gina actual
    for (
      let i = Math.max(2, currentPage - 1);
      i <= Math.min(totalPages - 1, currentPage + 1);
      i++
    ) {
      if (i > 1 && i < totalPages) {
        pageNumbers.push(i)
      }
    }

    // Mostrar puntos suspensivos si la p√°gina actual est√° lejos de la √∫ltima
    if (currentPage < totalPages - 2) {
      pageNumbers.push('...')
    }

    // Siempre mostrar la √∫ltima p√°gina si hay m√°s de una
    if (totalPages > 1) {
      pageNumbers.push(totalPages)
    }

    return pageNumbers
  }

  // No mostrar paginaci√≥n si solo hay una p√°gina
  if (totalPages <= 1) {
    return null
  }

  return (
    <div className="mt-8 flex justify-center">
      <nav className="flex items-center space-x-2">
        {/* Bot√≥n anterior */}
        <Link
          href={createPageURL(Math.max(1, currentPage - 1))}
          className={`rounded border px-3 py-1 ${
            currentPage === 1
              ? 'cursor-not-allowed border-gray-200 text-gray-400'
              : 'border-gray-300 text-gray-700 hover:bg-gray-50'
          }`}
          aria-disabled={currentPage === 1}
          tabIndex={currentPage === 1 ? -1 : undefined}
        >
          <ChevronLeft className="h-4 w-4" />
        </Link>

        {/* N√∫meros de p√°gina */}
        {getPageNumbers().map((page, index) => {
          if (typeof page === 'string') {
            return (
              <span
                key={`ellipsis-${index}`}
                className="px-3 py-1 text-gray-500"
              >
                {page}
              </span>
            )
          }

          return (
            <Link
              key={page}
              href={createPageURL(page)}
              className={`rounded border px-3 py-1 ${
                currentPage === page
                  ? 'border-primary bg-primary text-white'
                  : 'border-gray-300 text-gray-700 hover:bg-gray-50'
              }`}
              aria-current={currentPage === page ? 'page' : undefined}
            >
              {page}
            </Link>
          )
        })}

        {/* Bot√≥n siguiente */}
        <Link
          href={createPageURL(Math.min(totalPages, currentPage + 1))}
          className={`rounded border px-3 py-1 ${
            currentPage === totalPages
              ? 'cursor-not-allowed border-gray-200 text-gray-400'
              : 'border-gray-300 text-gray-700 hover:bg-gray-50'
          }`}
          aria-disabled={currentPage === totalPages}
          tabIndex={currentPage === totalPages ? -1 : undefined}
        >
          <ChevronRight className="h-4 w-4" />
        </Link>
      </nav>
    </div>
  )
}

export default Pagination



üìÅ ARCHIVO: src/components/search/ActiveFilters.tsx
------------------------------------------------------------------------------------
'use client'
import { type AvailableFilters } from '@/backend/filters'
import { type ProductSearchFilters } from '@/backend/search'

import { usePathname, useRouter, useSearchParams } from 'next/navigation'
import React from 'react'

interface ActiveFiltersProps {
  availableFilters: AvailableFilters
  currentFilters: ProductSearchFilters
}

const ActiveFilters: React.FC<ActiveFiltersProps> = ({
  availableFilters,
  currentFilters
}) => {
  const pathname = usePathname()
  const searchParams = useSearchParams()
  const router = useRouter()

  const updateFilter = (key: string, value: string | null) => {
    const params = new URLSearchParams(searchParams.toString())

    if (value === null || value === '') {
      params.delete(key)
    } else {
      params.set(key, value)
    }

    params.set('page', '1') // Reset to first page when filtering
    router.push(`${pathname}?${params.toString()}`)
  }

  // Verificar si hay filtros activos
  const hasActiveFilters =
    currentFilters.categoryId ||
    currentFilters.brandId ||
    currentFilters.minPrice ||
    currentFilters.maxPrice ||
    (currentFilters.attributes &&
      Object.keys(currentFilters.attributes).length > 0)

  if (!hasActiveFilters) {
    return null
  }

  return (
    <div className="mb-6 rounded-lg bg-gray-50 p-3">
      <h4 className="mb-2 text-sm font-medium text-gray-700">
        Filtros aplicados:
      </h4>
      <div className="flex flex-wrap gap-2">
        {/* Categor√≠a seleccionada */}
        {currentFilters.categoryId &&
          availableFilters?.categories &&
          (() => {
            const selectedCategory = availableFilters.categories.find(
              (cat) => cat.id === currentFilters.categoryId
            )
            return selectedCategory ? (
              <span className="inline-flex items-center rounded-full bg-primary px-2 py-1 text-xs text-white">
                {selectedCategory.name}
                <button
                  onClick={() => { updateFilter('category', null) }}
                  className="ml-1 rounded-full p-0.5 hover:bg-primary/80"
                >
                  √ó
                </button>
              </span>
            ) : null
          })()}

        {/* Marca seleccionada */}
        {currentFilters.brandId &&
          availableFilters?.brands &&
          (() => {
            const selectedBrand = availableFilters.brands.find(
              (brand) => brand.id === currentFilters.brandId
            )
            return selectedBrand ? (
              <span className="inline-flex items-center rounded-full bg-primary px-2 py-1 text-xs text-white">
                {selectedBrand.name}
                <button
                  onClick={() => { updateFilter('brand', null) }}
                  className="ml-1 rounded-full p-0.5 hover:bg-primary/80"
                >
                  √ó
                </button>
              </span>
            ) : null
          })()}

        {/* Precio m√≠nimo */}
        {currentFilters.minPrice && (
          <span className="inline-flex items-center rounded-full bg-green-500 px-2 py-1 text-xs text-white">
            Min: S/ {currentFilters.minPrice}
            <button
              onClick={() => { updateFilter('minPrice', null) }}
              className="ml-1 rounded-full p-0.5 hover:bg-green-600"
            >
              √ó
            </button>
          </span>
        )}

        {/* Precio m√°ximo */}
        {currentFilters.maxPrice && (
          <span className="inline-flex items-center rounded-full bg-green-500 px-2 py-1 text-xs text-white">
            Max: S/ {currentFilters.maxPrice}
            <button
              onClick={() => { updateFilter('maxPrice', null) }}
              className="ml-1 rounded-full p-0.5 hover:bg-green-600"
            >
              √ó
            </button>
          </span>
        )}

        {/* Atributos seleccionados */}
        {currentFilters.attributes &&
          availableFilters?.attributes &&
          Object.entries(currentFilters.attributes).map(
            ([attributeId, optionIds]) => {
              const attribute = availableFilters.attributes.find(
                (attr) => attr.id === parseInt(attributeId)
              )
              if (!attribute) return null

              return optionIds.map((optionId) => {
                const option = attribute.options.find(
                  (opt) => opt.id === optionId
                )
                if (!option) return null

                return (
                  <span
                    key={`${attributeId}-${optionId}`}
                    className="inline-flex items-center rounded-full bg-blue-500 px-2 py-1 text-xs text-white"
                  >
                    {option.value}
                    <button
                      onClick={() => {
                        const currentValues =
                          currentFilters.attributes?.[parseInt(attributeId)] ||
                          []
                        const newValues = currentValues.filter(
                          (id) => id !== optionId
                        )

                        const params = new URLSearchParams(
                          searchParams.toString()
                        )
                        if (newValues.length > 0) {
                          params.set(`attr_${attributeId}`, newValues.join(','))
                        } else {
                          params.delete(`attr_${attributeId}`)
                        }
                        params.set('page', '1')
                        router.push(`${pathname}?${params.toString()}`)
                      }}
                      className="ml-1 rounded-full p-0.5 hover:bg-blue-600"
                    >
                      √ó
                    </button>
                  </span>
                )
              })
            }
          )}
      </div>
    </div>
  )
}

export default ActiveFilters



üìÅ ARCHIVO: src/components/search/SearchResults/SearchResults.tsx
------------------------------------------------------------------------------------
'use client'
import { type ProductSearchFilters, type ProductSearchItem } from '@/backend/search'
import Pagination from '@/components/search/Pagination'
import { SearchNotFound } from '@/components/search/SearchNotFound'
import SearchSorting from '@/components/search/SearchSorting'
import ProductCard from '@/components/ui/ProductCard'
import React from 'react'

interface SearchResultsProps {
  products: ProductSearchItem[]
  totalPages: number
  currentPage: number
  currentFilters: ProductSearchFilters
  defaultView?: 'grid' | 'list'
}

const SearchResults: React.FC<SearchResultsProps> = ({
  products,
  totalPages,
  currentPage,
  defaultView: viewMode = 'grid',
  currentFilters: filters
}) => {
  if (products.length === 0) {
    return <SearchNotFound />
  }

  return (
    <div>
      <div className="mb-6 flex flex-col items-start justify-between gap-4 sm:flex-row sm:items-center">
        <div className="flex w-full items-center justify-end">
          <SearchSorting currentSort={filters.sort} variant="toggle" />
        </div>
      </div>

      {/* Productos en modo grid o list */}
      <div
        className={
          viewMode === 'grid'
            ? 'grid grid-cols-1 gap-5 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 3xl:grid-cols-6'
            : 'flex flex-col space-y-4'
        }
      >
        {products.map((product) => (
          <ProductCard
            key={product.variantId || product.id}
            product={product}
          />
        ))}
      </div>

      {/* Paginaci√≥n */}
      <Pagination totalPages={totalPages} currentPage={currentPage} />
    </div>
  )
}

export default SearchResults



üìÅ ARCHIVO: src/components/search/SearchResults/index.ts
------------------------------------------------------------------------------------
export { default } from './SearchResults'



üìÅ ARCHIVO: src/components/search/ClearFiltersButton.tsx
------------------------------------------------------------------------------------
'use client'
import { type ProductSearchFilters } from '@/backend/search'
import { usePathname, useRouter } from 'next/navigation'
import React from 'react'

interface ClearFiltersButtonProps {
  currentFilters: ProductSearchFilters
}

const ClearFiltersButton: React.FC<ClearFiltersButtonProps> = ({
  currentFilters
}) => {
  const pathname = usePathname()
  const router = useRouter()

  const clearAllFilters = () => {
    const params = new URLSearchParams()
    // Mantener solo la query de b√∫squeda si existe
    if (currentFilters.query) {
      params.set('q', currentFilters.query)
    }
    router.push(`${pathname}?${params.toString()}`)
  }

  return (
    <button
      onClick={clearAllFilters}
      className="text-sm text-primary hover:text-primary/80"
    >
      Limpiar filtros
    </button>
  )
}

export default ClearFiltersButton



üìÅ ARCHIVO: src/components/search/SearchSuggestions/SearchSuggestions.tsx
------------------------------------------------------------------------------------
'use client'
import { searchSuggestionsService } from '@/services/search/searchSuggestions'
import { ArrowUpLeft, Search } from 'lucide-react'
import React, { useEffect, useRef, useState } from 'react'

interface SearchSuggestionsProps {
  onSearch: (query?: string) => void
  placeholder?: string
  className?: string
}

const SearchSuggestions: React.FC<SearchSuggestionsProps> = ({
  onSearch,
  placeholder = 'Buscar productos...',
  className = ''
}) => {
  const [query, setQuery] = useState('')
  const [suggestions, setSuggestions] = useState<string[]>([])
  const [showSuggestions, setShowSuggestions] = useState(false)
  const [isLoading, setIsLoading] = useState(false)
  const [selectedIndex, setSelectedIndex] = useState(-1)

  const inputRef = useRef<HTMLInputElement>(null)
  const suggestionsRef = useRef<HTMLDivElement>(null)
  const debounceRef = useRef<NodeJS.Timeout>()

  // Funci√≥n para resaltar el texto de b√∫squeda en las sugerencias
  const highlightMatch = (text: string, searchQuery: string) => {
    if (!searchQuery.trim()) return text

    const regex = new RegExp(
      `(${searchQuery.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`,
      'gi'
    )
    const parts = text.split(regex)

    return parts.map((part, index) => {
      if (regex.test(part)) {
        return (
          <strong key={index} className="font-bold text-gray-900">
            {part}
          </strong>
        )
      }
      return part
    })
  }

  // Funci√≥n para obtener sugerencias con debounce
  const fetchSuggestions = async (searchQuery: string) => {
    if (searchQuery.trim().length < 2) {
      setSuggestions([])
      setShowSuggestions(false)
      return
    }

    setIsLoading(true)
    try {
      const results = await searchSuggestionsService.getSuggestions(
        searchQuery,
        8
      )
      setSuggestions(results)
      setShowSuggestions(results.length > 0)
      setSelectedIndex(-1)
    } catch (error) {
      console.error('Error al obtener sugerencias:', error)
      setSuggestions([])
      setShowSuggestions(false)
    } finally {
      setIsLoading(false)
    }
  }

  // Manejar cambios en el input con debounce
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value
    setQuery(value)

    // Limpiar el debounce anterior
    if (debounceRef.current) {
      clearTimeout(debounceRef.current)
    }

    // Configurar nuevo debounce
    debounceRef.current = setTimeout(() => {
      fetchSuggestions(value)
    }, 300)
  }

  // Manejar env√≠o del formulario
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()

    if (query === '') {
      onSearch()
    }

    if (query.trim()) {
      onSearch(query.trim())
      setShowSuggestions(false)
      inputRef.current?.blur()
    }
  }

  // Manejar clic en una sugerencia
  const handleSuggestionClick = (suggestion: string) => {
    setQuery(suggestion)
    onSearch(suggestion)
    setShowSuggestions(false)
    inputRef.current?.blur()
  }

  // Manejar navegaci√≥n con teclado
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (!showSuggestions || suggestions.length === 0) return

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault()
        setSelectedIndex((prev) =>
          prev < suggestions.length - 1 ? prev + 1 : prev
        )
        break
      case 'ArrowUp':
        e.preventDefault()
        setSelectedIndex((prev) => (prev > 0 ? prev - 1 : -1))
        break
      case 'Enter':
        e.preventDefault()
        if (selectedIndex >= 0 && selectedIndex < suggestions.length) {
          handleSuggestionClick(suggestions[selectedIndex])
        } else if (query.trim()) {
          handleSubmit(e)
        }
        break
      case 'Escape':
        setShowSuggestions(false)
        setSelectedIndex(-1)
        inputRef.current?.blur()
        break
    }
  }

  // Limpiar b√∫squeda
  const clearSearch = () => {
    setQuery('')
    setSuggestions([])
    setShowSuggestions(false)
    setSelectedIndex(-1)
    inputRef.current?.focus()
  }

  // Cerrar sugerencias al hacer clic fuera
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        suggestionsRef.current &&
        !suggestionsRef.current.contains(event.target as Node) &&
        !inputRef.current?.contains(event.target as Node)
      ) {
        setShowSuggestions(false)
        setSelectedIndex(-1)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [])

  // Limpiar debounce al desmontar
  useEffect(() => {
    return () => {
      if (debounceRef.current) {
        clearTimeout(debounceRef.current)
      }
    }
  }, [])

  return (
    <div className={`relative w-full ${className}`}>
      <form onSubmit={handleSubmit} className="relative">
        <div className="relative">
          <Search className="absolute left-3 top-1/2 h-5 w-5 -translate-y-1/2 transform text-gray-400" />
          <input
            ref={inputRef}
            type="text"
            value={query}
            onChange={handleInputChange}
            onKeyDown={handleKeyDown}
            onFocus={() => {
              if (suggestions.length > 0) {
                setShowSuggestions(true)
              }
            }}
            placeholder={placeholder}
            className="w-full rounded-3xl border border-gray-300 py-3 pl-10 pr-10 focus:border-transparent focus:outline-none focus:ring-2 focus:ring-indigo-500"
          />
          <button
            type="submit"
            className="absolute right-1.5 top-1/2 flex h-10 w-10 -translate-y-1/2 items-center justify-center rounded-full bg-primary p-2 text-white transition-colors hover:bg-secondary"
          >
            <Search className="h-5 w-5" />
          </button>
        </div>
      </form>

      {/* Sugerencias */}
      {showSuggestions && (
        <div
          ref={suggestionsRef}
          className="absolute left-0 right-0 top-full z-50 mt-1 max-h-64 overflow-y-auto rounded-sm border border-gray-200 bg-white shadow-lg"
        >
          {isLoading ? (
            <div className="p-3 text-center text-gray-500">
              <div className="mr-2 inline-block h-4 w-4 animate-spin rounded-full border-2 border-current border-t-transparent"></div>
              Buscando...
            </div>
          ) : suggestions.length > 0 ? (
            <ul className="py-1">
              {suggestions.map((suggestion, index) => (
                <li key={index}>
                  <button
                    type="button"
                    onClick={() => { handleSuggestionClick(suggestion) }}
                    className={`w-full px-4 py-2 text-left transition-colors hover:bg-gray-100 focus:bg-gray-100 focus:outline-none ${
                      index === selectedIndex ? 'bg-gray-100' : ''
                    }`}
                  >
                    <div className="flex items-center justify-between">
                      <div className="flex items-center">
                        <Search className="mr-3 h-4 w-4 flex-shrink-0 text-gray-400" />
                        <span className="truncate text-gray-700">
                          {highlightMatch(suggestion, query)}
                        </span>
                      </div>
                      <ArrowUpLeft className="h-5 w-5 stroke-1 text-gray-500" />
                    </div>
                  </button>
                </li>
              ))}
            </ul>
          ) : null}
        </div>
      )}
    </div>
  )
}

export default SearchSuggestions



üìÅ ARCHIVO: src/components/search/SearchSuggestions/index.ts
------------------------------------------------------------------------------------
export { default } from './SearchSuggestions'



üìÅ ARCHIVO: src/components/search/ViewModeSelector.tsx
------------------------------------------------------------------------------------
'use client'
import { LayoutGrid, List } from 'lucide-react'
import React from 'react'

interface ViewModeSelectorProps {
  viewMode: 'grid' | 'list'
  onViewModeChange: (mode: 'grid' | 'list') => void
}

const ViewModeSelector: React.FC<ViewModeSelectorProps> = ({
  viewMode,
  onViewModeChange
}) => {
  return (
    <div className="flex items-center overflow-hidden rounded-lg border">
      <button
        onClick={() => { onViewModeChange('grid') }}
        className={`flex items-center px-3 py-2 ${
          viewMode === 'grid'
            ? 'bg-primary text-white'
            : 'bg-white text-gray-700 hover:bg-gray-50'
        }`}
        aria-label="Ver como cuadr√≠cula"
      >
        <LayoutGrid className="mr-1 h-4 w-4" />
        <span className="text-sm">Cuadr√≠cula</span>
      </button>
      <button
        onClick={() => { onViewModeChange('list') }}
        className={`flex items-center px-3 py-2 ${
          viewMode === 'list'
            ? 'bg-primary text-white'
            : 'bg-white text-gray-700 hover:bg-gray-50'
        }`}
        aria-label="Ver como lista"
      >
        <List className="mr-1 h-4 w-4" />
        <span className="text-sm">Lista</span>
      </button>
    </div>
  )
}

export default ViewModeSelector



üìÅ ARCHIVO: src/components/search/PriceRangeFilter/schema.ts
------------------------------------------------------------------------------------
import { z } from 'zod'

export const priceSchema = z
  .object({
    minPrice: z
      .number()
      .min(0, 'El precio m√≠nimo debe ser mayor a 0')
      .optional(),
    maxPrice: z
      .number()
      .min(0, 'El precio m√°ximo debe ser mayor a 0')
      .optional()
  })
  .refine(
    (data) => {
      if (data.minPrice && data.maxPrice) {
        return data.minPrice <= data.maxPrice
      }
      return true
    },
    {
      message: 'El precio m√≠nimo debe ser menor o igual al precio m√°ximo'
    }
  )

export type PriceFormData = z.infer<typeof priceSchema>



üìÅ ARCHIVO: src/components/search/PriceRangeFilter/usePriceRangeFilter.ts
------------------------------------------------------------------------------------
import { type AvailableFilters } from '@/backend/filters'
import { type ProductSearchFilters } from '@/backend/search'
import { usePathname, useRouter, useSearchParams } from 'next/navigation'
import { useState } from 'react'
import { z } from 'zod'
import { priceSchema } from './schema'

interface UsePriceRangeFilterProps {
  availableFilters: AvailableFilters
  currentFilters: ProductSearchFilters
}

export const usePriceRangeFilter = ({
  availableFilters,
  currentFilters
}: UsePriceRangeFilterProps) => {
  const [minPrice, setMinPrice] = useState(
    currentFilters.minPrice?.toString() || ''
  )
  const [maxPrice, setMaxPrice] = useState(
    currentFilters.maxPrice?.toString() || ''
  )
  const [error, setError] = useState('')

  const pathname = usePathname()
  const searchParams = useSearchParams()
  const router = useRouter()

  const applyPriceFilter = () => {
    try {
      const minVal = minPrice ? parseFloat(minPrice) : undefined
      const maxVal = maxPrice ? parseFloat(maxPrice) : undefined

      // Validar con Zod
      priceSchema.parse({ minPrice: minVal, maxPrice: maxVal })

      // Validar rango disponible
      if (availableFilters?.priceRange) {
        if (minVal && minVal < availableFilters.priceRange.min) {
          setError(
            `El precio m√≠nimo debe ser mayor a S/ ${availableFilters.priceRange.min}`
          )
          return
        }
        if (maxVal && maxVal > availableFilters.priceRange.max) {
          setError(
            `El precio m√°ximo debe ser menor a S/ ${availableFilters.priceRange.max}`
          )
          return
        }
      }

      setError('')

      const params = new URLSearchParams(searchParams.toString())

      if (minVal) {
        params.set('minPrice', minVal.toString())
      } else {
        params.delete('minPrice')
      }

      if (maxVal) {
        params.set('maxPrice', maxVal.toString())
      } else {
        params.delete('maxPrice')
      }

      params.set('page', '1')
      router.push(`${pathname}?${params.toString()}`)
    } catch (err) {
      if (err instanceof z.ZodError) {
        setError(err.errors[0].message)
      } else {
        setError('Por favor, introduce n√∫meros v√°lidos en el rango de precios')
      }
    }
  }

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      applyPriceFilter()
    }
  }

  return {
    minPrice,
    setMinPrice,
    maxPrice,
    setMaxPrice,
    error,
    applyPriceFilter,
    handleKeyPress
  }
}



üìÅ ARCHIVO: src/components/search/PriceRangeFilter/PriceRangeFilter.tsx
------------------------------------------------------------------------------------
'use client'
import { type AvailableFilters } from '@/backend/filters'
import { type ProductSearchFilters } from '@/backend/search'
import CollapsibleSection from '@/components/ui/CollapsibleSection'
import { type FC } from 'react'
import InputPrice from './InputPrice'
import { usePriceRangeFilter } from './usePriceRangeFilter'

interface PriceRangeFilterProps {
  availableFilters: AvailableFilters
  currentFilters: ProductSearchFilters
}

const PriceRangeFilter: FC<PriceRangeFilterProps> = ({
  availableFilters,
  currentFilters
}) => {
  const {
    minPrice,
    setMinPrice,
    maxPrice,
    setMaxPrice,
    error,
    applyPriceFilter,
    handleKeyPress
  } = usePriceRangeFilter({ availableFilters, currentFilters })

  if (!availableFilters?.priceRange) {
    return null
  }

  return (
    <CollapsibleSection title="Precio" className="mb-0">
      <div className="space-y-3">
        <div className="flex items-center gap-1">
          <div className="flex items-center gap-0.5">
            <div className="flex-1">
              <InputPrice
                value={minPrice}
                onChange={setMinPrice}
                onKeyPress={handleKeyPress}
                placeholder="Min"
                hasError={!!error}
              />
            </div>
            <span className="flex-shrink-0 text-gray-500">-</span>
            <div className="flex-1">
              <InputPrice
                value={maxPrice}
                onChange={setMaxPrice}
                onKeyPress={handleKeyPress}
                placeholder="Max"
                hasError={!!error}
              />
            </div>
          </div>
          <button
            onClick={applyPriceFilter}
            className="flex-shrink-0 rounded bg-black px-4 py-2 text-sm font-medium text-white transition-colors hover:bg-gray-800"
          >
            OK
          </button>
        </div>
        {error && <p className="text-sm text-red-500">{error}</p>}
      </div>
    </CollapsibleSection>
  )
}

export default PriceRangeFilter



üìÅ ARCHIVO: src/components/search/PriceRangeFilter/index.ts
------------------------------------------------------------------------------------
export { default as InputPrice } from './InputPrice'
export { default } from './PriceRangeFilter'
export * from './schema'
export * from './usePriceRangeFilter'



üìÅ ARCHIVO: src/components/search/PriceRangeFilter/InputPrice.tsx
------------------------------------------------------------------------------------
import React from 'react'

interface InputPriceProps {
  value: string
  onChange: (value: string) => void
  onKeyPress: (e: React.KeyboardEvent) => void
  placeholder: string
  hasError: boolean
}

const InputPrice: React.FC<InputPriceProps> = ({
  value,
  onChange,
  onKeyPress,
  placeholder,
  hasError
}) => {
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    // Permitir teclas de control (backspace, delete, tab, escape, enter, etc.)
    if (
      e.key === 'Backspace' ||
      e.key === 'Delete' ||
      e.key === 'Tab' ||
      e.key === 'Escape' ||
      e.key === 'Enter' ||
      e.key === 'ArrowLeft' ||
      e.key === 'ArrowRight' ||
      e.key === 'ArrowUp' ||
      e.key === 'ArrowDown' ||
      e.key === 'Home' ||
      e.key === 'End' ||
      (e.key === 'a' && e.ctrlKey) || // Ctrl+A
      (e.key === 'c' && e.ctrlKey) || // Ctrl+C
      (e.key === 'v' && e.ctrlKey) || // Ctrl+V
      (e.key === 'x' && e.ctrlKey) // Ctrl+X
    ) {
      return
    }

    // Permitir solo n√∫meros y punto decimal
    if (!/[0-9.]/.test(e.key)) {
      e.preventDefault()
      return
    }

    // Prevenir m√∫ltiples puntos decimales
    if (e.key === '.' && value.includes('.')) {
      e.preventDefault()
      return
    }

    // Llamar al handler original si existe
    onKeyPress(e)
  }

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value

    // Permitir string vac√≠o
    if (newValue === '') {
      onChange('')
      return
    }

    // Validar que sea un n√∫mero v√°lido
    if (/^\d*\.?\d*$/.test(newValue)) {
      onChange(newValue)
    }
  }

  return (
    <input
      type="text"
      inputMode="numeric"
      pattern="[0-9]*"
      value={value}
      onChange={handleChange}
      onKeyDown={handleKeyDown}
      className={`w-full rounded-sm border px-3 py-2 text-sm ${
        hasError ? 'border-red-500' : 'border-gray-300'
      }`}
      placeholder={placeholder}
    />
  )
}

export default InputPrice



üìÅ ARCHIVO: src/components/search/AttributeFilter.tsx
------------------------------------------------------------------------------------
'use client'
import { type AvailableFilters } from '@/backend/filters'
import { type ProductSearchFilters } from '@/backend/search'

import CollapsibleSection from '@/components/ui/CollapsibleSection'
import { usePathname, useRouter, useSearchParams } from 'next/navigation'
import React from 'react'

interface AttributeFilterProps {
  availableFilters: AvailableFilters
  currentFilters: ProductSearchFilters
}

const AttributeFilter: React.FC<AttributeFilterProps> = ({
  availableFilters,
  currentFilters
}) => {
  const pathname = usePathname()
  const searchParams = useSearchParams()
  const router = useRouter()

  if (
    !availableFilters?.attributes ||
    availableFilters.attributes.length === 0
  ) {
    return null
  }

  return (
    <div>
      {availableFilters.attributes.map((attribute) => (
        <CollapsibleSection
          key={attribute.id}
          title={attribute.name}
          className="mb-0"
        >
          <div className="space-y-1">
            {attribute.options.map((option) => (
              <label key={option.id} className="flex items-center">
                <input
                  type="checkbox"
                  value={option.id}
                  checked={
                    currentFilters.attributes?.[attribute.id]?.includes(
                      option.id
                    ) || false
                  }
                  onChange={(e) => {
                    const currentValues =
                      currentFilters.attributes?.[attribute.id] || []
                    const newValues = e.target.checked
                      ? [...currentValues, option.id]
                      : currentValues.filter((id) => id !== option.id)

                    const params = new URLSearchParams(searchParams.toString())
                    if (newValues.length > 0) {
                      params.set(`attr_${attribute.id}`, newValues.join(','))
                    } else {
                      params.delete(`attr_${attribute.id}`)
                    }
                    params.set('page', '1')
                    router.push(`${pathname}?${params.toString()}`)
                  }}
                  className="mr-2"
                />
                <span className="text-sm">{option.value}</span>
              </label>
            ))}
          </div>
        </CollapsibleSection>
      ))}
    </div>
  )
}

export default AttributeFilter



üìÅ ARCHIVO: src/components/search/CategoryFilter.tsx
------------------------------------------------------------------------------------
'use client'
import CollapsibleSection from '@/components/ui/CollapsibleSection'
import { usePathname, useRouter, useSearchParams } from 'next/navigation'
import React from 'react'

import { type AvailableFilters } from '@/backend/filters'
import { type ProductSearchFilters } from '@/backend/search'

interface CategoryFilterProps {
  availableFilters: AvailableFilters
  currentFilters: ProductSearchFilters
}

const CategoryFilter: React.FC<CategoryFilterProps> = ({
  availableFilters,
  currentFilters
}) => {
  const pathname = usePathname()
  const searchParams = useSearchParams()
  const router = useRouter()

  const updateFilter = (key: string, value: string | null) => {
    const params = new URLSearchParams(searchParams.toString())

    if (value === null || value === '') {
      params.delete(key)
    } else {
      params.set(key, value)
    }

    params.set('page', '1') // Reset to first page when filtering
    router.push(`${pathname}?${params.toString()}`)
  }

  if (
    !availableFilters?.categories ||
    availableFilters.categories.length === 0
  ) {
    return null
  }

  return (
    <CollapsibleSection title="Categor√≠as" className="mb-0">
      <div className="space-y-2">
        {availableFilters.categories.map((category) => (
          <label key={category.id} className="flex items-center">
            <input
              type="radio"
              name="category"
              value={category.id}
              checked={currentFilters.categoryId === category.id}
              onChange={(e) => {
 updateFilter(
                  'category',
                  e.target.checked ? e.target.value : null
                )
}
              }
              className="mr-2"
            />
            <span className="text-sm">
              {category.name} ({category.count})
            </span>
          </label>
        ))}
      </div>
    </CollapsibleSection>
  )
}

export default CategoryFilter



üìÅ ARCHIVO: src/components/search/SearchFilters/SearchFilters.tsx
------------------------------------------------------------------------------------
'use client'
import { type AvailableFilters } from '@/backend/filters'
import { type ProductSearchFilters } from '@/backend/search'
import ActiveFilters from '@/components/search/ActiveFilters'
import AttributeFilter from '@/components/search/AttributeFilter'
import PriceRangeFilter from '@/components/search/PriceRangeFilter'
import React from 'react'

interface SearchFiltersProps {
  availableFilters: AvailableFilters
  currentFilters: ProductSearchFilters
}

const SearchFilters: React.FC<SearchFiltersProps> = ({
  availableFilters,
  currentFilters
}) => {
  return (
    <div className="rounded-lg bg-white py-6">
      {/* <div className="flex justify-between items-center mb-4">
        <h3 className="text-lg font-semibold">Filtros</h3>
        <ClearFiltersButton currentFilters={currentFilters} />
      </div> */}

      {/* Filtros activos */}
      <ActiveFilters
        availableFilters={availableFilters}
        currentFilters={currentFilters}
      />

      {/* Categor√≠as */}
      {/* <CategoryFilter
        availableFilters={availableFilters}
        currentFilters={currentFilters}
      /> */}

      {/* Marcas */}
      {/* <BrandFilter
        availableFilters={availableFilters}
        currentFilters={currentFilters}
      /> */}

      {/* Atributos */}
      <AttributeFilter
        availableFilters={availableFilters}
        currentFilters={currentFilters}
      />

      {/* Rango de precios */}
      <PriceRangeFilter
        availableFilters={availableFilters}
        currentFilters={currentFilters}
      />
    </div>
  )
}

export default SearchFilters



üìÅ ARCHIVO: src/components/search/SearchFilters/index.ts
------------------------------------------------------------------------------------
export { default } from './SearchFilters'



üìÅ ARCHIVO: src/components/search/SearchSorting.tsx
------------------------------------------------------------------------------------
'use client'
import { type ProductSearchFilters } from '@/backend/search'
import { usePathname, useRouter, useSearchParams } from 'next/navigation'
import React from 'react'

interface SearchSortingProps {
  currentSort?: ProductSearchFilters['sort']
}
interface ExtendedSearchSortingProps extends SearchSortingProps {
  variant?: 'select' | 'toggle'
}

const SearchSorting: React.FC<ExtendedSearchSortingProps> = ({
  currentSort,
  variant = 'select'
}) => {
  const pathname = usePathname()
  const searchParams = useSearchParams()
  const router = useRouter()

  const sortOptions = [
    {
      key: 'newest',
      label: 'M√°s recientes',
      asc: 'newest',
      desc: 'newest' // Solo hay una direcci√≥n para "m√°s recientes"
    },
    {
      key: 'price',
      label: 'Precio',
      asc: 'price_asc',
      desc: 'price_desc'
    },
    {
      key: 'name',
      label: 'Nombre',
      asc: 'name_asc',
      desc: 'name_desc'
    }
  ]

  // Funci√≥n para determinar qu√© opci√≥n est√° activa y su direcci√≥n
  const getActiveSort = () => {
    const current = currentSort || 'newest'
    for (const option of sortOptions) {
      if (current === option.asc || current === option.desc) {
        return {
          key: option.key,
          direction: current === option.desc ? 'desc' : 'asc'
        }
      }
    }
    return { key: 'newest', direction: 'asc' }
  }

  const activeSort = getActiveSort()

  const handleSortChange = (sortValue: string) => {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortValue)
    params.set('page', '1') // Reset to first page when sorting
    router.push(`${pathname}?${params.toString()}`)
  }

  const handleToggleDirection = (option: (typeof sortOptions)[0]) => {
    if (option.key === 'newest') {
      // Para "m√°s recientes" solo hay una opci√≥n
      handleSortChange(option.asc)
      return
    }

    // Para precio y nombre, alternar entre asc y desc
    const currentValue = currentSort || 'newest'
    const isCurrentlyAsc = currentValue === option.asc
    const newValue = isCurrentlyAsc ? option.desc : option.asc
    handleSortChange(newValue)
  }

  if (variant === 'toggle') {
    return (
      <div className="flex items-center gap-2">
        <span className="text-sm font-medium text-gray-700">Ordenar por:</span>
        <div className="flex flex-wrap gap-2">
          {sortOptions.map((option) => {
            const isActive = activeSort.key === option.key
            const isDesc = activeSort.direction === 'desc'

            return (
              <button
                key={option.key}
                onClick={() => { handleToggleDirection(option) }}
                className={`flex items-center gap-2 border px-3 py-2 text-sm transition-colors ${
                  isActive
                    ? 'border-primary bg-primary text-white'
                    : 'border-gray-300 bg-white text-gray-700 hover:bg-gray-50'
                }`}
              >
                <span>{option.label}</span>
                {option.key !== 'newest' && (
                  <span className="text-xs">
                    {isActive && isDesc ? '‚Üì' : '‚Üë'}
                  </span>
                )}
              </button>
            )
          })}
        </div>
      </div>
    )
  }

  return (
    <div className="flex items-center gap-2">
      <label
        htmlFor="sort-select"
        className="text-sm font-medium text-gray-700"
      >
        Ordenar por:
      </label>
      <select
        id="sort-select"
        value={currentSort || 'newest'}
        onChange={(e) => { handleSortChange(e.target.value) }}
        className="rounded-md border border-gray-300 px-3 py-1 text-sm focus:border-transparent focus:outline-none focus:ring-2 focus:ring-primary"
      >
        <option value="newest">M√°s recientes</option>
        <option value="price_asc">Precio: menor a mayor</option>
        <option value="price_desc">Precio: mayor a menor</option>
        <option value="name_asc">Nombre: A-Z</option>
        <option value="name_desc">Nombre: Z-A</option>
      </select>
    </div>
  )
}

export default SearchSorting



üìÅ ARCHIVO: src/components/search/StickyFilters.tsx
------------------------------------------------------------------------------------
'use client'
import { useStickyFilters } from '@/hooks/useStickyFilters'
import { type FC, type ReactNode } from 'react'

interface StickyFiltersProps {
  children: ReactNode
}

const StickyFilters: FC<StickyFiltersProps> = ({ children }) => {
  const { topPosition, maxHeight, minHeight, bottomConstraint } =
    useStickyFilters()

  return (
    <div
      className="sticky left-12 z-10 w-56 overflow-y-auto"
      style={{
        top: topPosition,
        maxHeight,
        minHeight,
        bottom: bottomConstraint
      }}
    >
      {children}
    </div>
  )
}

export default StickyFilters



üìÅ ARCHIVO: src/components/search/SearchNotFound.tsx
------------------------------------------------------------------------------------
import Link from 'next/link'

export const SearchNotFound = () => {
  return (
    <div className="bg-white p-8 text-center">
      <div className="mb-4 text-gray-400">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          className="mx-auto h-12 w-12"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
          />
        </svg>
      </div>
      <h3 className="mb-2 text-lg font-medium text-gray-900">
        No se encontraron productos
      </h3>
      <p className="mb-4 text-gray-500">
        Intenta con otros t√©rminos de b√∫squeda o filtros diferentes.
      </p>
      <Link
        href="/search"
        className="inline-flex items-center rounded-md border border-transparent bg-primary px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2"
      >
        Ver todos los productos
      </Link>
    </div>
  )
}



üìÅ ARCHIVO: src/components/LoginCustomerForm/LoginCustomerForm.schema.ts
------------------------------------------------------------------------------------
import z from 'zod'

export const LoginCustomerFormSchema = z.object({
  email: z
    .string()
    .min(1, { message: 'El email es requerido' })
    .email({ message: 'Email inv√°lido' }),
  password: z
    .string()
    .min(1, { message: 'La contrase√±a es requerida' })
    .min(8, { message: 'La contrase√±a debe tener al menos 8 caracteres' })
})



üìÅ ARCHIVO: src/components/LoginCustomerForm/use-login-customer-form.hook.ts
------------------------------------------------------------------------------------
// hooks/useLoginCustomerForm.ts
'use client'

import { signIn } from 'next-auth/react'
import { useState } from 'react'
import z from 'zod'
import { LoginCustomerFormSchema } from './LoginCustomerForm.schema'
import { type LoginFormData } from './LoginCustomerForm.types'

interface UseLoginCustomerFormProps {
  onSuccess?: () => void
  onClose?: () => void
}

interface UseLoginCustomerFormReturn {
  email: string
  password: string
  errors: {
    email?: string
    password?: string
    form?: string
  }
  isLoading: boolean
  setEmail: (email: string) => void
  setPassword: (password: string) => void
  handleSubmit: (e: React.FormEvent) => Promise<void>
  validateField: (field: keyof LoginFormData, value: string) => void
}

export const useLoginCustomerForm = ({
  onSuccess,
  onClose
}: UseLoginCustomerFormProps): UseLoginCustomerFormReturn => {
  const [formData, setFormData] = useState<LoginFormData>({
    email: '',
    password: ''
  })
  const [errors, setErrors] = useState<UseLoginCustomerFormReturn['errors']>({})
  const [isLoading, setIsLoading] = useState(false)

  const validateField = (field: keyof LoginFormData, value: string): void => {
    try {
      const tempSchema = z.object({
        [field]: LoginCustomerFormSchema.shape[field]
      })
      tempSchema.parse({ [field]: value })

      setErrors((prev) => ({ ...prev, [field]: undefined }))
    } catch (error) {
      if (error instanceof z.ZodError) {
        setErrors((prev) => ({
          ...prev,
          [field]: error.errors.find((e) => e.path.includes(field))?.message
        }))
      }
    }
  }

  const handleSubmit = async (e: React.FormEvent): Promise<void> => {
    e.preventDefault()

    try {
      // Validar todo el formulario
      LoginCustomerFormSchema.parse(formData)
      setErrors({})

      setIsLoading(true)

      const result = await signIn('credentials', {
        redirect: false,
        email: formData.email,
        password: formData.password
      })

      if (result?.error != null) {
        setErrors({
          form:
            result.error === 'CredentialsSignin'
              ? 'Credenciales incorrectas'
              : 'Error al iniciar sesi√≥n'
        })
      } else if (result?.ok ?? false) {
        onSuccess?.()
        onClose?.()
      }
    } catch (error) {
      if (error instanceof z.ZodError) {
        const newErrors: Record<string, string> = {}
        error.errors.forEach((err) => {
          const field = err.path[0] as string
          newErrors[field] = err.message
        })
        setErrors(newErrors)
      } else {
        setErrors({ form: 'Ocurri√≥ un error al iniciar sesi√≥n' })
      }
    } finally {
      setIsLoading(false)
    }
  }

  const setEmail = (email: string): void => {
    setFormData((prev) => ({ ...prev, email }))
    validateField('email', email)
  }

  const setPassword = (password: string): void => {
    setFormData((prev) => ({ ...prev, password }))
    validateField('password', password)
  }

  return {
    email: formData.email,
    password: formData.password,
    errors,
    isLoading,
    setEmail,
    setPassword,
    handleSubmit,
    validateField
  }
}



üìÅ ARCHIVO: src/components/LoginCustomerForm/LoginCustomerFormSocial.tsx
------------------------------------------------------------------------------------
// components/SocialLogin.tsx
'use client'

import { Button } from '@/components/ui/Button'
import { type JSX } from 'react'

interface LoginCustomerFormSocialProps {
  onGoogleLogin?: () => void
  onFacebookLogin?: () => void
  isLoading?: boolean
}

export const LoginCustomerFormSocial = ({
  onGoogleLogin,
  onFacebookLogin,
  isLoading = false
}: LoginCustomerFormSocialProps): JSX.Element => {
  return (
    <div className="mt-6">
      <div className="relative">
        <div className="absolute inset-0 flex items-center">
          <div className="w-full border-t border-gray-300"></div>
        </div>
        <div className="relative flex justify-center text-sm">
          <span className="bg-white px-2 text-gray-500">O contin√∫a con</span>
        </div>
      </div>

      <div className="mt-6 grid grid-cols-2 gap-3">
        <Button
          variant="outline"
          onClick={onGoogleLogin}
          disabled={isLoading}
          className="inline-flex w-full justify-center"
        >
          <span>Google</span>
        </Button>
        <Button
          variant="outline"
          onClick={onFacebookLogin}
          disabled={isLoading}
          className="inline-flex w-full justify-center"
        >
          <span>Facebook</span>
        </Button>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/LoginCustomerForm/LoginCustomerForm.types.ts
------------------------------------------------------------------------------------
import type z from 'zod'
import { type LoginCustomerFormSchema } from './LoginCustomerForm.schema'

export type LoginFormData = z.infer<typeof LoginCustomerFormSchema>



üìÅ ARCHIVO: src/components/LoginCustomerForm/index.ts
------------------------------------------------------------------------------------
export { default } from './LoginCustomerForm'



üìÅ ARCHIVO: src/components/LoginCustomerForm/LoginCustomerForm.tsx
------------------------------------------------------------------------------------
// components/LoginCustomerForm.tsx
'use client'

import { Button } from '@/components/ui/Button'
import { InputField } from '@/components/ui/InputField'
import { PasswordField } from '@/components/ui/PasswordField'
import { Loader2 } from 'lucide-react'
import { LoginCustomerFormSocial } from './LoginCustomerFormSocial'
import { useLoginCustomerForm } from './use-login-customer-form.hook'

interface LoginCustomerFormProps {
  onSuccess?: () => void
  onClose?: () => void
  onSwitchToRegister?: () => void
  onGoogleLogin?: () => void
  onFacebookLogin?: () => void
}

const LoginCustomerForm: React.FC<LoginCustomerFormProps> = ({
  onSuccess,
  onClose,
  onSwitchToRegister,
  onGoogleLogin,
  onFacebookLogin
}) => {
  const {
    email,
    password,
    errors,
    isLoading,
    setEmail,
    setPassword,
    handleSubmit,
    validateField
  } = useLoginCustomerForm({ onSuccess, onClose })

  const handleEmailChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    const value = e.target.value
    setEmail(value)
    validateField('email', value)
  }

  const handlePasswordChange = (value: string): void => {
    setPassword(value)
    validateField('password', value)
  }

  return (
    <div className="w-full">
      {/* Mostrar error general del formulario */}
      {errors.form != null && (
        <div className="mb-4 rounded-lg border border-red-200 bg-red-50 p-4 text-red-600">
          {errors.form}
        </div>
      )}

      <form onSubmit={handleSubmit} className="space-y-4">
        <InputField
          id="email"
          label="Email"
          type="email"
          value={email}
          onChange={handleEmailChange}
          placeholder="usuario@ejemplo.com"
          error={errors.email}
          disabled={isLoading}
          required
          autoComplete="email"
        />

        <PasswordField
          id="password"
          label="Contrase√±a"
          value={password}
          onChange={handlePasswordChange}
          showPassword={false}
          onToggleVisibility={() => {}}
          error={errors.password}
          disabled={isLoading}
          required
          autoComplete="current-password"
        />

        <div className="flex items-center justify-between">
          <div className="flex items-center">
            <input
              id="remember"
              type="checkbox"
              className="h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
              disabled={isLoading}
            />
            <label
              htmlFor="remember"
              className="ml-2 block text-sm text-gray-700"
            >
              Recordarme
            </label>
          </div>

          <div className="text-sm">
            <a href="#" className="text-primary hover:text-primary/80">
              ¬øOlvidaste tu contrase√±a?
            </a>
          </div>
        </div>

        <Button type="submit" disabled={isLoading} className="w-full">
          {isLoading ? (
            <span className="flex items-center justify-center">
              <Loader2 className="mr-2 h-5 w-5 animate-spin" />
              Iniciando sesi√≥n...
            </span>
          ) : (
            'Iniciar sesi√≥n'
          )}
        </Button>
      </form>

      <div className="mt-6 text-center text-sm text-gray-600">
        ¬øNo tienes una cuenta?{' '}
        <button
          onClick={onSwitchToRegister}
          className="font-medium text-primary hover:text-primary/80"
          disabled={isLoading}
        >
          Reg√≠strate
        </button>
      </div>

      <LoginCustomerFormSocial
        onGoogleLogin={onGoogleLogin}
        onFacebookLogin={onFacebookLogin}
        isLoading={isLoading}
      />
    </div>
  )
}

export default LoginCustomerForm



üìÅ ARCHIVO: src/components/cart/Skeleton/CartSummarySkeleton.tsx
------------------------------------------------------------------------------------
export const CartSummarySkeleton = () => {
  return (
    <div className="border border-gray-200 bg-white p-4">
      {/* T√≠tulo */}
      <div className="mb-4 h-6 w-20 animate-pulse rounded bg-gray-200"></div>

      {/* Im√°genes peque√±as */}
      <div className="mb-4 flex gap-2">
        {[1, 2, 3].map((i) => (
          <div
            key={i}
            className="h-12 w-12 animate-pulse rounded bg-gray-200"
          ></div>
        ))}
      </div>

      {/* L√≠neas de precio */}
      <div className="mb-4 space-y-3">
        {[1, 2, 3, 4].map((i) => (
          <div key={i} className="flex justify-between">
            <div className="h-4 w-24 animate-pulse rounded bg-gray-200"></div>
            <div className="h-4 w-16 animate-pulse rounded bg-gray-200"></div>
          </div>
        ))}
      </div>

      {/* Total */}
      <div className="mb-4 border-t pt-4">
        <div className="flex justify-between">
          <div className="h-6 w-32 animate-pulse rounded bg-gray-200"></div>
          <div className="h-6 w-20 animate-pulse rounded bg-gray-200"></div>
        </div>
      </div>

      {/* Bot√≥n */}
      <div className="mb-3 h-12 w-full animate-pulse bg-gray-200"></div>

      {/* M√©todos de pago */}
      <div className="mb-4">
        <div className="mb-2 h-4 w-16 animate-pulse rounded bg-gray-200"></div>
        <div className="flex gap-2">
          {[1, 2, 3, 4].map((i) => (
            <div
              key={i}
              className="h-5 w-8 animate-pulse rounded bg-gray-200"
            ></div>
          ))}
        </div>
      </div>

      {/* Protecci√≥n */}
      <div className="border-t pt-4">
        <div className="mb-2 h-4 w-32 animate-pulse rounded bg-gray-200"></div>
        <div className="space-y-2">
          <div className="h-3 w-full animate-pulse rounded bg-gray-200"></div>
          <div className="h-3 w-3/4 animate-pulse rounded bg-gray-200"></div>
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/cart/Skeleton/CartPageSkeleton.tsx
------------------------------------------------------------------------------------
import { CartItemSkeleton } from '@/components/cart/Skeleton/CartItemSkeleton'
import { CartSummarySkeleton } from '@/components/cart/Skeleton/CartSummarySkeleton'

export const CartPageSkeleton = () => {
  return (
    <div className="mx-auto max-w-7xl px-4 py-6 pt-4">
      {/* Header Skeleton */}
      <div className="mb-6">
        <div className="h-8 w-40 animate-pulse rounded bg-gray-200"></div>
      </div>

      <div className="grid grid-cols-1 gap-6 xl:grid-cols-12">
        {/* Lista de productos skeleton */}
        <div className="xl:col-span-8">
          {/* Header de selecci√≥n skeleton */}
          <div className="mb-4 border border-gray-200 bg-white p-4">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="h-4 w-4 animate-pulse rounded bg-gray-200"></div>
                <div className="h-4 w-48 animate-pulse rounded bg-gray-200"></div>
              </div>
              <div className="h-4 w-32 animate-pulse rounded bg-gray-200"></div>
            </div>
          </div>

          {/* Items skeleton */}
          <div className="space-y-3.5">
            {[1, 2, 3].map((i) => (
              <CartItemSkeleton key={i} />
            ))}
          </div>
        </div>

        {/* Summary skeleton */}
        <div className="xl:col-span-4">
          <CartSummarySkeleton />
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/cart/Skeleton/CartItemSkeleton.tsx
------------------------------------------------------------------------------------
export const CartItemSkeleton = () => {
  return (
    <div className="border border-gray-200 bg-white p-4">
      <div className="flex gap-4">
        <div className="flex-shrink-0 pt-2">
          <div className="h-4 w-4 animate-pulse rounded bg-gray-200"></div>
        </div>
        <div className="flex-shrink-0">
          <div className="h-20 w-20 animate-pulse bg-gray-200"></div>
        </div>
        <div className="min-w-0 flex-1">
          <div className="flex items-start justify-between">
            <div className="flex-1 pr-4">
              <div className="mb-2 h-5 w-3/4 animate-pulse rounded bg-gray-200"></div>
              <div className="mb-2 h-4 w-32 animate-pulse rounded bg-gray-200"></div>
              <div className="mb-3 h-3 w-24 animate-pulse rounded bg-gray-200"></div>
            </div>
            <div className="flex flex-col items-end gap-3">
              <div className="h-6 w-20 animate-pulse rounded bg-gray-200"></div>
              <div className="h-8 w-24 animate-pulse rounded bg-gray-200"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/cart/Skeleton/index.ts
------------------------------------------------------------------------------------
export * from './CartPageSkeleton'



üìÅ ARCHIVO: src/components/cart/CartPageInteractive.tsx
------------------------------------------------------------------------------------
'use client'

import CartPageContent from '@/components/cart/CartPageContent'

export const CartPageInteractive = () => {
  return <CartPageContent />
}



üìÅ ARCHIVO: src/components/cart/CartPageSummary.tsx
------------------------------------------------------------------------------------
import StockValidationModal from '@/components/checkout/StockValidationModal'
import { useCheckoutNavigation } from '@/components/checkout/useStockValidation'
import { formatPrice } from '@/helpers/utils'
import { type CartItem } from '@/hooks/useCart'
import { ShieldCheck } from 'lucide-react'
import Image from 'next/image'
import { type FC, useState } from 'react'

// Helper para obtener precio con promoci√≥n
const getPriceIfHasPromotion = (item: CartItem) => {
  const currentPromotion = item.promotionVariants?.[0]
  const originalPrice = Number(item.price)
  const promotionPrice = currentPromotion
    ? Number(currentPromotion.promotionPrice)
    : null
  const finalPrice = promotionPrice || originalPrice

  return {
    finalPrice,
    hasPromotion: Boolean(currentPromotion),
    originalPrice,
    currentPromotion
  }
}

interface CartPageSummaryProps {
  summaryCart: {
    selectedItems: CartItem[]
    selectedTotalItems: number
    selectedTotalPrice: number
    hasSelectedItems: () => boolean
  }
  onCartUpdate?: (
    adjustedItems: Array<{ id: number, quantity: number }>
  ) => void // Callback para actualizar carrito
  onStockInfoReceived?: (
    stockInfo: Array<{ id: number, availableStock: number }>
  ) => void // üÜï Callback para recibir stock info
}

export const CartPageSummary: FC<CartPageSummaryProps> = ({
  summaryCart,
  onCartUpdate,
  onStockInfoReceived // üÜï Nuevo callback
}) => {
  // Calcular totales considerando promociones
  const calculateTotalsWithPromotions = (items: CartItem[]) => {
    return items.reduce(
      (acc, item) => {
        const { finalPrice, originalPrice } = getPriceIfHasPromotion(item)
        const itemOriginalTotal = originalPrice * item.quantity
        const itemFinalTotal = finalPrice * item.quantity

        acc.originalTotal += itemOriginalTotal
        acc.finalTotal += itemFinalTotal
        acc.totalItems += item.quantity

        return acc
      },
      { originalTotal: 0, finalTotal: 0, totalItems: 0 }
    )
  }

  const totals = calculateTotalsWithPromotions(summaryCart.selectedItems)
  const totalDiscount = totals.originalTotal - totals.finalTotal
  const hasDiscounts = totalDiscount > 0

  const [isNavigating, setIsNavigating] = useState(false)

  // üÜï Hook para validaci√≥n de stock
  const { proceedFromCart, isValidating, modal } = useCheckoutNavigation()

  // üÜï Funci√≥n actualizada con validaci√≥n de stock
  const handleContinueToCheckout = async () => {
    if (!summaryCart.hasSelectedItems()) return

    setIsNavigating(true)

    try {
      // üÜï Preparar items para validaci√≥n
      const cartItems = summaryCart.selectedItems.map((item) => ({
        id: item.id,
        name: item.name,
        quantity: item.quantity
      }))

      // üÜï Callback para recibir informaci√≥n de stock (SOLO INFORMATIVO)
      const handleStockInfoReceived = (
        stockInfo: Array<{ id: number, availableStock: number }>
      ) => {
        console.log('üì¶ Stock info received in CartPageSummary:', stockInfo)

        // üÜï Enviar informaci√≥n de stock al padre para mostrar en CartPageItem
        if (onStockInfoReceived) {
          onStockInfoReceived(stockInfo)
        }
      }

      // üÜï Validar stock y proceder al checkout
      const success = await proceedFromCart(cartItems, handleStockInfoReceived)

      // Si el usuario cancel√≥ la validaci√≥n, restaurar el estado
      if (!success) {
        setIsNavigating(false)
      }
      // Si fue exitoso, el usuario ya est√° en /checkout (manejado por el hook)
    } catch (error) {
      console.error('Error navigating to checkout:', error)
      setIsNavigating(false)
    }
  }

  // üÜï Estado combinado de loading
  const isLoading = isNavigating || isValidating

  if (!summaryCart.hasSelectedItems()) {
    return (
      <>
        <div className="sticky top-4 border border-gray-200 bg-white p-4">
          <h2 className="mb-6 text-lg font-semibold text-gray-900">Resumen</h2>

          {/* Total cuando no hay items seleccionados */}
          <div className="mb-6 border-t pt-4">
            <div className="flex justify-between text-lg font-bold">
              <span>Estimaci√≥n total</span>
              <span>{formatPrice(0)}</span>
            </div>
          </div>

          {/* Bot√≥n deshabilitado */}
          <button
            className="mb-6 w-full cursor-not-allowed bg-gray-400 py-3 font-medium text-white"
            disabled
          >
            <div className="flex items-center justify-center gap-2">
              <span>Continuar (0)</span>
            </div>
            <div className="text-xs opacity-90">üöö Env√≠o gratis!</div>
          </button>

          {/* M√©todos de pago */}
          <div className="mb-6">
            <p className="mb-2 text-sm font-medium text-gray-900">Paga con</p>
            <div className="flex gap-2">
              <div className="flex h-5 w-8 items-center justify-center rounded bg-blue-600 text-xs font-bold text-white">
                VISA
              </div>
              <div className="flex h-5 w-8 items-center justify-center rounded bg-red-500 text-xs font-bold text-white">
                MC
              </div>
              <div className="flex h-5 w-8 items-center justify-center rounded bg-green-600 text-xs font-bold text-white">
                JCB
              </div>
              <div className="flex h-5 w-8 items-center justify-center rounded bg-blue-500 text-xs font-bold text-white">
                AMEX
              </div>
            </div>
          </div>

          {/* Protecci√≥n del comprador */}
          <div className="border-t pt-4">
            <h3 className="mb-2 text-sm font-medium text-gray-900">
              Protecci√≥n del comprador
            </h3>
            <div className="flex items-start gap-2">
              <ShieldCheck className="mt-0.5 h-4 w-4 flex-shrink-0 text-green-600" />
              <p className="text-xs text-gray-600">
                Recibe un reembolso de tu dinero si el art√≠culo no llega o es
                diferente al de la descripci√≥n.
              </p>
            </div>
          </div>
        </div>
        <StockValidationModal
          isOpen={modal.isOpen}
          result={modal.result}
          onConfirm={modal.onConfirm}
          onCancel={modal.onCancel}
        />
      </>
    )
  }

  return (
    <div className="sticky top-4 border border-gray-200 bg-white p-4">
      <h2 className="mb-4 text-lg font-semibold text-gray-900">Resumen</h2>

      {/* Im√°genes peque√±as de productos seleccionados */}
      <div className="mb-4 flex gap-2">
        {summaryCart.selectedItems.slice(0, 3).map((item) => (
          <div
            key={item.id}
            className="h-12 w-12 overflow-hidden rounded bg-gray-100"
          >
            <Image
              src={item.image}
              alt={item.name}
              width={48}
              height={48}
              className="h-full w-full object-cover"
            />
          </div>
        ))}
        {summaryCart.selectedItems.length > 3 && (
          <div className="flex h-12 w-12 items-center justify-center rounded bg-gray-100 text-xs text-gray-500">
            +{summaryCart.selectedItems.length - 3}
          </div>
        )}
      </div>

      {/* C√°lculos basados en productos seleccionados CON promociones */}
      <div className="mb-4 space-y-3">
        <div className="flex justify-between text-sm">
          <span className="text-gray-600">Total de art√≠culos</span>
          <span className="font-medium">
            {formatPrice(totals.originalTotal)}
          </span>
        </div>

        {hasDiscounts && (
          <div className="flex justify-between text-sm">
            <span className="text-gray-600">Descuento de art√≠culos</span>
            <span className="font-medium text-red-600">
              -{formatPrice(totalDiscount)}
            </span>
          </div>
        )}

        <div className="flex justify-between text-sm font-medium">
          <span>Subtotal</span>
          <span>{formatPrice(totals.finalTotal)}</span>
        </div>

        <div className="flex justify-between text-sm">
          <span className="text-gray-600">Env√≠o</span>
          <span className="font-medium text-green-600">Gratis</span>
        </div>

        {hasDiscounts && (
          <div className="text-xs text-gray-500">
            ¬°{formatPrice(totalDiscount)} ahorrado! Visita la p√°gina de pago
          </div>
        )}
      </div>

      <div className="mb-4 border-t pt-4">
        <div className="flex justify-between text-lg font-bold">
          <span>Estimaci√≥n total</span>
          <span>{formatPrice(totals.finalTotal)}</span>
        </div>
      </div>

      {/* üÜï Bot√≥n actualizado con estados de validaci√≥n */}
      <button
        onClick={handleContinueToCheckout}
        className="mb-3 w-full bg-red-600 py-3 font-bold text-white transition-colors hover:bg-red-700 disabled:cursor-not-allowed disabled:bg-gray-400"
        disabled={!summaryCart.hasSelectedItems() || isLoading}
      >
        <div className="flex items-center justify-center gap-2">
          {isLoading ? (
            <>
              <div className="h-4 w-4 animate-spin rounded-full border-b-2 border-white"></div>
              <span>
                {isValidating ? 'Validando stock...' : 'Redirigiendo...'}
              </span>
            </>
          ) : (
            <span>Continuar ({totals.totalItems})</span>
          )}
        </div>
      </button>

      {/* üÜï Mensaje informativo durante la validaci√≥n */}
      {isValidating && (
        <div className="mb-3 text-center text-xs text-gray-600">
          Verificando disponibilidad de productos...
        </div>
      )}

      {/* M√©todos de pago */}
      <div className="mb-4">
        <p className="mb-2 text-sm font-medium text-gray-900">Paga con</p>
        <div className="flex gap-2">
          <div className="flex h-5 w-8 items-center justify-center rounded bg-blue-600 text-xs font-bold text-white">
            VISA
          </div>
          <div className="flex h-5 w-8 items-center justify-center rounded bg-red-500 text-xs font-bold text-white">
            MC
          </div>
          <div className="flex h-5 w-8 items-center justify-center rounded bg-green-600 text-xs font-bold text-white">
            JCB
          </div>
          <div className="flex h-5 w-8 items-center justify-center rounded bg-blue-500 text-xs font-bold text-white">
            AMEX
          </div>
        </div>
      </div>

      {/* Protecci√≥n del comprador */}
      <div className="border-t pt-4">
        <h3 className="mb-2 text-sm font-medium text-gray-900">
          Protecci√≥n del comprador
        </h3>
        <div className="flex items-start gap-2">
          <ShieldCheck className="mt-0.5 h-4 w-4 flex-shrink-0 text-green-600" />
          <p className="text-xs text-gray-600">
            Recibe un reembolso de tu dinero si el art√≠culo no llega o es
            diferente al de la descripci√≥n.
          </p>
        </div>
      </div>

      {/* Resumen de promociones aplicadas (si las hay) */}
      {/* <CartPageSummaryPromotions /> */}

      <StockValidationModal
        isOpen={modal.isOpen}
        result={modal.result}
        onConfirm={modal.onConfirm}
        onCancel={modal.onCancel}
      />
    </div>
  )
}



üìÅ ARCHIVO: src/components/cart/CartPageItem.tsx
------------------------------------------------------------------------------------
import { PlusMinusButton } from '@/components/ui/PlusMinusButton'
import { formatPrice } from '@/helpers/utils'
import { type CartItem } from '@/hooks/useCart'
import { useCartContext } from '@/providers/cart'
import { AlertTriangle, Package, Trash2 } from 'lucide-react'
import Image from 'next/image'
import Link from 'next/link'
import { type FC } from 'react'

// Helper para obtener precio con promoci√≥n
const getPriceIfHasPromotion = (item: CartItem) => {
  const currentPromotion = item.promotionVariants?.[0]
  const originalPrice = Number(item.price)
  const promotionPrice = currentPromotion
    ? Number(currentPromotion.promotionPrice)
    : null
  const finalPrice = promotionPrice || originalPrice

  return {
    finalPrice,
    hasPromotion: Boolean(currentPromotion),
    originalPrice,
    currentPromotion
  }
}

interface CartPageItemProps {
  item: CartItem
  isSelected: boolean
  onToggleSelection: () => void
  // üÜï Informaci√≥n de stock actualizada desde validaci√≥n
  stockInfo?: {
    id: number
    availableStock: number
  }
}

export const CartPageItem: FC<CartPageItemProps> = ({
  item,
  isSelected,
  onToggleSelection,
  stockInfo // üÜï Recibir stockInfo desde el padre
}) => {
  const { updateQuantity, openDeleteConfirmation } = useCartContext()
  const { finalPrice, hasPromotion, originalPrice } =
    getPriceIfHasPromotion(item)

  // ‚úÖ Determinar el stock actual
  // Si stockInfo est√° disponible, usarlo; si no, usar el stock del item
  const currentStock = stockInfo?.availableStock ?? item.stock
  const hasStockIssue = item.quantity > currentStock
  const isOutOfStock = currentStock === 0

  // ‚úÖ SIEMPRE usar el stock real para controles (no el stock original)
  const stockForControls = currentStock
  const maxAvailable = Math.max(0, stockForControls)

  const handleQuantityChange = (newQuantity: number) => {
    console.log(
      `üîÑ Quantity change requested for item ${item.id} (${item.name}):`
    )
    console.log(`   Current quantity: ${item.quantity}`)
    console.log(`   New quantity: ${newQuantity}`)
    console.log(`   Current item stock: ${item.stock}`)
    console.log(`   Current stockInfo: ${stockInfo?.availableStock ?? 'none'}`)

    // ‚úÖ SIEMPRE actualizar la cantidad, independientemente del stock
    // La validaci√≥n de stock es solo para mostrar advertencias, no para bloquear cambios
    if (newQuantity >= 0) {
      console.log(`‚úÖ Calling updateQuantity(${item.id}, ${newQuantity})`)

      // üîç Verificar localStorage antes del update
      const cartBefore = JSON.parse(localStorage.getItem('cart') || '[]')
      const itemBefore = cartBefore.find(
        (cartItem: any) => cartItem.id === item.id
      )
      console.log('üìã Item in localStorage BEFORE update:', itemBefore)

      updateQuantity(item.id, newQuantity)

      // üîç Verificar localStorage despu√©s del update (con delay)
      setTimeout(() => {
        const cartAfter = JSON.parse(localStorage.getItem('cart') || '[]')
        const itemAfter = cartAfter.find(
          (cartItem: any) => cartItem.id === item.id
        )
        console.log('üìã Item in localStorage AFTER update:', itemAfter)
      }, 50)
    } else {
      console.log(`‚ùå Invalid quantity: ${newQuantity} (must be >= 0)`)
    }
  }

  const handleRemove = () => {
    openDeleteConfirmation(item.id, item.name)
  }

  // ‚úÖ Funci√≥n para ajuste r√°pido a stock m√°ximo
  const handleQuickAdjust = () => {
    if (currentStock > 0) {
      updateQuantity(item.id, currentStock)
    }
  }

  return (
    <div
      className={`relative border bg-white p-4 transition-all hover:shadow-sm ${
        hasStockIssue ? 'border-red-200 bg-red-50' : ''
      }`}
    >
      <div className="flex gap-4">
        {/* Checkbox */}
        <div className="flex-shrink-0 pt-2">
          <input
            type="checkbox"
            className="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
            checked={isSelected}
            onChange={onToggleSelection}
          />
        </div>

        {/* Imagen del producto */}
        <div className="flex-shrink-0">
          <div className="relative h-20 w-20 overflow-hidden bg-gray-100">
            <Link href={`/productos/variante/${item.id}`}>
              <Image
                src={item.image}
                alt={item.name}
                fill
                sizes="80px"
                className="object-cover transition-transform hover:scale-105"
              />
            </Link>
          </div>
        </div>

        {/* Informaci√≥n del producto */}
        <div className="min-w-0 flex-1">
          <div>
            <div className="flex flex-1 flex-col gap-2 pr-4">
              <div className="flex w-full justify-between">
                <h3 className="line-clamp-2 font-medium text-gray-900">
                  <Link
                    href={`/productos/variante/${item.id}`}
                    className="transition-colors hover:text-blue-600"
                  >
                    <div className="flex items-center">
                      {/* Badge de promoci√≥n */}
                      {hasPromotion && (
                        <div className="z-10 mr-1 h-4 bg-red-500 px-1 text-[11px] font-semibold leading-4 text-white">
                          Promo
                        </div>
                      )}
                      <span>{item.name}</span>
                    </div>
                  </Link>
                </h3>
                <div className="flex items-center gap-4 text-sm">
                  <button
                    onClick={handleRemove}
                    className="flex items-center gap-1 transition-colors"
                  >
                    <Trash2 className="h-4 w-4" />
                  </button>
                </div>
              </div>

              <div className="flex w-full justify-between">
                {hasPromotion ? (
                  <div className="flex items-end gap-1">
                    {/* Precio con promoci√≥n */}
                    <div className="text-lg font-semibold leading-5 text-red-500">
                      {formatPrice(finalPrice)}
                    </div>
                    {/* Precio original tachado */}
                    <div className="text-sm leading-[14px] text-gray-500 line-through">
                      {formatPrice(originalPrice)}
                    </div>
                  </div>
                ) : (
                  <div className="text-lg font-semibold text-gray-900">
                    {formatPrice(finalPrice)}
                  </div>
                )}

                {/* Precio y controles */}
                <div className="flex flex-col items-end gap-3">
                  {/* Controles de cantidad */}
                  <div className="flex items-center gap-2">
                    <PlusMinusButton
                      stock={stockForControls} // ‚úÖ Usar stock contextual
                      initialQuantity={item.quantity}
                      onQuantityChange={handleQuantityChange}
                      onRemoveRequest={handleRemove}
                      size="sm"
                      allowRemove={true}
                      // üÜï Preservar cantidad del usuario cuando hay validaci√≥n de stock
                      preserveQuantity={Boolean(stockInfo)}
                    />
                  </div>
                </div>
              </div>
              {/* ‚úÖ Advertencia de stock (solo se muestra cuando hay problemas Y stockInfo) */}
              {stockInfo && hasStockIssue && (
                <div
                  className={`mt-2 rounded p-2 ${
                    isOutOfStock
                      ? 'border border-red-200 bg-red-100'
                      : 'border border-orange-200 bg-orange-100'
                  }`}
                >
                  <div className="flex items-center gap-2">
                    {isOutOfStock ? (
                      <Package className="h-4 w-4 text-red-600" />
                    ) : (
                      <AlertTriangle className="h-4 w-4 text-orange-600" />
                    )}
                    <span
                      className={`text-sm font-medium ${
                        isOutOfStock ? 'text-red-700' : 'text-orange-700'
                      }`}
                    >
                      {isOutOfStock ? 'Sin stock disponible' : 'Stock limitado'}
                    </span>
                  </div>

                  <p
                    className={`mt-1 text-xs ${
                      isOutOfStock ? 'text-red-600' : 'text-orange-600'
                    }`}
                  >
                    {isOutOfStock
                      ? 'Este producto ya no est√° disponible'
                      : `Tienes ${item.quantity} seleccionados, pero solo hay ${currentStock} disponible${currentStock !== 1 ? 's' : ''}`}
                  </p>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/cart/CartPageHeader.tsx
------------------------------------------------------------------------------------
import { type CartItem } from '@/hooks/useCart'
import { ArrowLeft } from 'lucide-react'
import Link from 'next/link'
import { type FC } from 'react'

interface CartPageHeaderProps {
  items: CartItem[]
}

export const CartPageHeader: FC<CartPageHeaderProps> = ({ items }) => {
  return (
    <div className="mb-8">
      <div className="mb-4 flex items-center gap-4">
        <Link
          href="/"
          className="flex items-center gap-2 text-gray-600 transition-colors hover:text-gray-900"
        >
          <ArrowLeft className="h-5 w-5" />
          Continuar comprando
        </Link>
      </div>
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold text-gray-900">Carrito de Compras</h1>
        <div className="text-sm text-gray-600">
          {items.length} {items.length === 1 ? 'producto' : 'productos'} en tu
          carrito
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/cart/CartPageSummaryPromotions.tsx
------------------------------------------------------------------------------------
import { calculateTotalsWithPromotions } from '@/components/cart/CartPageSummary.helpers'
import { getPriceIfHasPromotion } from '@/components/product/ProductVariant.helpers'
import { formatPrice } from '@/helpers/utils'
import useSummaryCart from '@/hooks/useSummaryCart'
import { useCartContext } from '@/providers/cart'

export const CartPageSummaryPromotions = () => {
  const { items } = useCartContext()

  // üÜï Hook dedicado para el manejo de la selecci√≥n del resumen
  const summaryCart = useSummaryCart(items)

  const totals = calculateTotalsWithPromotions(summaryCart.selectedItems)
  const totalDiscount = totals.originalTotal - totals.finalTotal
  const hasDiscounts = totalDiscount > 0

  return (
    <>
      {hasDiscounts && (
        <div className="mt-4 border-t pt-4">
          <h3 className="mb-2 text-sm font-medium text-gray-900">
            Promociones aplicadas
          </h3>
          <div className="space-y-2">
            {summaryCart.selectedItems
              .filter((item) => getPriceIfHasPromotion(item).hasPromotion)
              .map((item) => {
                const { currentPromotion } = getPriceIfHasPromotion(item)
                const itemDiscount =
                  (Number(item.price) -
                    Number(currentPromotion?.promotionPrice || item.price)) *
                  item.quantity

                return (
                  <div key={item.id} className="flex justify-between text-xs">
                    <span className="text-green-600">
                      {currentPromotion?.promotion?.name}
                    </span>
                    <span className="font-medium text-green-600">
                      -{formatPrice(itemDiscount)}
                    </span>
                  </div>
                )
              })}
          </div>
        </div>
      )}
    </>
  )
}



üìÅ ARCHIVO: src/components/cart/CartPageSummary.helpers.ts
------------------------------------------------------------------------------------
import { getPriceIfHasPromotion } from '@/components/product/ProductVariant.helpers'
import { type CartItem } from '@/hooks/useCart'

// Calcular totales considerando promociones
export const calculateTotalsWithPromotions = (items: CartItem[]) => {
  return items.reduce(
    (acc, item) => {
      const { finalPrice, originalPrice } = getPriceIfHasPromotion(item)
      const itemOriginalTotal = originalPrice * item.quantity
      const itemFinalTotal = finalPrice * item.quantity

      acc.originalTotal += itemOriginalTotal
      acc.finalTotal += itemFinalTotal
      acc.totalItems += item.quantity

      return acc
    },
    { originalTotal: 0, finalTotal: 0, totalItems: 0 }
  )
}



üìÅ ARCHIVO: src/components/cart/CartPageEmpty.tsx
------------------------------------------------------------------------------------
import { ArrowLeft, ShoppingBag } from 'lucide-react'
import Link from 'next/link'

export const CartPageEmpty = () => {
  return (
    <div className="mx-auto max-w-screen-4xl px-12 py-16">
      <div className="text-center">
        <div className="mx-auto mb-8 flex h-24 w-24 items-center justify-center rounded-full bg-gray-100">
          <ShoppingBag className="h-12 w-12 text-gray-400" />
        </div>
        <h1 className="mb-4 text-3xl font-bold text-gray-900">
          Tu carrito est√° vac√≠o
        </h1>
        <p className="mx-auto mb-8 max-w-md text-gray-600">
          Parece que a√∫n no has agregado ning√∫n producto a tu carrito. ¬°Explora
          nuestros productos y encuentra algo que te guste!
        </p>
        <Link
          href="/"
          className="inline-flex items-center gap-2 bg-primary px-8 py-3 font-medium text-white transition-colors hover:bg-primary-700"
        >
          <ArrowLeft className="h-5 w-5" />
          Continuar comprando
        </Link>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/cart/CartPageContent.tsx
------------------------------------------------------------------------------------
'use client'
import { CartPageEmpty } from '@/components/cart/CartPageEmpty'
import { CartPageItem } from '@/components/cart/CartPageItem'
import { CartPageSummary } from '@/components/cart/CartPageSummary'
import { CartPageSkeleton } from '@/components/cart/Skeleton/CartPageSkeleton'
import { useSummaryCart } from '@/hooks/useSummaryCart'
import { useCartContext } from '@/providers/cart'
import { useEffect, useState } from 'react'

export default function CartPageContent() {
  const {
    items,
    totalItems,
    isInitialized,
    openDeleteConfirmation,
    removeItem,
    updateQuantity
  } = useCartContext()

  // üÜï Estado para almacenar informaci√≥n de stock actualizada desde validaci√≥n
  const [stockInfo, setStockInfo] = useState<
    Array<{ id: number, availableStock: number }>
  >([])

  // üÜï Hook dedicado para el manejo de la selecci√≥n del resumen
  const summaryCart = useSummaryCart(items)

  // üÜï CARGAR stockInfo desde localStorage al inicializar
  useEffect(() => {
    if (isInitialized) {
      try {
        const savedStockInfo = localStorage.getItem('stockValidationInfo')
        if (savedStockInfo) {
          const parsedStockInfo = JSON.parse(savedStockInfo)
          console.log(
            'üì¶ Restored stock validation info from localStorage:',
            parsedStockInfo
          )
          setStockInfo(parsedStockInfo)
        } else {
          console.log('üì≠ No stock validation info found in localStorage')
        }
      } catch (error) {
        console.error(
          '‚ùå Error loading stock validation info from localStorage:',
          error
        )
      }
    }
  }, [isInitialized])

  // Mostrar shimmer mientras carga
  if (!isInitialized) {
    return <CartPageSkeleton />
  }

  // Mostrar p√°gina vac√≠a si no hay items
  if (items.length === 0) {
    return <CartPageEmpty />
  }

  const handleRemoveSelectedItems = () => {
    const selectedItems = summaryCart.selectedItems
    openDeleteConfirmation(
      -1,
      '¬øEst√°s seguro de que quieres eliminar los art√≠culo(s) de tu cesta?',
      () => {
        selectedItems.forEach((item) => { removeItem(item.id) })
      }
    )
  }

  // üÜï Funci√≥n para recibir actualizaciones de stock desde CartPageSummary
  const handleStockInfoUpdate = (
    newStockInfo: Array<{ id: number, availableStock: number }>
  ) => {
    console.log('üì¶ Stock info received in CartPageContent:', newStockInfo)
    setStockInfo(newStockInfo)

    // üÜï GUARDAR stockInfo en localStorage para persistir despu√©s de recargas
    localStorage.setItem('stockValidationInfo', JSON.stringify(newStockInfo))
    console.log('üíæ Stock validation info saved to localStorage')

    // üÜï Actualizar SOLO el stock en localStorage, mantener quantity del usuario
    const currentCart = JSON.parse(localStorage.getItem('cart') || '[]')
    console.log('üìã Current cart before stock update:', currentCart)

    const updatedCart = currentCart.map((cartItem: any) => {
      const stockUpdate = newStockInfo.find((info) => info.id === cartItem.id)
      if (stockUpdate) {
        console.log(`üì¶ Updating stock for ${cartItem.name}:`)
        console.log(
          `   Stock: ${cartItem.stock} ‚Üí ${stockUpdate.availableStock}`
        )
        console.log(`   Quantity: ${cartItem.quantity} (unchanged)`)

        const updatedItem = {
          ...cartItem,
          stock: stockUpdate.availableStock // ‚úÖ Solo actualizar stock
          // quantity se mantiene igual - es lo que eligi√≥ el usuario
        }

        console.log('üì¶ Updated item:', updatedItem)
        return updatedItem
      }
      return cartItem
    })

    // üîç Debug: verificar que los datos sean correctos antes de guardar
    console.log('üíæ About to save updated cart:', updatedCart)

    // Guardar el carrito actualizado en localStorage
    localStorage.setItem('cart', JSON.stringify(updatedCart))

    // üîç Verificar que se guard√≥ correctamente
    const savedCart = JSON.parse(localStorage.getItem('cart') || '[]')
    console.log('‚úÖ Verified saved cart:', savedCart)
    console.log('üíæ Updated cart with new stock info saved to localStorage')
    console.log('üìã User quantities preserved - no automatic changes made')

    // üÜï Forzar actualizaci√≥n del contexto del carrito si es necesario
    setTimeout(() => {
      console.log('üîÑ Triggering cart update event')
      window.dispatchEvent(new Event('cartUpdated'))
    }, 100)
  }

  // üÜï Funci√≥n para limpiar informaci√≥n de stock validado
  const clearStockValidationInfo = () => {
    console.log('üßπ Clearing stock validation info')
    setStockInfo([])
    localStorage.removeItem('stockValidationInfo')
  }

  // üÜï Funci√≥n para manejar actualizaciones del carrito (remover/ajustar cantidades)
  const handleCartUpdate = (
    adjustedItems: Array<{ id: number, quantity: number }>
  ) => {
    console.log('üîÑ Processing cart updates in CartPageContent:', adjustedItems)

    adjustedItems.forEach((adjustment) => {
      if (adjustment.quantity === 0) {
        console.log(`‚ùå Removing item ${adjustment.id} from cart`)
        removeItem(adjustment.id)
      } else {
        console.log(
          `üîÑ Updating item ${adjustment.id} quantity to ${adjustment.quantity}`
        )
        updateQuantity(adjustment.id, adjustment.quantity)
      }
    })
  }

  // üÜï Funci√≥n para obtener stock info para un item espec√≠fico
  const getStockInfoForItem = (itemId: number) => {
    return stockInfo.find((info) => info.id === itemId)
  }

  return (
    <div className="mx-auto max-w-7xl px-4 py-6 pt-4">
      {/* Header */}
      <div className="mb-6">
        <div className="flex items-center justify-between">
          <h1 className="text-xl font-bold text-gray-900">
            Cesta ({totalItems})
          </h1>
        </div>
      </div>

      <div className="grid grid-cols-1 gap-6 xl:grid-cols-12">
        {/* Lista de productos */}
        <div className="xl:col-span-8">
          {/* Header con opciones de selecci√≥n */}
          <div className="mb-4 border border-gray-200 bg-white p-4">
            <div className="flex items-center justify-between">
              <label className="flex cursor-pointer items-center gap-3">
                <input
                  type="checkbox"
                  className="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                  checked={summaryCart.isAllSelected}
                  onChange={summaryCart.toggleSelectAll}
                />
                <span className="text-sm font-medium text-gray-900">
                  Seleccionar todos los art√≠culos
                </span>
              </label>
              <button
                className="text-sm font-medium text-blue-600 hover:text-blue-700 disabled:cursor-not-allowed disabled:text-gray-400"
                onClick={handleRemoveSelectedItems}
                disabled={summaryCart.getSelectedCount() === 0}
              >
                Borrar art√≠culos seleccionados ({summaryCart.getSelectedCount()}
                )
              </button>
            </div>
          </div>

          {/* Productos */}
          <div className="space-y-4">
            {items.map((item) => {
              const stockInfoForItem = getStockInfoForItem(item.id) // üÜï Obtener stock info espec√≠fico

              return (
                <CartPageItem
                  key={item.id}
                  item={item}
                  isSelected={summaryCart.isItemSelected(item.id)}
                  onToggleSelection={() => { summaryCart.toggleItemSelection(item.id) }
                  }
                  stockInfo={stockInfoForItem} // üÜï Pasar stock info al item
                />
              )
            })}
          </div>
        </div>

        {/* Resumen del pedido */}
        <div className="xl:col-span-4">
          <CartPageSummary
            summaryCart={summaryCart}
            onCartUpdate={handleCartUpdate} // üÜï Callback para manejar actualizaciones del carrito
            onStockInfoReceived={handleStockInfoUpdate} // üÜï Callback para recibir info de stock
          />
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/cart/CartPageActivePromotions.tsx
------------------------------------------------------------------------------------
import { type CartItem } from '@/hooks/useCart'
import { Clock, Tag } from 'lucide-react'
import { type FC } from 'react'

// Helper para obtener promoci√≥n de un item
const getPromotionFromItem = (item: CartItem) => {
  return item.promotionVariants?.[0]
}

// Helper para formatear fecha de promoci√≥n
const formatPromotionEndDate = (endDate?: string | null): string => {
  if (!endDate) return 'Fail Date'
  const date = new Date(endDate)
  return date.toLocaleDateString('es-PE', {
    day: 'numeric',
    month: 'short',
    hour: '2-digit',
    minute: '2-digit',
    timeZone: 'America/Lima'
  })
}

interface CartPageActivePromotionsProps {
  selectedItems: CartItem[]
}

export const CartPageActivePromotions: FC<CartPageActivePromotionsProps> = ({
  selectedItems
}) => {
  // Obtener promociones √∫nicas de los items seleccionados que tienen promoci√≥n
  const activePromotions = selectedItems
    .filter((item) => getPromotionFromItem(item)) // Solo items con promoci√≥n
    .map((item) => getPromotionFromItem(item)) // Extraer la promoci√≥n
    .filter(
      (promo, index, self) =>
        // Eliminar duplicados por promotionId
        promo &&
        index === self.findIndex((p) => p?.promotionId === promo.promotionId)
    )

  // Si no hay promociones activas en los productos seleccionados, no mostrar nada
  if (activePromotions.length === 0) {
    return null
  }

  return (
    <div className="mb-4 space-y-3">
      {activePromotions.map((promotion) => {
        if (!promotion?.promotion) return null

        return (
          <div
            key={promotion.promotionId}
            className="bg-gradient-to-r from-blue-500 to-blue-600 px-4 py-2 text-white"
          >
            <div className="flex items-start justify-between">
              {/* Lado izquierdo: Informaci√≥n de la promoci√≥n */}
              <div className="flex-1">
                <div>
                  <div className="flex w-full justify-between">
                    <div className="flex items-center gap-2">
                      <Tag className="h-4 w-4" />
                      <h3 className="text-lg font-semibold">
                        Promoci√≥n {promotion.promotion.name}
                      </h3>
                    </div>
                    <div className="flex items-center gap-1">
                      <Clock className="h-3 w-3" />
                      <span className="text-xs opacity-90">
                        Termina:{' '}
                        {formatPromotionEndDate(
                          promotion?.promotion?.endDate.toString()
                        )}{' '}
                        (GMT-5)
                      </span>
                    </div>
                  </div>

                  {/* <p className="text-sm opacity-90 mb-2">
                    {promotion.promotion.description}
                  </p> */}
                  {/* Badges de informaci√≥n */}
                  <div className="flex items-center gap-3 text-sm">
                    {/* <div className="bg-white/20 rounded px-2 py-1">
                      <span className="font-medium">
                        {promotion.promotion.discountType === 'percentage'
                          ? `${Number(promotion.promotion.discountValue)}% OFF`
                          : `${formatPrice(Number(promotion.promotion.discountValue))} OFF`}
                      </span>
                    </div> */}

                    {/* {promotion.stockLimit && (
                    <div className="bg-orange-500/80 rounded px-2 py-1">
                      <span className="text-xs font-medium">
                        Stock limitado: {promotion.stockLimit}
                      </span>
                    </div>
                  )} */}

                    {/* <div className="bg-green-500/80 rounded px-2 py-1">
                    <span className="text-xs font-medium">
                      {affectedItems.length} producto{affectedItems.length > 1 ? 's' : ''}
                    </span>
                  </div> */}
                  </div>
                </div>
              </div>

              {/* Lado derecho: Descuento aplicado */}
              {/* <CartPageSummaryPromotions /> */}
            </div>
          </div>
        )
      })}
    </div>
  )
}



üìÅ ARCHIVO: src/components/account/EditProfile/use-edit-profile.hook.ts
------------------------------------------------------------------------------------
import {
  editProfileSchema,
  type EditProfileFormData
} from '@/components/account/EditProfile/EditProfile.schema'
import { type Customers } from '@/types/domain'
import { useState } from 'react'
import { z } from 'zod'

interface UseEditProfileProps {
  customer: Customers
}

interface UseEditProfileReturn {
  // Form data
  formData: EditProfileFormData
  setFormData: React.Dispatch<React.SetStateAction<EditProfileFormData>>

  // Form validation
  errors: Record<string, string>
  validateForm: () => boolean
  validateField: (fieldName: string, value: string) => string | null

  // Form submission
  isLoading: boolean
  message: string
  handleSubmit: (e: React.FormEvent) => Promise<void>

  // Input handling
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void

  // Reset form
  resetForm: () => void

  // Check if form has changes
  hasChanges: () => boolean
}

export const useEditProfile = ({
  customer
}: UseEditProfileProps): UseEditProfileReturn => {
  const initialData: EditProfileFormData = {
    name: customer.name || '',
    lastname: customer.lastname || '',
    email: customer.email || '',
    phone: customer.phone || '',
    dni: customer.dni || ''
  }

  const [formData, setFormData] = useState<EditProfileFormData>(initialData)
  const [isLoading, setIsLoading] = useState(false)
  const [message, setMessage] = useState('')
  const [errors, setErrors] = useState<Record<string, string>>({})

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target

    // Formatear valor seg√∫n el campo
    let formattedValue = value

    if (name === 'dni' || name === 'phone') {
      // Solo permitir n√∫meros
      formattedValue = value.replace(/\D/g, '')

      // Limitar longitud
      if (name === 'dni' && formattedValue.length > 8) {
        formattedValue = formattedValue.slice(0, 8)
      }
      if (name === 'phone' && formattedValue.length > 9) {
        formattedValue = formattedValue.slice(0, 9)
      }
    }

    if (name === 'name' || name === 'lastname') {
      // Solo permitir letras y espacios
      formattedValue = value.replace(/[^a-zA-Z√°√©√≠√≥√∫√Å√â√ç√ì√ö√±√ë\s]/g, '')
    }

    setFormData((prev) => ({ ...prev, [name]: formattedValue }))

    // Limpiar error del campo actual y validar en tiempo real
    if (errors[name]) {
      setErrors((prev) => ({ ...prev, [name]: '' }))
    }

    // Validaci√≥n en tiempo real
    const fieldError = validateField(name, formattedValue)
    if (fieldError) {
      setErrors((prev) => ({ ...prev, [name]: fieldError }))
    }
  }

  const validateField = (fieldName: string, value: string): string | null => {
    try {
      const fieldSchema =
        editProfileSchema.shape[
          fieldName as keyof typeof editProfileSchema.shape
        ]
      fieldSchema.parse(value)
      return null
    } catch (error) {
      if (error instanceof z.ZodError) {
        return error.errors[0]?.message || 'Campo inv√°lido'
      }
      return null
    }
  }

  const validateForm = () => {
    try {
      editProfileSchema.parse(formData)
      setErrors({})
      return true
    } catch (error) {
      if (error instanceof z.ZodError) {
        const newErrors: Record<string, string> = {}
        error.errors.forEach((err) => {
          if (err.path.length > 0) {
            newErrors[err.path[0] as string] = err.message
          }
        })
        setErrors(newErrors)
      }
      return false
    }
  }

  const hasChanges = () => {
    return JSON.stringify(formData) !== JSON.stringify(initialData)
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    if (!validateForm()) {
      return
    }

    if (!hasChanges()) {
      setMessage('No hay cambios para guardar')
      return
    }

    setIsLoading(true)
    setMessage('')

    try {
      const response = await fetch('/api/customer/profile', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData)
      })

      if (response.ok) {
        setMessage('Informaci√≥n actualizada correctamente')
        // Actualizar los datos iniciales para el siguiente check de cambios
        Object.assign(initialData, formData)
      } else {
        const error = await response.json()
        setMessage(error.message || 'Error al actualizar la informaci√≥n')
      }
    } catch (error) {
      setMessage('Error de conexi√≥n')
      console.error('Error updating profile:', error)
    } finally {
      setIsLoading(false)
    }
  }

  const resetForm = () => {
    setFormData(initialData)
    setErrors({})
    setMessage('')
  }

  return {
    // Form data
    formData,
    setFormData,

    // Form validation
    errors,
    validateForm,
    validateField,

    // Form submission
    isLoading,
    message,
    handleSubmit,

    // Input handling
    handleInputChange,

    // Reset
    resetForm,

    // Changes detection
    hasChanges
  }
}



üìÅ ARCHIVO: src/components/account/EditProfile/EditProfile.schema.ts
------------------------------------------------------------------------------------
import { z } from 'zod'

export const editProfileSchema = z.object({
  name: z
    .string()
    .min(1, 'El nombre es requerido')
    .min(2, 'El nombre debe tener al menos 2 caracteres')
    .max(50, 'El nombre no puede exceder 50 caracteres')
    .regex(/^[a-zA-Z√°√©√≠√≥√∫√Å√â√ç√ì√ö√±√ë\s]+$/, 'El nombre solo puede contener letras'),
  lastname: z
    .string()
    .min(1, 'El apellido es requerido')
    .min(2, 'El apellido debe tener al menos 2 caracteres')
    .max(50, 'El apellido no puede exceder 50 caracteres')
    .regex(
      /^[a-zA-Z√°√©√≠√≥√∫√Å√â√ç√ì√ö√±√ë\s]+$/,
      'El apellido solo puede contener letras'
    ),
  email: z
    .string()
    .min(1, 'El email es requerido')
    .email('Por favor ingresa un email v√°lido'),
  phone: z
    .string()
    .min(1, 'El tel√©fono es requerido')
    .regex(
      /^9\d{8}$/,
      'El tel√©fono debe ser un celular v√°lido (9 d√≠gitos que empiece con 9)'
    ),
  dni: z
    .string()
    .min(1, 'El DNI es requerido')
    .regex(/^\d{8}$/, 'El DNI debe tener 8 d√≠gitos')
})

export type EditProfileFormData = z.infer<typeof editProfileSchema>



üìÅ ARCHIVO: src/components/account/EditProfile/EditProfile.tsx
------------------------------------------------------------------------------------
'use client'

import { Button } from '@/components/ui/Button'
import { Input } from '@/components/ui/Input'
import { Label } from '@/components/ui/Label'
import { type Customers } from '@/types/domain'
import { CreditCard, Mail, Phone, Save, User } from 'lucide-react'
import { useEditProfile } from './use-edit-profile.hook'

interface EditProfileProps {
  customer: Customers
}

export default function EditProfile({ customer }: EditProfileProps) {
  const {
    formData,
    errors,
    isLoading,
    message,
    handleSubmit,
    handleInputChange,
    hasChanges,
    resetForm
  } = useEditProfile({ customer })

  return (
    <div>
      <div className="mb-8 flex items-center gap-2">
        <User className="h-5 w-5" />
        <h2 className="text-xl font-bold">Datos personales</h2>
      </div>

      <form onSubmit={handleSubmit} className="max-w-md space-y-6">
        {/* Nombre y Apellido */}
        <div className="grid gap-4 md:grid-cols-2">
          <div className="space-y-2">
            <Label htmlFor="name">Nombre</Label>
            <Input
              id="name"
              name="name"
              type="text"
              value={formData.name}
              onChange={handleInputChange}
              className={`${errors.name ? 'border-red-500 focus:border-red-500 focus:ring-red-500' : 'border-gray-300 focus:border-blue-500 focus:ring-blue-500'} focus:ring-2`}
              placeholder="Ingresa tu nombre"
            />
            {errors.name && (
              <p className="flex items-center gap-1 text-sm text-red-600">
                <span className="h-1 w-1 rounded-full bg-red-600"></span>
                {errors.name}
              </p>
            )}
          </div>

          <div className="space-y-2">
            <Label htmlFor="lastname">Apellido</Label>
            <Input
              id="lastname"
              name="lastname"
              type="text"
              value={formData.lastname}
              onChange={handleInputChange}
              className={`${errors.lastname ? 'border-red-500 focus:border-red-500 focus:ring-red-500' : 'border-gray-300 focus:border-blue-500 focus:ring-blue-500'} focus:ring-2`}
              placeholder="Ingresa tu apellido"
            />
            {errors.lastname && (
              <p className="flex items-center gap-1 text-sm text-red-600">
                <span className="h-1 w-1 rounded-full bg-red-600"></span>
                {errors.lastname}
              </p>
            )}
          </div>
        </div>

        {/* Email */}
        <div className="space-y-2">
          <Label htmlFor="email" className="flex items-center gap-2">
            <Mail className="h-4 w-4" />
            Email
          </Label>
          <Input
            id="email"
            name="email"
            type="email"
            value={formData.email}
            onChange={handleInputChange}
            className={`${errors.email ? 'border-red-500 focus:border-red-500 focus:ring-red-500' : 'border-gray-300 focus:border-blue-500 focus:ring-blue-500'} focus:ring-2`}
            placeholder="correo@ejemplo.com"
          />
          {errors.email && (
            <p className="flex items-center gap-1 text-sm text-red-600">
              <span className="h-1 w-1 rounded-full bg-red-600"></span>
              {errors.email}
            </p>
          )}
        </div>

        {/* Tel√©fono y DNI */}
        <div className="grid gap-4 md:grid-cols-2">
          <div className="space-y-2">
            <Label htmlFor="phone" className="flex items-center gap-2">
              <Phone className="h-4 w-4" />
              Celular
            </Label>
            <Input
              id="phone"
              name="phone"
              type="tel"
              value={formData.phone}
              onChange={handleInputChange}
              className={`${errors.phone ? 'border-red-500 focus:border-red-500 focus:ring-red-500' : 'border-gray-300 focus:border-blue-500 focus:ring-blue-500'} focus:ring-2`}
              placeholder="987654321"
              maxLength={9}
            />
            {errors.phone && (
              <p className="flex items-center gap-1 text-sm text-red-600">
                <span className="h-1 w-1 rounded-full bg-red-600"></span>
                {errors.phone}
              </p>
            )}
            <p className="text-xs text-gray-500">
              9 d√≠gitos, debe empezar con 9
            </p>
          </div>

          <div className="space-y-2">
            <Label htmlFor="dni" className="flex items-center gap-2">
              <CreditCard className="h-4 w-4" />
              DNI
            </Label>
            <Input
              id="dni"
              name="dni"
              type="text"
              value={formData.dni}
              onChange={handleInputChange}
              className={`${errors.dni ? 'border-red-500 focus:border-red-500 focus:ring-red-500' : 'border-gray-300 focus:border-blue-500 focus:ring-blue-500'} focus:ring-2`}
              placeholder="12345678"
              maxLength={8}
            />
            {errors.dni && (
              <p className="flex items-center gap-1 text-sm text-red-600">
                <span className="h-1 w-1 rounded-full bg-red-600"></span>
                {errors.dni}
              </p>
            )}
            <p className="text-xs text-gray-500">8 d√≠gitos exactos</p>
          </div>
        </div>

        {/* Message */}
        {message && (
          <div
            className={`rounded-lg p-4 ${
              message.includes('Error') || message.includes('error')
                ? 'border border-red-200 bg-red-50 text-red-700'
                : message.includes('No hay cambios')
                  ? 'border border-yellow-200 bg-yellow-50 text-yellow-700'
                  : 'border border-green-200 bg-green-50 text-green-700'
            }`}
          >
            <div className="flex items-center gap-2">
              <div
                className={`h-2 w-2 rounded-full ${
                  message.includes('Error') || message.includes('error')
                    ? 'bg-red-600'
                    : message.includes('No hay cambios')
                      ? 'bg-yellow-600'
                      : 'bg-green-600'
                }`}
              ></div>
              {message}
            </div>
          </div>
        )}

        {/* Submit Buttons */}
        <div className="flex gap-3">
          <Button
            type="submit"
            disabled={isLoading || !hasChanges()}
            className="flex items-center gap-2 rounded-lg bg-black px-6 py-3 font-medium text-white transition-colors duration-200 hover:bg-gray-800 disabled:cursor-not-allowed disabled:opacity-50"
          >
            <Save className="h-4 w-4" />
            {isLoading ? (
              <div className="flex items-center gap-2">
                <div className="h-4 w-4 animate-spin rounded-full border-2 border-white border-t-transparent"></div>
                Guardando...
              </div>
            ) : (
              'Guardar Cambios'
            )}
          </Button>

          {hasChanges() && (
            <Button
              type="button"
              variant="outline"
              onClick={resetForm}
              disabled={isLoading}
              className="border-gray-300 px-6 py-3 text-gray-700 hover:bg-gray-50"
            >
              Cancelar
            </Button>
          )}
        </div>
      </form>
    </div>
  )
}



üìÅ ARCHIVO: src/components/account/EditProfile/index.ts
------------------------------------------------------------------------------------
export { default } from './EditProfile'



üìÅ ARCHIVO: src/components/account/AccountLayout.tsx
------------------------------------------------------------------------------------
'use client'

import {
  ChevronRight,
  Lock,
  LogOut,
  MapPinHouse,
  Package,
  User
} from 'lucide-react'
import { signOut } from 'next-auth/react'
import Link from 'next/link'
import { usePathname } from 'next/navigation'

interface AccountLayoutProps {
  children: React.ReactNode
  userName?: string
}

export default function AccountLayout({
  children,
  userName = 'John Doe'
}: AccountLayoutProps) {
  const pathname = usePathname()

  const menuItems = [
    {
      href: '/account/orders',
      label: 'Mis compras',
      icon: Package,
      active: pathname.startsWith('/account/orders')
    },
    {
      href: '/account/edit-profile',
      label: 'Datos personales',
      icon: User,
      active: pathname === '/account/edit-profile'
    },
    {
      href: '/account/change-password',
      label: 'Cambiar contrase√±a',
      icon: Lock,
      active: pathname === '/account/change-password'
    },
    {
      href: '/account/addresses',
      label: 'Direcciones',
      icon: MapPinHouse,
      active: pathname === '/account/addresses'
    }
  ]

  const handleSignOut = () => {
    signOut({ callbackUrl: '/' })
  }

  return (
    <div className="min-h-screen bg-gray-50 px-8 py-16">
      <div className="mx-auto max-w-6xl">
        <h1 className="mb-8 text-2xl font-bold">Mi cuenta</h1>

        <div className="flex gap-8">
          {/* Sidebar */}
          <div className="w-96 bg-white p-6">
            <div className="mb-8">
              <h2 className="mb-4 text-lg font-semibold">Hola, {userName}</h2>
            </div>

            <nav className="space-y-2">
              {menuItems.map((item) => {
                const Icon = item.icon
                return (
                  <Link
                    key={item.href}
                    href={item.href}
                    className={`flex items-center justify-between p-3 transition-colors ${
                      item.active
                        ? 'bg-gray-100'
                        : 'text-gray-700 hover:bg-gray-50'
                    }`}
                  >
                    <div className="flex items-center gap-3">
                      <Icon className="h-5 w-5" />
                      <span className={item.active ? 'font-medium' : ''}>
                        {item.label}
                      </span>
                    </div>
                    <ChevronRight className="h-4 w-4 text-gray-400" />
                  </Link>
                )
              })}

              <button
                onClick={handleSignOut}
                className="flex w-full items-center justify-between p-3 text-gray-700 transition-colors hover:bg-gray-50"
              >
                <div className="flex items-center gap-3">
                  <LogOut className="h-5 w-5" />
                  <span>Cerrar sesi√≥n</span>
                </div>
                <ChevronRight className="h-4 w-4 text-gray-400" />
              </button>
            </nav>
          </div>

          {/* Main Content */}
          <div className="flex-1 bg-white p-8">{children}</div>
        </div>
      </div>
    </div>
  )
}



üìÅ ARCHIVO: src/components/account/AccountHome.tsx
------------------------------------------------------------------------------------
'use client'
import { useRouter } from 'next/navigation'
import { useEffect } from 'react'

const AccountHome = () => {
  const router = useRouter()
  useEffect(() => {
    router.push('/account/edit-profile')
  }, [])
  return null
}

export default AccountHome



üìÅ ARCHIVO: src/components/account/ChangePassword/ChangePassword.helpers.ts
------------------------------------------------------------------------------------



üìÅ ARCHIVO: src/components/account/ChangePassword/use-change-password.hook.ts
------------------------------------------------------------------------------------
// ========================================================================================
// hooks/useChangePassword.ts
import {
  changePasswordSchema,
  type ChangePasswordFormData
} from '@/components/account/ChangePassword/ChangePassword.schema'
import { useState } from 'react'
import z from 'zod'

interface UseChangePasswordReturn {
  // Form data
  formData: ChangePasswordFormData
  setFormData: React.Dispatch<React.SetStateAction<ChangePasswordFormData>>

  // Password visibility
  showPasswords: {
    current: boolean
    new: boolean
    confirm: boolean
  }
  togglePasswordVisibility: (field: 'current' | 'new' | 'confirm') => void

  // Form validation
  errors: Record<string, string>
  validateForm: () => boolean

  // Form submission
  isLoading: boolean
  message: string
  handleSubmit: (e: React.FormEvent) => Promise<void>

  // Input handling
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void

  // Password criteria checking
  getPasswordCriteriaStatus: (criteria: string) => boolean

  // Reset form
  resetForm: () => void
}

export const useChangePassword = (): UseChangePasswordReturn => {
  const [formData, setFormData] = useState<ChangePasswordFormData>({
    currentPassword: '',
    newPassword: '',
    confirmPassword: ''
  })

  const [showPasswords, setShowPasswords] = useState({
    current: false,
    new: false,
    confirm: false
  })

  const [isLoading, setIsLoading] = useState(false)
  const [message, setMessage] = useState('')
  const [errors, setErrors] = useState<Record<string, string>>({})

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target
    setFormData((prev) => ({ ...prev, [name]: value }))

    // Limpiar error del campo actual cuando el usuario empiece a escribir
    if (errors[name]) {
      setErrors((prev) => ({ ...prev, [name]: '' }))
    }
  }

  const togglePasswordVisibility = (field: 'current' | 'new' | 'confirm') => {
    setShowPasswords((prev) => ({ ...prev, [field]: !prev[field] }))
  }

  const validateForm = () => {
    try {
      changePasswordSchema.parse(formData)
      setErrors({})
      return true
    } catch (error) {
      if (error instanceof z.ZodError) {
        const newErrors: Record<string, string> = {}
        error.errors.forEach((err) => {
          if (err.path.length > 0) {
            newErrors[err.path[0] as string] = err.message
          }
        })
        setErrors(newErrors)
      }
      return false
    }
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    if (!validateForm()) {
      return
    }

    setIsLoading(true)
    setMessage('')

    try {
      const response = await fetch('/api/customer/change-password', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          currentPassword: formData.currentPassword,
          newPassword: formData.newPassword
        })
      })

      if (response.ok) {
        setMessage('Contrase√±a actualizada correctamente')
        resetForm()
      } else {
        const error = await response.json()
        setMessage(error.message || 'Error al cambiar la contrase√±a')
      }
    } catch (error) {
      setMessage('Error de conexi√≥n')
      console.error('Error changing password:', error)
    } finally {
      setIsLoading(false)
    }
  }

  const getPasswordCriteriaStatus = (criteria: string) => {
    const password = formData.newPassword
    if (!password) return false

    switch (criteria) {
      case 'length':
        return password.length >= 8
      case 'uppercase':
        return /[A-Z]/.test(password)
      case 'lowercase':
        return /[a-z]/.test(password)
      case 'number':
        return /[0-9]/.test(password)
      case 'special':
        return /[^A-Za-z0-9]/.test(password)
      default:
        return false
    }
  }

  const resetForm = () => {
    setFormData({
      currentPassword: '',
      newPassword: '',
      confirmPassword: ''
    })
    setErrors({})
    setMessage('')
  }

  return {
    // Form data
    formData,
    setFormData,

    // Password visibility
    showPasswords,
    togglePasswordVisibility,

    // Form validation
    errors,
    validateForm,

    // Form submission
    isLoading,
    message,
    handleSubmit,

    // Input handling
    handleInputChange,

    // Password criteria
    getPasswordCriteriaStatus,

    // Reset
    resetForm
  }
}



üìÅ ARCHIVO: src/components/account/ChangePassword/ChangePassword.tsx
------------------------------------------------------------------------------------
'use client'

import { useChangePassword } from '@/components/account/ChangePassword/use-change-password.hook'
import { Button } from '@/components/ui/Button'
import { Input } from '@/components/ui/Input'
import { Label } from '@/components/ui/Label'
import { Eye, EyeOff, Lock } from 'lucide-react'

export default function ChangePassword() {
  const {
    formData,
    showPasswords,
    togglePasswordVisibility,
    errors,
    isLoading,
    message,
    handleSubmit,
    handleInputChange,
    getPasswordCriteriaStatus
  } = useChangePassword()

  return (
    <div>
      <div className="mb-8 flex items-center gap-2">
        <Lock className="h-5 w-5" />
        <h2 className="text-xl font-bold">Cambiar Contrase√±a</h2>
      </div>

      <form onSubmit={handleSubmit} className="max-w-md space-y-6">
        {/* Current Password */}
        <div className="space-y-2">
          <Label htmlFor="currentPassword">Contrase√±a actual</Label>
          <div className="relative">
            <Input
              id="currentPassword"
              name="currentPassword"
              type={showPasswords.current ? 'text' : 'password'}
              value={formData.currentPassword}
              onChange={handleInputChange}
              className={`${errors.currentPassword ? 'border-red-500 focus:border-red-500 focus:ring-red-500' : 'border-gray-300 focus:border-blue-500 focus:ring-blue-500'} focus:ring-2`}
              placeholder="Ingresa tu contrase√±a actual"
            />
            <button
              type="button"
              onClick={() => { togglePasswordVisibility('current') }}
              className="absolute right-3 top-1/2 -translate-y-1/2 transform text-gray-500 hover:text-gray-700"
            >
              {showPasswords.current ? (
                <EyeOff className="h-4 w-4" />
              ) : (
                <Eye className="h-4 w-4" />
              )}
            </button>
          </div>
          {errors.currentPassword && (
            <p className="flex items-center gap-1 text-sm text-red-600">
              <span className="h-1 w-1 rounded-full bg-red-600"></span>
              {errors.currentPassword}
            </p>
          )}
        </div>

        {/* New Password */}
        <div className="space-y-2">
          <Label htmlFor="newPassword">Nueva contrase√±a</Label>
          <div className="relative">
            <Input
              id="newPassword"
              name="newPassword"
              type={showPasswords.new ? 'text' : 'password'}
              value={formData.newPassword}
              onChange={handleInputChange}
              className={`${errors.newPassword ? 'border-red-500 focus:border-red-500 focus:ring-red-500' : 'border-gray-300 focus:border-blue-500 focus:ring-blue-500'} focus:ring-2`}
              placeholder="Ingresa tu nueva contrase√±a"
            />
            <button
              type="button"
              onClick={() => { togglePasswordVisibility('new') }}
              className="absolute right-3 top-1/2 -translate-y-1/2 transform text-gray-500 hover:text-gray-700"
            >
              {showPasswords.new ? (
                <EyeOff className="h-4 w-4" />
              ) : (
                <Eye className="h-4 w-4" />
              )}
            </button>
          </div>
          {errors.newPassword && (
            <p className="flex items-center gap-1 text-sm text-red-600">
              <span className="h-1 w-1 rounded-full bg-red-600"></span>
              {errors.newPassword}
            </p>
          )}

          {/* Password Requirements */}
          <div className="mt-3 space-y-2">
            <p className="text-sm font-medium text-gray-700">
              Requisitos de la contrase√±a:
            </p>
            <div className="space-y-1">
              <div
                className={`flex items-center gap-2 text-xs ${getPasswordCriteriaStatus('length') ? 'text-green-600' : 'text-gray-500'}`}
              >
                <div
                  className={`h-1.5 w-1.5 rounded-full ${getPasswordCriteriaStatus('length') ? 'bg-green-600' : 'bg-gray-300'}`}
                ></div>
                Al menos 8 caracteres
              </div>
              <div
                className={`flex items-center gap-2 text-xs ${getPasswordCriteriaStatus('uppercase') ? 'text-green-600' : 'text-gray-500'}`}
              >
                <div
                  className={`h-1.5 w-1.5 rounded-full ${getPasswordCriteriaStatus('uppercase') ? 'bg-green-600' : 'bg-gray-300'}`}
                ></div>
                Una letra may√∫scula
              </div>
              <div
                className={`flex items-center gap-2 text-xs ${getPasswordCriteriaStatus('lowercase') ? 'text-green-600' : 'text-gray-500'}`}
              >
                <div
                  className={`h-1.5 w-1.5 rounded-full ${getPasswordCriteriaStatus('lowercase') ? 'bg-green-600' : 'bg-gray-300'}`}
                ></div>
                Una letra min√∫scula
              </div>
              <div
                className={`flex items-center gap-2 text-xs ${getPasswordCriteriaStatus('number') ? 'text-green-600' : 'text-gray-500'}`}
              >
                <div
                  className={`h-1.5 w-1.5 rounded-full ${getPasswordCriteriaStatus('number') ? 'bg-green-600' : 'bg-gray-300'}`}
                ></div>
                Un n√∫mero
              </div>
              <div
                className={`flex items-center gap-2 text-xs ${getPasswordCriteriaStatus('special') ? 'text-green-600' : 'text-gray-500'}`}
              >
                <div
                  className={`h-1.5 w-1.5 rounded-full ${getPasswordCriteriaStatus('special') ? 'bg-green-600' : 'bg-gray-300'}`}
                ></div>
                Un car√°cter especial (!@#$%^&*)
              </div>
            </div>
          </div>
        </div>

        {/* Confirm Password */}
        <div className="space-y-2">
          <Label htmlFor="confirmPassword">Confirmar nueva contrase√±a</Label>
          <div className="relative">
            <Input
              id="confirmPassword"
              name="confirmPassword"
              type={showPasswords.confirm ? 'text' : 'password'}
              value={formData.confirmPassword}
              onChange={handleInputChange}
              className={`${errors.confirmPassword ? 'border-red-500 focus:border-red-500 focus:ring-red-500' : 'border-gray-300 focus:border-blue-500 focus:ring-blue-500'} focus:ring-2`}
              placeholder="Confirma tu nueva contrase√±a"
            />
            <button
              type="button"
              onClick={() => { togglePasswordVisibility('confirm') }}
              className="absolute right-3 top-1/2 -translate-y-1/2 transform text-gray-500 hover:text-gray-700"
            >
              {showPasswords.confirm ? (
                <EyeOff className="h-4 w-4" />
              ) : (
                <Eye className="h-4 w-4" />
              )}
            </button>
          </div>
          {errors.confirmPassword && (
            <p className="flex items-center gap-1 text-sm text-red-600">
              <span className="h-1 w-1 rounded-full bg-red-600"></span>
              {errors.confirmPassword}
            </p>
          )}
          {formData.confirmPassword &&
            formData.newPassword === formData.confirmPassword && (
              <p className="flex items-center gap-1 text-sm text-green-600">
                <span className="h-1 w-1 rounded-full bg-green-600"></span>
                Las contrase√±as coinciden
              </p>
            )}
        </div>

        {/* Message */}
        {message && (
          <div
            className={`rounded-lg p-4 ${
              message.includes('Error') || message.includes('error')
                ? 'border border-red-200 bg-red-50 text-red-700'
                : 'border border-green-200 bg-green-50 text-green-700'
            }`}
          >
            <div className="flex items-center gap-2">
              <div
                className={`h-2 w-2 rounded-full ${message.includes('Error') || message.includes('error') ? 'bg-red-600' : 'bg-green-600'}`}
              ></div>
              {message}
            </div>
          </div>
        )}

        {/* Submit Button */}
        <Button
          type="submit"
          disabled={isLoading}
          className="w-full bg-black px-6 py-3 font-medium text-white transition-colors duration-200 hover:bg-gray-800 disabled:cursor-not-allowed disabled:opacity-50"
        >
          {isLoading ? (
            <div className="flex items-center gap-2">
              <div className="h-4 w-4 animate-spin rounded-full border-2 border-white border-t-transparent"></div>
              Cambiando Contrase√±a...
            </div>
          ) : (
            'Cambiar Contrase√±a'
          )}
        </Button>
      </form>
    </div>
  )
}



üìÅ ARCHIVO: src/components/account/ChangePassword/ChangePassword.schema.ts
------------------------------------------------------------------------------------
import z from 'zod'

export const changePasswordSchema = z
  .object({
    currentPassword: z.string().min(1, 'La contrase√±a actual es requerida'),
    newPassword: z
      .string()
      .min(8, 'La contrase√±a debe tener al menos 8 caracteres')
      .regex(
        /[A-Z]/,
        'La contrase√±a debe contener al menos una letra may√∫scula'
      )
      .regex(
        /[a-z]/,
        'La contrase√±a debe contener al menos una letra min√∫scula'
      )
      .regex(/[0-9]/, 'La contrase√±a debe contener al menos un n√∫mero')
      .regex(
        /[^A-Za-z0-9]/,
        'La contrase√±a debe contener al menos un car√°cter especial'
      ),
    confirmPassword: z.string().min(1, 'Por favor confirma tu nueva contrase√±a')
  })
  .refine((data) => data.newPassword === data.confirmPassword, {
    message: 'Las contrase√±as no coinciden',
    path: ['confirmPassword']
  })
  .refine((data) => data.currentPassword !== data.newPassword, {
    message: 'La nueva contrase√±a debe ser diferente a la actual',
    path: ['newPassword']
  })

export type ChangePasswordFormData = z.infer<typeof changePasswordSchema>



üìÅ ARCHIVO: src/components/account/ChangePassword/index.ts
------------------------------------------------------------------------------------
export { default } from './ChangePassword'



üìÅ ARCHIVO: src/components/account/Addresses/Addresses.schema.ts
------------------------------------------------------------------------------------
import z from 'zod'

export const addressSchema = z.object({
  alias: z
    .string()
    .min(1, 'El nombre de la direcci√≥n es requerido')
    .min(2, 'El nombre debe tener al menos 2 caracteres')
    .max(50, 'El nombre no puede exceder 50 caracteres'),
  department: z.string().min(1, 'El departamento es requerido'),
  province: z.string().min(1, 'La provincia es requerida'),
  district: z.string().min(1, 'El distrito es requerido'),
  streetName: z
    .string()
    .min(1, 'El nombre de la calle es requerido')
    .min(3, 'El nombre de la calle debe tener al menos 3 caracteres')
    .max(100, 'El nombre de la calle no puede exceder 100 caracteres'),
  streetNumber: z
    .string()
    .min(1, 'El n√∫mero de la calle es requerido')
    .max(10, 'El n√∫mero no puede exceder 10 caracteres'),
  apartment: z
    .string()
    .max(20, 'El apartamento no puede exceder 20 caracteres')
    .optional(),
  latitude: z
    .number()
    .min(-90, 'Latitud inv√°lida')
    .max(90, 'Latitud inv√°lida')
    .optional(),
  longitude: z
    .number()
    .min(-180, 'Longitud inv√°lida')
    .max(180, 'Longitud inv√°lida')
    .optional()
})

export type AddressFormData = z.infer<typeof addressSchema>



üìÅ ARCHIVO: src/components/account/Addresses/Addresses.data.ts
------------------------------------------------------------------------------------
export const departments = [
  'LIMA',
  'AREQUIPA',
  'CUSCO',
  'LA LIBERTAD',
  'PIURA',
  'LAMBAYEQUE',
  'ANCASH',
  'JUN√çN',
  'ICA',
  'CAJAMARCA',
  'HU√ÅNUCO',
  'LORETO'
]

export const districtsByProvince = {
  LIMA: [
    'LIMA',
    'BARRANCO',
    'BRE√ëA',
    'CHORRILLOS',
    'EL AGUSTINO',
    'JES√öS MAR√çA',
    'LA MOLINA',
    'LA VICTORIA',
    'LINCE',
    'MAGDALENA DEL MAR',
    'MIRAFLORES',
    'PUEBLO LIBRE',
    'R√çMAC',
    'SAN BORJA',
    'SAN ISIDRO',
    'SAN LUIS',
    'SAN MIGUEL',
    'SANTA ANITA',
    'SANTIAGO DE SURCO',
    'SURQUILLO',
    'CIENEGUILLA',
    'CHACLACAYO',
    'ATE',
    'CARABAYLLO',
    'COMAS',
    'INDEPENDENCIA',
    'LOS OLIVOS',
    'PUENTE PIEDRA',
    'SAN JUAN DE LURIGANCHO',
    'SAN JUAN DE MIRAFLORES',
    'SAN MART√çN DE PORRES',
    'VILLA EL SALVADOR',
    'VILLA MAR√çA DEL TRIUNFO'
  ]
}



üìÅ ARCHIVO: src/components/account/Addresses/index.ts
------------------------------------------------------------------------------------
export { default } from './Addresses'



üìÅ ARCHIVO: src/components/account/Addresses/use-addresses.hook.ts
------------------------------------------------------------------------------------
import { districtsByProvince } from '@/components/account/Addresses/Addresses.data'
import {
  addressSchema,
  type AddressFormData
} from '@/components/account/Addresses/Addresses.schema'
import { type CustomersAddresses } from '@/types/domain'
import { useState } from 'react'
import { z } from 'zod'

interface UseAddressesProps {
  initialAddresses: CustomersAddresses[]
}

interface UseAddressesReturn {
  // Addresses data
  addresses: CustomersAddresses[]
  setAddresses: React.Dispatch<React.SetStateAction<CustomersAddresses[]>>
  isLoading: boolean

  // Modal state
  isModalOpen: boolean
  editingAddress: CustomersAddresses | null
  openNewAddressModal: () => void
  closeModal: () => void

  // Form data
  formData: AddressFormData
  setFormData: React.Dispatch<React.SetStateAction<AddressFormData>>

  // Form validation
  errors: Record<string, string>
  validateForm: () => boolean

  // Form submission
  isSubmitting: boolean
  message: string
  handleSubmit: (e: React.FormEvent) => Promise<void>

  // Input handling
  handleInputChange: (
    e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
  ) => void

  // Address operations
  handleEdit: (address: CustomersAddresses) => void
  handleDelete: (id: number) => Promise<void>
  handleSetDefault: (id: number) => Promise<void>

  // Helpers
  availableDistricts: string[]
  resetForm: () => void
  loadAddresses: () => Promise<void>
}

export const useAddresses = ({
  initialAddresses
}: UseAddressesProps): UseAddressesReturn => {
  // Usar directamente las direcciones iniciales del server
  const [addresses, setAddresses] =
    useState<CustomersAddresses[]>(initialAddresses)
  const [isLoading, setIsLoading] = useState(false)
  const [isModalOpen, setIsModalOpen] = useState(false)
  const [editingAddress, setEditingAddress] =
    useState<CustomersAddresses | null>(null)
  const [formData, setFormData] = useState<AddressFormData>({
    alias: '',
    department: 'LIMA',
    province: 'LIMA',
    district: '',
    streetName: '',
    streetNumber: '',
    apartment: '',
    latitude: undefined,
    longitude: undefined
  })
  const [message, setMessage] = useState('')
  const [errors, setErrors] = useState<Record<string, string>>({})
  const [isSubmitting, setIsSubmitting] = useState(false)

  // ‚ùå ELIMINADO: useEffect que hac√≠a fetch innecesario
  // Solo usar las direcciones que vienen del server como props

  const loadAddresses = async () => {
    setIsLoading(true)
    try {
      const response = await fetch('/api/customer/addresses')
      if (response.ok) {
        const data = await response.json()
        setAddresses(data.addresses || [])
      } else {
        console.error('Error loading addresses: Response not ok')
        setMessage('Error al cargar las direcciones')
      }
    } catch (error) {
      console.error('Error loading addresses:', error)
      setMessage('Error al cargar las direcciones')
    } finally {
      setIsLoading(false)
    }
  }

  const handleInputChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
  ) => {
    const { name, value } = e.target

    // Formatear valor seg√∫n el campo
    let formattedValue = value

    if (name === 'streetNumber') {
      // Permitir solo n√∫meros y letras b√°sicas para n√∫meros de casa
      formattedValue = value.replace(/[^a-zA-Z0-9-]/g, '')
    }

    if (name === 'alias') {
      // Limpiar caracteres especiales del alias
      formattedValue = value.replace(/[^a-zA-Z√°√©√≠√≥√∫√Å√â√ç√ì√ö√±√ë\s]/g, '')
    }

    setFormData((prev) => ({
      ...prev,
      [name]:
        name === 'latitude' || name === 'longitude'
          ? value
            ? parseFloat(value)
            : undefined
          : formattedValue
    }))

    // Limpiar error del campo actual
    if (errors[name]) {
      setErrors((prev) => ({ ...prev, [name]: '' }))
    }

    // Resetear distrito cuando cambia departamento o provincia
    if (name === 'department' || name === 'province') {
      setFormData((prev) => ({ ...prev, district: '' }))
    }
  }

  const validateForm = () => {
    try {
      addressSchema.parse(formData)
      setErrors({})
      return true
    } catch (error) {
      if (error instanceof z.ZodError) {
        const newErrors: Record<string, string> = {}
        error.errors.forEach((err) => {
          if (err.path.length > 0) {
            newErrors[err.path[0] as string] = err.message
          }
        })
        setErrors(newErrors)
      }
      return false
    }
  }

  const resetForm = () => {
    setFormData({
      alias: '',
      department: 'LIMA',
      province: 'LIMA',
      district: '',
      streetName: '',
      streetNumber: '',
      apartment: '',
      latitude: undefined,
      longitude: undefined
    })
    setErrors({})
    setMessage('')
  }

  const closeModal = () => {
    setIsModalOpen(false)
    setEditingAddress(null)
    resetForm()
  }

  const openNewAddressModal = () => {
    setEditingAddress(null)
    resetForm()
    setIsModalOpen(true)
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    if (!validateForm()) {
      return
    }

    setIsSubmitting(true)
    setMessage('')

    try {
      const method = editingAddress ? 'PUT' : 'POST'
      const body = editingAddress
        ? { ...formData, id: editingAddress.id }
        : formData

      const response = await fetch('/api/customer/addresses', {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      })

      if (response.ok) {
        // ‚úÖ Solo hacer fetch despu√©s de crear/actualizar
        await loadAddresses()
        setMessage(
          editingAddress
            ? 'Direcci√≥n actualizada correctamente'
            : 'Direcci√≥n agregada correctamente'
        )
        closeModal()

        // Limpiar mensaje despu√©s de 3 segundos
        setTimeout(() => { setMessage('') }, 3000)
      } else {
        const error = await response.json()
        setMessage(error.error || 'Error al guardar la direcci√≥n')
      }
    } catch (error) {
      setMessage('Error de conexi√≥n')
      console.error('Error saving address:', error)
    } finally {
      setIsSubmitting(false)
    }
  }

  const handleEdit = (address: CustomersAddresses) => {
    setEditingAddress(address)
    setFormData({
      alias: address.alias,
      department: address.department,
      province: address.province,
      district: address.district,
      streetName: address.streetName,
      streetNumber: address.streetNumber,
      apartment: address.apartment || '',
      latitude: address.latitude ? Number(address.latitude) : undefined,
      longitude: address.longitude ? Number(address.longitude) : undefined
    })
    setIsModalOpen(true)
  }

  const handleDelete = async (id: number) => {
    const confirmDelete = window.confirm(
      '¬øEst√°s seguro de que quieres eliminar esta direcci√≥n? Esta acci√≥n no se puede deshacer.'
    )

    if (!confirmDelete) return

    try {
      const response = await fetch(`/api/customer/addresses?id=${id}`, {
        method: 'DELETE'
      })

      if (response.ok) {
        // ‚úÖ Solo hacer fetch despu√©s de eliminar
        await loadAddresses()
        setMessage('Direcci√≥n eliminada correctamente')
        setTimeout(() => { setMessage('') }, 3000)
      } else {
        const errorData = await response.json()
        setMessage(errorData.error || 'Error al eliminar la direcci√≥n')
      }
    } catch (error) {
      setMessage('Error de conexi√≥n')
      console.error('Error deleting address:', error)
    }
  }

  const handleSetDefault = async (id: number) => {
    try {
      const response = await fetch('/api/customer/addresses', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ addressId: id })
      })

      if (response.ok) {
        // ‚úÖ Solo hacer fetch despu√©s de cambiar direcci√≥n por defecto
        await loadAddresses()
        setMessage('Direcci√≥n por defecto actualizada')
        setTimeout(() => { setMessage('') }, 3000)
      } else {
        const errorData = await response.json()
        setMessage(
          errorData.error || 'Error al actualizar la direcci√≥n por defecto'
        )
      }
    } catch (error) {
      setMessage('Error de conexi√≥n')
      console.error('Error setting default address:', error)
    }
  }

  const availableDistricts =
    districtsByProvince[
      formData.province as keyof typeof districtsByProvince
    ] || []

  return {
    // Addresses data
    addresses,
    setAddresses,
    isLoading,

    // Modal state
    isModalOpen,
    editingAddress,
    openNewAddressModal,
    closeModal,

    // Form data
    formData,
    setFormData,

    // Form validation
    errors,
    validateForm,

    // Form submission
    isSubmitting,
    message,
    handleSubmit,

    // Input handling
    handleInputChange,

    // Address operations
    handleEdit,
    handleDelete,
    handleSetDefault,

    // Helpers
    availableDistricts,
    resetForm,
    loadAddresses
  }
}



üìÅ ARCHIVO: src/components/account/Addresses/Addresses.tsx
------------------------------------------------------------------------------------
'use client'

import { departments } from '@/components/account/Addresses/Addresses.data'
import { Button } from '@/components/ui/Button'
import { Input } from '@/components/ui/Input'
import { Label } from '@/components/ui/Label'
import { Modal } from '@/components/ui/Modal'
import { ModalContent } from '@/components/ui/Modal/ModalContent'
import { ModalTitle } from '@/components/ui/Modal/ModalTitle'
import { type CustomersAddresses } from '@/types/domain'
import { Home, MapPin, MapPinHouse } from 'lucide-react'
import { useAddresses } from './use-addresses.hook'

interface AddressesProps {
  initialAddresses: CustomersAddresses[]
}

export default function Addresses({ initialAddresses }: AddressesProps) {
  const {
    addresses,
    isLoading,
    isModalOpen,
    editingAddress,
    openNewAddressModal,
    closeModal,
    formData,
    errors,
    isSubmitting,
    message,
    handleSubmit,
    handleInputChange,
    handleEdit,
    handleDelete,
    handleSetDefault,
    availableDistricts
  } = useAddresses({ initialAddresses })

  if (isLoading) {
    return (
      <div>
        <div className="mb-8 flex items-center justify-between">
          <h2 className="text-xl font-bold">Direcciones</h2>
          <div className="h-8 w-32 animate-pulse rounded bg-gray-200"></div>
        </div>
        <div className="space-y-4">
          {[1, 2].map((i) => (
            <div
              key={i}
              className="h-32 animate-pulse rounded bg-gray-200"
            ></div>
          ))}
        </div>
      </div>
    )
  }

  return (
    <div>
      {addresses.length > 0 && (
        <div className="mb-8 flex items-center justify-between">
          <div className="mb-8 flex items-center gap-2">
            <MapPinHouse className="h-5 w-5" />
            <h2 className="text-xl font-bold">Direcciones</h2>
          </div>{' '}
          <Button
            onClick={openNewAddressModal}
            className="border border-gray-300 bg-white px-6 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
          >
            AGREGAR DIRECCI√ìN
          </Button>
        </div>
      )}

      {/* Mensaje global */}
      {message && !isModalOpen && (
        <div
          className={`mb-6 rounded-lg p-4 text-sm ${
            message.includes('Error')
              ? 'border border-red-200 bg-red-50 text-red-700'
              : 'border border-green-200 bg-green-50 text-green-700'
          }`}
        >
          <div className="flex items-center gap-2">
            <div
              className={`h-2 w-2 rounded-full ${message.includes('Error') ? 'bg-red-600' : 'bg-green-600'}`}
            ></div>
            {message}
          </div>
        </div>
      )}

      {/* Lista de direcciones */}
      {addresses.length === 0 ? (
        <div className="py-16 text-center">
          <div className="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-gray-100">
            <MapPin className="h-8 w-8 text-gray-400" />
          </div>
          <h3 className="mb-2 text-lg font-semibold text-gray-900">
            No tienes direcciones guardadas
          </h3>
          <p className="mx-auto mb-6 max-w-sm text-gray-600">
            Agrega tu primera direcci√≥n para realizar pedidos m√°s r√°pido y
            f√°cil.
          </p>
          <Button
            onClick={openNewAddressModal}
            className="border border-gray-300 bg-white px-6 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
          >
            AGREGAR TU PRIMERA DIRECCI√ìN
          </Button>
        </div>
      ) : (
        <div className="space-y-6">
          {addresses.map((address) => (
            <div
              key={address.id}
              className="flex items-center gap-6 border-b border-gray-200 py-6 last:border-b-0"
            >
              {/* Icono de direcci√≥n */}
              <div className="flex h-20 w-20 flex-shrink-0 items-center justify-center bg-gray-100">
                <Home className="h-8 w-8 text-gray-600" />
              </div>

              {/* Informaci√≥n de la direcci√≥n */}
              <div className="min-w-0 flex-1">
                <div className="mb-2 flex items-center gap-2">
                  <h3 className="font-semibold text-gray-900">
                    {address.alias}
                  </h3>
                  {Boolean(address.isDefault) && (
                    <span className="rounded-full bg-green-100 px-2 py-1 text-xs font-medium text-green-700">
                      Por defecto
                    </span>
                  )}
                </div>

                <div className="space-y-1 text-sm text-gray-600">
                  <p className="font-medium text-gray-900">
                    {address.streetName} {address.streetNumber}
                    {address.apartment && `, ${address.apartment}`}
                  </p>
                  <p>
                    {address.district}, {address.province}
                  </p>
                  <p>{address.department}, Per√∫</p>
                </div>
              </div>

              {/* Estado y acciones */}
              <div className="flex flex-col items-end gap-2">
                <div className="flex items-center gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => { handleEdit(address) }}
                    className="border-gray-300 px-4 py-2 text-sm text-gray-700 hover:bg-gray-50"
                  >
                    EDITAR
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={async () => { await handleDelete(address.id) }}
                    className="border-gray-300 px-4 py-2 text-sm text-red-600 hover:border-red-300 hover:bg-red-50"
                  >
                    ELIMINAR
                  </Button>
                </div>

                {!address.isDefault && (
                  <button
                    onClick={async () => { await handleSetDefault(address.id) }}
                    className="text-sm text-blue-600 underline hover:text-blue-800"
                  >
                    Establecer como predeterminada
                  </button>
                )}
              </div>
            </div>
          ))}
        </div>
      )}

      {/* Modal */}
      <Modal
        isOpen={isModalOpen}
        onClose={closeModal}
        className="h-full max-w-2xl overflow-y-auto"
      >
        <ModalTitle
          onClose={closeModal}
          title={`${editingAddress ? 'Editar' : 'Agregar'} direcci√≥n`}
        />
        <ModalContent>
          <form onSubmit={handleSubmit} className="space-y-6">
            <div className="space-y-4">
              {/* Nombre de la direcci√≥n */}
              <div className="space-y-2">
                <Label
                  htmlFor="alias"
                  className="text-sm font-medium text-gray-700"
                >
                  Nombre de la direcci√≥n
                </Label>
                <Input
                  id="alias"
                  name="alias"
                  value={formData.alias}
                  onChange={handleInputChange}
                  placeholder="ej. Casa, Oficina, Casa de mam√°"
                  className={`${errors.alias ? 'border-red-500 focus:border-red-500 focus:ring-red-500' : 'border-gray-300 focus:border-blue-500 focus:ring-blue-500'} focus:ring-2`}
                />
                {errors.alias && (
                  <p className="flex items-center gap-1 text-sm text-red-600">
                    <span className="h-1 w-1 rounded-full bg-red-600"></span>
                    {errors.alias}
                  </p>
                )}
              </div>

              {/* Departamento y Provincia */}
              <div className="grid grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label
                    htmlFor="department"
                    className="text-sm font-medium text-gray-700"
                  >
                    Departamento
                  </Label>
                  <select
                    id="department"
                    name="department"
                    value={formData.department}
                    onChange={handleInputChange}
                    className="w-full rounded-lg border border-gray-300 px-3 py-2 focus:border-blue-500 focus:ring-2 focus:ring-blue-500"
                  >
                    {departments.map((dept) => (
                      <option key={dept} value={dept}>
                        {dept}
                      </option>
                    ))}
                  </select>
                  {errors.department && (
                    <p className="flex items-center gap-1 text-sm text-red-600">
                      <span className="h-1 w-1 rounded-full bg-red-600"></span>
                      {errors.department}
                    </p>
                  )}
                </div>

                <div className="space-y-2">
                  <Label
                    htmlFor="province"
                    className="text-sm font-medium text-gray-700"
                  >
                    Provincia
                  </Label>
                  <select
                    id="province"
                    name="province"
                    value={formData.province}
                    onChange={handleInputChange}
                    className="w-full rounded-lg border border-gray-300 px-3 py-2 focus:border-blue-500 focus:ring-2 focus:ring-blue-500"
                  >
                    <option value="LIMA">LIMA</option>
                  </select>
                  {errors.province && (
                    <p className="flex items-center gap-1 text-sm text-red-600">
                      <span className="h-1 w-1 rounded-full bg-red-600"></span>
                      {errors.province}
                    </p>
                  )}
                </div>
              </div>

              {/* Distrito */}
              <div className="space-y-2">
                <Label
                  htmlFor="district"
                  className="text-sm font-medium text-gray-700"
                >
                  Distrito
                </Label>
                <select
                  id="district"
                  name="district"
                  value={formData.district}
                  onChange={handleInputChange}
                  className={`w-full rounded-lg border px-3 py-2 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 ${errors.district ? 'border-red-500' : 'border-gray-300'}`}
                >
                  <option value="">Selecciona un distrito</option>
                  {availableDistricts.map((district) => (
                    <option key={district} value={district}>
                      {district}
                    </option>
                  ))}
                </select>
                {errors.district && (
                  <p className="flex items-center gap-1 text-sm text-red-600">
                    <span className="h-1 w-1 rounded-full bg-red-600"></span>
                    {errors.district}
                  </p>
                )}
              </div>

              {/* Avenida/Calle y N√∫mero */}
              <div className="grid grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label
                    htmlFor="streetName"
                    className="text-sm font-medium text-gray-700"
                  >
                    Nombre de la calle
                  </Label>
                  <Input
                    id="streetName"
                    name="streetName"
                    value={formData.streetName}
                    onChange={handleInputChange}
                    placeholder="Av. Javier Prado, Jr. Lima, etc."
                    className={`${errors.streetName ? 'border-red-500 focus:border-red-500 focus:ring-red-500' : 'border-gray-300 focus:border-blue-500 focus:ring-blue-500'} focus:ring-2`}
                  />
                  {errors.streetName && (
                    <p className="flex items-center gap-1 text-sm text-red-600">
                      <span className="h-1 w-1 rounded-full bg-red-600"></span>
                      {errors.streetName}
                    </p>
                  )}
                </div>

                <div className="space-y-2">
                  <Label
                    htmlFor="streetNumber"
                    className="text-sm font-medium text-gray-700"
                  >
                    N√∫mero
                  </Label>
                  <Input
                    id="streetNumber"
                    name="streetNumber"
                    value={formData.streetNumber}
                    onChange={handleInputChange}
                    placeholder="123, 45-A, etc."
                    className={`${errors.streetNumber ? 'border-red-500 focus:border-red-500 focus:ring-red-500' : 'border-gray-300 focus:border-blue-500 focus:ring-blue-500'} focus:ring-2`}
                  />
                  {errors.streetNumber && (
                    <p className="flex items-center gap-1 text-sm text-red-600">
                      <span className="h-1 w-1 rounded-full bg-red-600"></span>
                      {errors.streetNumber}
                    </p>
                  )}
                </div>
              </div>

              {/* Apartamento (opcional) */}
              <div className="space-y-2">
                <Label
                  htmlFor="apartment"
                  className="text-sm font-medium text-gray-700"
                >
                  Apartamento / Unidad / Piso (opcional)
                </Label>
                <Input
                  id="apartment"
                  name="apartment"
                  value={formData.apartment}
                  onChange={handleInputChange}
                  placeholder="ej. Apt 3, Dpto 101, Piso 2"
                  className="border-gray-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-500"
                />
              </div>
            </div>

            {/* Mensaje en modal */}
            {message && isModalOpen && (
              <div
                className={`rounded-lg p-3 text-sm ${
                  message.includes('Error')
                    ? 'border border-red-200 bg-red-50 text-red-700'
                    : 'border border-green-200 bg-green-50 text-green-700'
                }`}
              >
                <div className="flex items-center gap-2">
                  <div
                    className={`h-2 w-2 rounded-full ${message.includes('Error') ? 'bg-red-600' : 'bg-green-600'}`}
                  ></div>
                  {message}
                </div>
              </div>
            )}

            {/* Botones */}
            <div className="flex justify-end gap-3 border-t border-gray-200 pt-6">
              <Button
                type="button"
                variant="outline"
                onClick={closeModal}
                disabled={isSubmitting}
                className="border-gray-300 px-6 py-2 text-gray-700 hover:bg-gray-50"
              >
                CANCELAR
              </Button>
              <Button
                type="submit"
                disabled={isSubmitting}
                className="min-w-[120px] rounded-lg bg-black px-6 py-2 font-medium text-white hover:bg-gray-800"
              >
                {isSubmitting ? (
                  <div className="flex items-center gap-2">
                    <div className="h-4 w-4 animate-spin rounded-full border-2 border-white border-t-transparent"></div>
                    GUARDANDO...
                  </div>
                ) : (
                  `${editingAddress ? 'ACTUALIZAR' : 'AGREGAR'} DIRECCI√ìN`
                )}
              </Button>
            </div>
          </form>
        </ModalContent>
      </Modal>
    </div>
  )
}



üìÅ ARCHIVO: src/components/account/OrderDetail/OrderDetail.tsx
------------------------------------------------------------------------------------
'use client'

import { Button } from '@/components/ui/Button'
import { Input } from '@/components/ui/Input'
import { Label } from '@/components/ui/Label'
import { Modal } from '@/components/ui/Modal'
import { ModalContent } from '@/components/ui/Modal/ModalContent'
import { ModalTitle } from '@/components/ui/Modal/ModalTitle'
import {
  AlertCircle,
  Calendar,
  CheckCircle,
  Clock,
  CreditCard,
  MapPin,
  Package,
  Truck,
  X
} from 'lucide-react'
import { useEffect, useState } from 'react'

interface OrderItem {
  id: number
  productName: string
  variantSku: string
  variantAttributes: any
  quantity: number
  unitPrice: number
  totalPrice: number
  discountAmount: number
}

interface TrackingEvent {
  id: number
  status: string
  currentLocation?: string
  courierCompany?: string
  trackingNumber?: string
  deliveryNotes?: string
  createdAt: string
  shippedAt?: string
  deliveredAt?: string
  deliveredTo?: string
}

interface ShippingAddress {
  alias: string
  streetName: string
  streetNumber: string
  apartment?: string
  district: string
  province: string
  department: string
}

interface OrderDetailData {
  id: number
  orderNumber: string
  status: string
  paymentStatus: string
  paymentMethod: string
  createdAt: string
  paidAt?: string
  estimatedDelivery?: string
  subtotal: number
  discountAmount: number
  shippingCost: number
  taxAmount: number
  totalAmount: number
  shippingMethod?: string
  shippingAddress?: ShippingAddress
  customerNotes?: string
  adminNotes?: string
  items: OrderItem[]
  itemCount: number
  trackingHistory: TrackingEvent[]
  latestTracking?: {
    status: string
    currentLocation?: string
    courierCompany?: string
    trackingNumber?: string
    deliveryNotes?: string
    updatedAt: string
  }
  canCancel: boolean
  hasTracking: boolean
  isDelivered: boolean
  needsPayment: boolean
}

interface OrderDetailModalProps {
  isOpen: boolean
  onClose: () => void
  orderId: string | null
}

const statusLabels: Record<
  string,
  { label: string, color: string, bgColor: string, icon: any }
> = {
  pending: {
    label: 'Pendiente',
    color: 'text-yellow-700',
    bgColor: 'bg-yellow-100',
    icon: Clock
  },
  processing: {
    label: 'Procesando',
    color: 'text-blue-700',
    bgColor: 'bg-blue-100',
    icon: Package
  },
  shipped: {
    label: 'Enviado',
    color: 'text-purple-700',
    bgColor: 'bg-purple-100',
    icon: Truck
  },
  delivered: {
    label: 'Entregado',
    color: 'text-green-700',
    bgColor: 'bg-green-100',
    icon: CheckCircle
  },
  cancelled: {
    label: 'Cancelado',
    color: 'text-red-700',
    bgColor: 'bg-red-100',
    icon: X
  }
}

const paymentStatusLabels: Record<string, { label: string, color: string }> = {
  pending: { label: 'Pendiente', color: 'text-orange-600' },
  paid: { label: 'Pagado', color: 'text-green-600' },
  failed: { label: 'Fall√≥', color: 'text-red-600' },
  refunded: { label: 'Reembolsado', color: 'text-blue-600' }
}

export default function OrderDetailModal({
  isOpen,
  onClose,
  orderId
}: OrderDetailModalProps) {
  const [order, setOrder] = useState<OrderDetailData | null>(null)
  const [loading, setLoading] = useState(false)
  const [showCancelModal, setShowCancelModal] = useState(false)
  const [cancelReason, setCancelReason] = useState('')
  const [cancelling, setCancelling] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const fetchOrderDetail = async () => {
    if (!orderId) return

    try {
      setLoading(true)
      setError(null)
      const response = await fetch(`/api/customer/orders/${orderId}`)

      if (!response.ok) {
        if (response.status === 404) {
          setError('Orden no encontrada')
        } else if (response.status === 403) {
          setError('No tienes acceso a esta orden')
        } else {
          setError('Error al cargar la orden')
        }
        return
      }

      const data = await response.json()
      setOrder(data.order)
    } catch (err) {
      setError('Error de conexi√≥n')
      console.error('Error fetching order detail:', err)
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    if (isOpen && orderId) {
      fetchOrderDetail()
    } else if (!isOpen) {
      // Reset state when modal closes
      setOrder(null)
      setError(null)
      setShowCancelModal(false)
      setCancelReason('')
    }
  }, [isOpen, orderId])

  const handleCancelOrder = async () => {
    if (!cancelReason.trim() || !orderId) return

    try {
      setCancelling(true)
      const response = await fetch(`/api/customer/orders/${orderId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'cancel',
          customerNotes: cancelReason
        })
      })

      if (response.ok) {
        setShowCancelModal(false)
        setCancelReason('')
        fetchOrderDetail() // Refresh order data
      }
    } catch (error) {
      console.error('Error cancelling order:', error)
    } finally {
      setCancelling(false)
    }
  }

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('es-PE', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    })
  }

  const formatPrice = (price: number) => {
    return `S/ ${price.toFixed(2)}`
  }

  const renderVariantAttributes = (attributes: any) => {
    if (!attributes) return null

    const attrs =
      typeof attributes === 'string' ? JSON.parse(attributes) : attributes
    return Object.entries(attrs).map(([key, value]) => (
      <span
        key={key}
        className="rounded bg-gray-100 px-2 py-1 text-xs text-gray-500"
      >
        {key}: {value as string}
      </span>
    ))
  }

  const StatusIcon = order
    ? statusLabels[order.status]?.icon || Package
    : Package

  return (
    <>
      <Modal
        isOpen={isOpen}
        onClose={onClose}
        className="max-h-[90vh] max-w-6xl overflow-y-auto"
      >
        <ModalTitle
          onClose={onClose}
          title={order ? `Orden ${order.orderNumber}` : 'Cargando orden...'}
        />
        <ModalContent className="space-y-6">
          {loading && (
            <div className="space-y-4">
              <div className="h-6 w-3/4 animate-pulse rounded bg-gray-200" />
              <div className="h-32 animate-pulse rounded bg-gray-200" />
              <div className="h-48 animate-pulse rounded bg-gray-200" />
            </div>
          )}

          {error && (
            <div className="py-8 text-center">
              <AlertCircle className="mx-auto mb-4 h-12 w-12 text-red-400" />
              <h3 className="mb-2 text-lg font-medium text-gray-900">
                {error}
              </h3>
              <p className="text-gray-500">
                {error === 'Orden no encontrada'
                  ? 'La orden que buscas no existe.'
                  : 'Int√©ntalo de nuevo m√°s tarde.'}
              </p>
            </div>
          )}

          {order && !loading && !error && (
            <>
              {/* Header Info */}
              <div className="flex items-center justify-between border-b pb-4">
                <div>
                  <p className="text-sm text-gray-500">
                    Realizada el {formatDate(order.createdAt)}
                  </p>
                  <div className="mt-2 flex items-center gap-3">
                    <div
                      className={`flex items-center gap-2 rounded-full px-3 py-1 text-sm ${statusLabels[order.status]?.bgColor} ${statusLabels[order.status]?.color}`}
                    >
                      <StatusIcon className="h-4 w-4" />
                      <span className="font-medium">
                        {statusLabels[order.status]?.label}
                      </span>
                    </div>
                    <div
                      className={`text-sm font-medium ${paymentStatusLabels[order.paymentStatus]?.color}`}
                    >
                      {paymentStatusLabels[order.paymentStatus]?.label}
                    </div>
                  </div>
                </div>
                {order.canCancel && (
                  <Button
                    variant="destructive"
                    size="sm"
                    onClick={() => { setShowCancelModal(true) }}
                  >
                    Cancelar orden
                  </Button>
                )}
              </div>

              <div className="grid gap-6 lg:grid-cols-3">
                {/* Main Content */}
                <div className="space-y-6 lg:col-span-2">
                  {/* Items */}
                  <div className="rounded-lg border p-4">
                    <h3 className="mb-4 font-semibold">
                      Productos ({order.itemCount})
                    </h3>
                    <div className="space-y-4">
                      {order.items.map((item) => (
                        <div
                          key={item.id}
                          className="flex items-start gap-3 border-b pb-4 last:border-b-0 last:pb-0"
                        >
                          <div className="flex h-12 w-12 flex-shrink-0 items-center justify-center rounded bg-gray-100">
                            <Package className="h-5 w-5 text-gray-400" />
                          </div>
                          <div className="min-w-0 flex-1">
                            <h4 className="mb-1 text-sm font-medium">
                              {item.productName}
                            </h4>
                            <p className="mb-1 text-xs text-gray-500">
                              SKU: {item.variantSku}
                            </p>
                            <div className="mb-2 flex flex-wrap gap-1">
                              {renderVariantAttributes(item.variantAttributes)}
                            </div>
                            <div className="flex items-center gap-3 text-xs text-gray-600">
                              <span>Cant: {item.quantity}</span>
                              <span>Unit: {formatPrice(item.unitPrice)}</span>
                              {item.discountAmount > 0 && (
                                <span className="text-green-600">
                                  Desc: -{formatPrice(item.discountAmount)}
                                </span>
                              )}
                            </div>
                          </div>
                          <div className="text-right">
                            <div className="text-sm font-semibold">
                              {formatPrice(item.totalPrice)}
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>

                  {/* Tracking */}
                  {order.hasTracking && (
                    <div className="rounded-lg border p-4">
                      <h3 className="mb-4 font-semibold">
                        Seguimiento del env√≠o
                      </h3>

                      {order.latestTracking && (
                        <div className="mb-4 rounded-lg border border-blue-200 bg-blue-50 p-3">
                          <div className="mb-2 flex items-center gap-2">
                            <Truck className="h-4 w-4 text-blue-600" />
                            <span className="text-sm font-medium text-blue-900">
                              Estado actual
                            </span>
                          </div>
                          <p className="mb-1 text-sm text-blue-800">
                            {statusLabels[order.latestTracking.status]?.label ||
                              order.latestTracking.status}
                          </p>
                          {order.latestTracking.currentLocation && (
                            <p className="text-xs text-blue-700">
                              üìç {order.latestTracking.currentLocation}
                            </p>
                          )}
                          {order.latestTracking.trackingNumber && (
                            <p className="text-xs text-blue-700">
                              N¬∞ seguimiento:{' '}
                              {order.latestTracking.trackingNumber}
                            </p>
                          )}
                        </div>
                      )}

                      <div className="space-y-3">
                        <h4 className="text-sm font-medium">Historial</h4>
                        <div className="max-h-40 overflow-y-auto">
                          {order.trackingHistory.map((event, index) => (
                            <div
                              key={event.id}
                              className="flex gap-3 pb-3 last:pb-0"
                            >
                              <div className="flex flex-col items-center">
                                <div
                                  className={`h-2 w-2 rounded-full ${index === 0 ? 'bg-blue-600' : 'bg-gray-300'}`}
                                />
                                {index < order.trackingHistory.length - 1 && (
                                  <div className="mt-1 h-6 w-px bg-gray-200" />
                                )}
                              </div>
                              <div className="flex-1">
                                <div className="mb-1 flex items-center justify-between">
                                  <span className="text-sm font-medium">
                                    {statusLabels[event.status]?.label ||
                                      event.status}
                                  </span>
                                  <span className="text-xs text-gray-500">
                                    {formatDate(event.createdAt)}
                                  </span>
                                </div>
                                {event.currentLocation && (
                                  <p className="text-xs text-gray-600">
                                    üìç {event.currentLocation}
                                  </p>
                                )}
                                {event.deliveryNotes && (
                                  <p className="text-xs text-gray-600">
                                    {event.deliveryNotes}
                                  </p>
                                )}
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    </div>
                  )}
                </div>

                {/* Sidebar */}
                <div className="space-y-4">
                  {/* Payment Info */}
                  <div className="rounded-lg border p-4">
                    <h3 className="mb-3 text-sm font-semibold">
                      Informaci√≥n de pago
                    </h3>
                    <div className="space-y-3">
                      <div className="flex items-center gap-2">
                        <CreditCard className="h-4 w-4 text-gray-400" />
                        <div>
                          <div className="text-xs text-gray-500">M√©todo</div>
                          <div className="text-sm font-medium">
                            {order.paymentMethod}
                          </div>
                        </div>
                      </div>
                      {order.paidAt && (
                        <div className="flex items-center gap-2">
                          <Calendar className="h-4 w-4 text-gray-400" />
                          <div>
                            <div className="text-xs text-gray-500">
                              Pagado el
                            </div>
                            <div className="text-sm font-medium">
                              {formatDate(order.paidAt)}
                            </div>
                          </div>
                        </div>
                      )}
                    </div>
                  </div>

                  {/* Shipping Address */}
                  {order.shippingAddress && (
                    <div className="rounded-lg border p-4">
                      <h3 className="mb-3 text-sm font-semibold">
                        Direcci√≥n de env√≠o
                      </h3>
                      <div className="flex items-start gap-2">
                        <MapPin className="mt-1 h-4 w-4 text-gray-400" />
                        <div>
                          <div className="text-sm font-medium">
                            {order.shippingAddress.alias}
                          </div>
                          <div className="space-y-1 text-xs text-gray-600">
                            <p>
                              {order.shippingAddress.streetName}{' '}
                              {order.shippingAddress.streetNumber}
                              {order.shippingAddress.apartment &&
                                `, ${order.shippingAddress.apartment}`}
                            </p>
                            <p>
                              {order.shippingAddress.district},{' '}
                              {order.shippingAddress.province}
                            </p>
                            <p>{order.shippingAddress.department}</p>
                          </div>
                        </div>
                      </div>
                    </div>
                  )}

                  {/* Order Total */}
                  <div className="rounded-lg border p-4">
                    <h3 className="mb-3 text-sm font-semibold">Resumen</h3>
                    <div className="space-y-2 text-sm">
                      <div className="flex justify-between">
                        <span>Subtotal</span>
                        <span>{formatPrice(order.subtotal)}</span>
                      </div>
                      {order.discountAmount > 0 && (
                        <div className="flex justify-between text-green-600">
                          <span>Descuento</span>
                          <span>-{formatPrice(order.discountAmount)}</span>
                        </div>
                      )}
                      {order.shippingCost > 0 && (
                        <div className="flex justify-between">
                          <span>Env√≠o</span>
                          <span>{formatPrice(order.shippingCost)}</span>
                        </div>
                      )}
                      {order.taxAmount > 0 && (
                        <div className="flex justify-between">
                          <span>Impuestos</span>
                          <span>{formatPrice(order.taxAmount)}</span>
                        </div>
                      )}
                      <div className="border-t pt-2">
                        <div className="flex justify-between font-semibold">
                          <span>Total</span>
                          <span>{formatPrice(order.totalAmount)}</span>
                        </div>
                      </div>
                    </div>
                  </div>

                  {/* Delivery Info */}
                  {order.estimatedDelivery && (
                    <div className="rounded-lg border p-4">
                      <h3 className="mb-3 text-sm font-semibold">Entrega</h3>
                      <div className="space-y-2">
                        {order.shippingMethod && (
                          <div className="flex items-center gap-2">
                            <Truck className="h-4 w-4 text-gray-400" />
                            <div>
                              <div className="text-xs text-gray-500">
                                M√©todo
                              </div>
                              <div className="text-sm font-medium">
                                {order.shippingMethod}
                              </div>
                            </div>
                          </div>
                        )}
                        <div className="flex items-center gap-2">
                          <Calendar className="h-4 w-4 text-gray-400" />
                          <div>
                            <div className="text-xs text-gray-500">
                              Estimada
                            </div>
                            <div className="text-sm font-medium">
                              {formatDate(order.estimatedDelivery)}
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  )}

                  {/* Notes */}
                  {(order.customerNotes || order.adminNotes) && (
                    <div className="rounded-lg border p-4">
                      <h3 className="mb-3 text-sm font-semibold">Notas</h3>
                      <div className="space-y-3">
                        {order.customerNotes && (
                          <div>
                            <div className="mb-1 text-xs text-gray-500">
                              Tus notas
                            </div>
                            <div className="rounded bg-gray-50 p-2 text-xs">
                              {order.customerNotes}
                            </div>
                          </div>
                        )}
                        {order.adminNotes && (
                          <div>
                            <div className="mb-1 text-xs text-gray-500">
                              Notas del vendedor
                            </div>
                            <div className="rounded bg-blue-50 p-2 text-xs">
                              {order.adminNotes}
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </>
          )}
        </ModalContent>
      </Modal>

      {/* Cancel Order Modal */}
      {showCancelModal && (
        <Modal
          isOpen={showCancelModal}
          onClose={() => { setShowCancelModal(false) }}
          className="max-w-md"
        >
          <ModalTitle
            onClose={() => { setShowCancelModal(false) }}
            title="Cancelar orden"
          />
          <ModalContent>
            <div className="space-y-4">
              <p className="text-sm text-gray-600">
                ¬øEst√°s seguro de que deseas cancelar esta orden? Esta acci√≥n no
                se puede deshacer.
              </p>

              <div className="space-y-2">
                <Label htmlFor="cancelReason" className="text-sm">
                  Motivo de cancelaci√≥n
                </Label>
                <Input
                  id="cancelReason"
                  value={cancelReason}
                  onChange={(e) => { setCancelReason(e.target.value) }}
                  placeholder="Explica por qu√© deseas cancelar..."
                  className="text-sm"
                />
              </div>

              <div className="flex gap-3 pt-4">
                <Button
                  variant="outline"
                  onClick={() => { setShowCancelModal(false) }}
                  disabled={cancelling}
                  className="flex-1 text-sm"
                >
                  Mantener orden
                </Button>
                <Button
                  variant="destructive"
                  onClick={handleCancelOrder}
                  disabled={!cancelReason.trim() || cancelling}
                  className="flex-1 text-sm"
                >
                  {cancelling ? (
                    <div className="flex items-center gap-2">
                      <div className="h-3 w-3 animate-spin rounded-full border-2 border-white border-t-transparent"></div>
                      Cancelando...
                    </div>
                  ) : (
                    'Cancelar orden'
                  )}
                </Button>
              </div>
            </div>
          </ModalContent>
        </Modal>
      )}
    </>
  )
}



üìÅ ARCHIVO: src/components/account/OrderDetail/index.ts
------------------------------------------------------------------------------------
export { default } from './OrderDetail'



üìÅ ARCHIVO: src/components/account/OrderList/index.ts
------------------------------------------------------------------------------------
export { default } from './OrdersList'



üìÅ ARCHIVO: src/components/account/OrderList/OrdersList.tsx
------------------------------------------------------------------------------------
'use client'

import OrderDetailModal from '@/components/account/OrderDetail'
import { Button } from '@/components/ui/Button'
import { Input } from '@/components/ui/Input'
import {
  Calendar,
  ChevronLeft,
  ChevronRight,
  CreditCard,
  Eye,
  Filter,
  Package,
  Search,
  Truck
} from 'lucide-react'
import Link from 'next/link'
import { useEffect, useState } from 'react'

interface Order {
  id: number
  orderNumber: string
  status: string
  paymentStatus: string
  totalAmount: number
  createdAt: string
  estimatedDelivery?: string
  itemCount: number
  shippingMethod?: string
  trackingAvailable: boolean
}

interface OrdersResponse {
  orders: Order[]
  pagination: {
    total: number
    page: number
    limit: number
    totalPages: number
  }
}

const statusLabels: Record<
  string,
  { label: string, color: string, bgColor: string }
> = {
  pending: {
    label: 'Pendiente',
    color: 'text-yellow-700',
    bgColor: 'bg-yellow-100'
  },
  processing: {
    label: 'Procesando',
    color: 'text-blue-700',
    bgColor: 'bg-blue-100'
  },
  shipped: {
    label: 'Enviado',
    color: 'text-purple-700',
    bgColor: 'bg-purple-100'
  },
  delivered: {
    label: 'Entregado',
    color: 'text-green-700',
    bgColor: 'bg-green-100'
  },
  cancelled: {
    label: 'Cancelado',
    color: 'text-red-700',
    bgColor: 'bg-red-100'
  }
}

const paymentStatusLabels: Record<string, { label: string, color: string }> = {
  pending: { label: 'Pendiente', color: 'text-orange-600' },
  paid: { label: 'Pagado', color: 'text-green-600' },
  failed: { label: 'Fall√≥', color: 'text-red-600' },
  refunded: { label: 'Reembolsado', color: 'text-blue-600' }
}

export default function OrdersList() {
  const [orders, setOrders] = useState<Order[]>([])
  const [pagination, setPagination] = useState({
    total: 0,
    page: 1,
    limit: 10,
    totalPages: 0
  })
  const [loading, setLoading] = useState(true)
  const [searchTerm, setSearchTerm] = useState('')
  const [statusFilter, setStatusFilter] = useState('')
  const [currentPage, setCurrentPage] = useState(1)

  // Modal state
  const [isModalOpen, setIsModalOpen] = useState(false)
  const [selectedOrderId, setSelectedOrderId] = useState<string | null>(null)

  const fetchOrders = async (page: number = 1, status: string = '') => {
    try {
      setLoading(true)
      const params = new URLSearchParams({
        page: page.toString(),
        limit: '10'
      })

      if (status) {
        params.append('status', status)
      }

      const response = await fetch(`/api/customer/orders?${params}`)
      if (response.ok) {
        const data: OrdersResponse = await response.json()
        setOrders(data.orders)
        setPagination(data.pagination)
      }
    } catch (error) {
      console.error('Error fetching orders:', error)
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchOrders(currentPage, statusFilter)
  }, [currentPage, statusFilter])

  const handlePageChange = (page: number) => {
    setCurrentPage(page)
  }

  const handleStatusFilter = (status: string) => {
    setStatusFilter(status)
    setCurrentPage(1)
  }

  const handleViewOrder = (orderId: number) => {
    setSelectedOrderId(orderId.toString())
    setIsModalOpen(true)
  }

  const handleCloseModal = () => {
    setIsModalOpen(false)
    setSelectedOrderId(null)
  }

  const filteredOrders = orders.filter((order) =>
    order.orderNumber.toLowerCase().includes(searchTerm.toLowerCase())
  )

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('es-PE', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    })
  }

  const formatPrice = (price: number) => {
    return `S/ ${price.toFixed(2)}`
  }

  if (loading) {
    return (
      <div className="space-y-6">
        <div className="mb-8 flex items-center gap-2">
          <Package className="h-5 w-5" />
          <h2 className="text-xl font-bold">Mis compras</h2>
        </div>
        <div className="space-y-4">
          {[...Array(5)].map((_, i) => (
            <div key={i} className="animate-pulse rounded-lg border p-6">
              <div className="mb-4 h-4 w-1/4 rounded bg-gray-200"></div>
              <div className="mb-2 h-4 w-1/2 rounded bg-gray-200"></div>
              <div className="h-4 w-1/3 rounded bg-gray-200"></div>
            </div>
          ))}
        </div>
      </div>
    )
  }

  return (
    <>
      <div className="space-y-6">
        {/* Header */}
        <div className="mb-8 flex items-center gap-2">
          <Package className="h-5 w-5" />
          <h2 className="text-xl font-bold">Mis compras</h2>
        </div>

        {/* Filters */}
        <div className="mb-6 flex flex-col gap-4 md:flex-row">
          <div className="relative flex-1">
            <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 transform text-gray-400" />
            <Input
              type="text"
              placeholder="Buscar por n√∫mero de orden..."
              value={searchTerm}
              onChange={(e) => { setSearchTerm(e.target.value) }}
              className="pl-10"
            />
          </div>

          <div className="flex items-center gap-2">
            <Filter className="h-4 w-4 text-gray-500" />
            <select
              value={statusFilter}
              onChange={(e) => { handleStatusFilter(e.target.value) }}
              className="rounded-lg border border-gray-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              <option value="">Todos los estados</option>
              <option value="pending">Pendiente</option>
              <option value="processing">Procesando</option>
              <option value="shipped">Enviado</option>
              <option value="delivered">Entregado</option>
              <option value="cancelled">Cancelado</option>
            </select>
          </div>
        </div>

        {/* Orders List */}
        {filteredOrders.length === 0 ? (
          <div className="py-12 text-center">
            <Package className="mx-auto mb-4 h-16 w-16 text-gray-300" />
            <h3 className="mb-2 text-lg font-medium text-gray-900">
              No tienes √≥rdenes a√∫n
            </h3>
            <p className="mb-6 text-gray-500">
              Cuando realices tu primera compra, aparecer√° aqu√≠.
            </p>
            <Button asChild>
              <Link href="/products">Explorar productos</Link>
            </Button>
          </div>
        ) : (
          <div className="space-y-4">
            {filteredOrders.map((order) => (
              <div
                key={order.id}
                className="rounded-lg border p-6 transition-shadow hover:shadow-md"
              >
                <div className="mb-4 flex items-start justify-between">
                  <div>
                    <h3 className="mb-1 text-lg font-semibold">
                      Orden {order.orderNumber}
                    </h3>
                    <div className="flex items-center gap-4 text-sm text-gray-600">
                      <span className="flex items-center gap-1">
                        <Calendar className="h-4 w-4" />
                        {formatDate(order.createdAt)}
                      </span>
                      <span>
                        {order.itemCount}{' '}
                        {order.itemCount === 1 ? 'producto' : 'productos'}
                      </span>
                    </div>
                  </div>

                  <div className="text-right">
                    <div className="mb-2 text-xl font-bold text-gray-900">
                      {formatPrice(order.totalAmount)}
                    </div>
                    <div className="flex items-center gap-2">
                      <span
                        className={`rounded-full px-2 py-1 text-xs font-medium ${statusLabels[order.status]?.color} ${statusLabels[order.status]?.bgColor}`}
                      >
                        {statusLabels[order.status]?.label || order.status}
                      </span>
                    </div>
                  </div>
                </div>

                <div className="mb-4 grid gap-4 md:grid-cols-3">
                  <div className="flex items-center gap-2">
                    <CreditCard className="h-4 w-4 text-gray-400" />
                    <div>
                      <div className="text-xs text-gray-500">
                        Estado de pago
                      </div>
                      <div
                        className={`text-sm font-medium ${paymentStatusLabels[order.paymentStatus]?.color}`}
                      >
                        {paymentStatusLabels[order.paymentStatus]?.label ||
                          order.paymentStatus}
                      </div>
                    </div>
                  </div>

                  {order.shippingMethod && (
                    <div className="flex items-center gap-2">
                      <Truck className="h-4 w-4 text-gray-400" />
                      <div>
                        <div className="text-xs text-gray-500">Env√≠o</div>
                        <div className="text-sm font-medium">
                          {order.shippingMethod}
                        </div>
                      </div>
                    </div>
                  )}

                  {order.estimatedDelivery && (
                    <div className="flex items-center gap-2">
                      <Calendar className="h-4 w-4 text-gray-400" />
                      <div>
                        <div className="text-xs text-gray-500">
                          Entrega estimada
                        </div>
                        <div className="text-sm font-medium">
                          {formatDate(order.estimatedDelivery)}
                        </div>
                      </div>
                    </div>
                  )}
                </div>

                <div className="flex items-center justify-between border-t pt-4">
                  <div className="flex items-center gap-4">
                    {order.trackingAvailable && (
                      <span className="text-sm font-medium text-green-600">
                        ‚úì Seguimiento disponible
                      </span>
                    )}
                  </div>

                  <Button variant="outline" asChild>
                    <button
                      onClick={() => { handleViewOrder(order.id) }}
                      className="flex items-center gap-2"
                    >
                      <Eye className="h-4 w-4" />
                      Ver detalles
                    </button>
                  </Button>
                </div>
              </div>
            ))}
          </div>
        )}

        {/* Pagination */}
        {pagination.totalPages > 1 && (
          <div className="mt-8 flex items-center justify-between">
            <div className="text-sm text-gray-700">
              Mostrando {(currentPage - 1) * pagination.limit + 1} -{' '}
              {Math.min(currentPage * pagination.limit, pagination.total)} de{' '}
              {pagination.total} √≥rdenes
            </div>

            <div className="flex items-center gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={() => { handlePageChange(currentPage - 1) }}
                disabled={currentPage === 1}
                className="flex items-center gap-1"
              >
                <ChevronLeft className="h-4 w-4" />
                Anterior
              </Button>

              <div className="flex items-center gap-1">
                {[...Array(pagination.totalPages)].map((_, i) => {
                  const page = i + 1
                  if (
                    page === 1 ||
                    page === pagination.totalPages ||
                    (page >= currentPage - 1 && page <= currentPage + 1)
                  ) {
                    return (
                      <Button
                        key={page}
                        variant={currentPage === page ? 'default' : 'outline'}
                        size="sm"
                        onClick={() => { handlePageChange(page) }}
                        className="h-8 w-8 p-0"
                      >
                        {page}
                      </Button>
                    )
                  } else if (
                    page === currentPage - 2 ||
                    page === currentPage + 2
                  ) {
                    return (
                      <span key={page} className="px-2 text-gray-400">
                        ...
                      </span>
                    )
                  }
                  return null
                })}
              </div>

              <Button
                variant="outline"
                size="sm"
                onClick={() => { handlePageChange(currentPage + 1) }}
                disabled={currentPage === pagination.totalPages}
                className="flex items-center gap-1"
              >
                Siguiente
                <ChevronRight className="h-4 w-4" />
              </Button>
            </div>
          </div>
        )}
      </div>
      <OrderDetailModal
        isOpen={isModalOpen}
        onClose={() => {
          setIsModalOpen(false)
        }}
        orderId={selectedOrderId}
      />
    </>
  )
}



üìÅ ARCHIVO: src/hooks/useSummaryCart.ts
------------------------------------------------------------------------------------
// hooks/useSummaryCart.ts - Hook dedicado para manejo de selecci√≥n del resumen
'use client'
import { useCallback, useEffect, useRef, useState } from 'react'
import { type CartItem } from './useCart'

export function useSummaryCart(items: CartItem[]) {
  const [selectedItemIds, setSelectedItemIds] = useState<number[]>([])

  // üÜï Ref para rastrear si la √∫ltima acci√≥n fue manual (toggle)
  const lastActionWasManualRef = useRef(false)
  const previousItemsLengthRef = useRef(0)

  // Auto-seleccionar nuevos items SOLO cuando se agregan items al carrito
  useEffect(() => {
    const currentItemIds = items.map((item) => item.id)
    const currentItemsLength = items.length

    // Solo auto-seleccionar si:
    // 1. No fue una acci√≥n manual reciente
    // 2. Se agregaron nuevos items (aument√≥ la cantidad)
    if (
      !lastActionWasManualRef.current &&
      currentItemsLength > previousItemsLengthRef.current
    ) {
      const newItems = currentItemIds.filter(
        (id) => !selectedItemIds.includes(id)
      )

      if (newItems.length > 0) {
        console.log('üìã Auto-selecting new items for summary:', newItems)
        setSelectedItemIds((prev) => [...prev, ...newItems])
      }
    }

    // Siempre remover items que ya no existen en el carrito
    const existingSelectedIds = selectedItemIds.filter((id) =>
      currentItemIds.includes(id)
    )

    if (existingSelectedIds.length !== selectedItemIds.length) {
      console.log('üìã Removing non-existent items from summary selection')
      setSelectedItemIds(existingSelectedIds)
    }

    // Actualizar la referencia de longitud anterior
    previousItemsLengthRef.current = currentItemsLength

    // Reset del flag de acci√≥n manual despu√©s de un tiempo
    if (lastActionWasManualRef.current) {
      const timer = setTimeout(() => {
        lastActionWasManualRef.current = false
      }, 100) // 100ms es suficiente para evitar conflicts

      return () => { clearTimeout(timer) }
    }
  }, [items])

  // Verificar si un item est√° seleccionado
  const isItemSelected = useCallback(
    (id: number): boolean => {
      return selectedItemIds.includes(id)
    },
    [selectedItemIds]
  )

  // Toggle selecci√≥n de un item individual
  const toggleItemSelection = useCallback((id: number) => {
    console.log('üìã Manual toggle for item:', id)

    // üÜï Marcar que esta fue una acci√≥n manual
    lastActionWasManualRef.current = true

    setSelectedItemIds((prev) => {
      if (prev.includes(id)) {
        console.log('üìã Deselecting item:', id)
        return prev.filter((selectedId) => selectedId !== id)
      } else {
        console.log('üìã Selecting item:', id)
        return [...prev, id]
      }
    })
  }, [])

  // Verificar si todos los items est√°n seleccionados
  const isAllSelected =
    items.length > 0 && selectedItemIds.length === items.length

  // Toggle selecci√≥n de todos los items
  const toggleSelectAll = useCallback(() => {
    console.log('üìã Manual toggle all')

    // üÜï Marcar que esta fue una acci√≥n manual
    lastActionWasManualRef.current = true

    if (isAllSelected) {
      console.log('üìã Deselecting all items from summary')
      setSelectedItemIds([])
    } else {
      console.log('üìã Selecting all items for summary')
      setSelectedItemIds(items.map((item) => item.id))
    }
  }, [isAllSelected, items])

  // Calcular items seleccionados y totales
  const selectedItems = items.filter((item) =>
    selectedItemIds.includes(item.id)
  )
  const selectedTotalItems = selectedItems.reduce(
    (sum, item) => sum + item.quantity,
    0
  )
  const selectedTotalPrice = selectedItems.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0
  )

  // Funciones para el resumen
  const getSelectedCount = () => selectedItems.length
  const hasSelectedItems = () => selectedItems.length > 0

  // Debug info
  useEffect(() => {
    console.log('üìã Summary Selection State:', {
      totalItems: items.length,
      selectedCount: selectedItems.length,
      selectedTotalItems,
      selectedTotalPrice: selectedTotalPrice.toFixed(2),
      isAllSelected,
      lastActionWasManual: lastActionWasManualRef.current
    })
  }, [
    items,
    selectedItems,
    selectedTotalItems,
    selectedTotalPrice,
    isAllSelected
  ])

  return {
    // Estados
    selectedItemIds,
    selectedItems,
    selectedTotalItems,
    selectedTotalPrice,
    isAllSelected,

    // Funciones
    isItemSelected,
    toggleItemSelection,
    toggleSelectAll,
    getSelectedCount,
    hasSelectedItems,

    // Setters (por si necesitas control directo)
    setSelectedItemIds
  }
}

export default useSummaryCart



üìÅ ARCHIVO: src/hooks/useImageCarousel.ts
------------------------------------------------------------------------------------
import { useCallback, useEffect, useRef, useState } from 'react'

// Tipo base para im√°genes compatibles
export interface BaseImage {
  id: number
  imageUrlNormal: string
  imageUrlThumb: string
  imageUrlZoom: string
  altText?: string
  imageType?: string
  displayOrder?: number
}

export interface UseImageCarouselProps {
  images: BaseImage[]
  initialIndex?: number
  mouseZoneDetection?: boolean // ‚úÖ Prop para activar detecci√≥n por zonas
  loop?: boolean
  preloadImages?: boolean
}

export interface UseImageCarouselReturn {
  // Estado actual
  currentImageIndex: number
  currentImage: BaseImage | null
  hasMultipleImages: boolean

  // Navegaci√≥n
  goToNextImage: () => void
  goToPrevImage: () => void
  goToImage: (index: number) => void

  // Handlers para eventos (detecci√≥n por zonas o b√°sicos)
  handleMouseEnter: (event?: React.MouseEvent<HTMLDivElement>) => void
  handleMouseLeave: () => void
  handleMouseMove: (event: React.MouseEvent<HTMLDivElement>) => void

  // Utilidades
  getImageAtIndex: (index: number) => BaseImage | null
  isFirstImage: boolean
  isLastImage: boolean
  totalImages: number

  // Propiedades para detecci√≥n por zonas
  containerRef: React.RefObject<HTMLDivElement>
  currentZone: number
  isHovering: boolean
}

export const useImageCarousel = ({
  images,
  initialIndex = 0,
  mouseZoneDetection = false,
  loop = true,
  preloadImages = true
}: UseImageCarouselProps): UseImageCarouselReturn => {
  const [currentImageIndex, setCurrentImageIndex] = useState(() => {
    if (images.length === 0) return 0
    const validIndex = Math.max(0, Math.min(initialIndex, images.length - 1))
    return validIndex
  })

  const [isHovering, setIsHovering] = useState(false)
  const [currentZone, setCurrentZone] = useState(0)
  const preloadedRef = useRef<Set<number>>(new Set())
  const containerRef = useRef<HTMLDivElement>(null)

  // Propiedades derivadas
  const hasMultipleImages = images.length > 1
  const currentImage = images[currentImageIndex] || null
  const isFirstImage = currentImageIndex === 0
  const isLastImage = currentImageIndex === images.length - 1
  const totalImages = images.length

  // Funci√≥n para precargar im√°genes
  const preloadImage = useCallback(
    (index: number) => {
      if (!preloadImages || preloadedRef.current.has(index) || !images[index]) { return }

      const img = new Image()
      img.src = images[index].imageUrlNormal
      preloadedRef.current.add(index)
    },
    [images, preloadImages]
  )

  // ‚úÖ Utilidades para detecci√≥n por zonas
  const getZoneWidth = useCallback((): number => {
    if (!containerRef.current || totalImages <= 0) return 0
    return containerRef.current.offsetWidth / totalImages
  }, [totalImages])

  const getZoneForPosition = useCallback(
    (x: number): number => {
      const zoneWidth = getZoneWidth()
      if (zoneWidth <= 0) return 0

      const zone = Math.floor(x / zoneWidth)
      return Math.max(0, Math.min(zone, totalImages - 1))
    },
    [getZoneWidth, totalImages]
  )

  // Navegaci√≥n b√°sica
  const goToImage = useCallback(
    (index: number) => {
      if (images.length === 0) return

      const validIndex = Math.max(0, Math.min(index, images.length - 1))
      setCurrentImageIndex(validIndex)

      // Precargar imagen actual y adyacentes
      if (preloadImages) {
        preloadImage(validIndex)
        if (validIndex > 0) preloadImage(validIndex - 1)
        if (validIndex < images.length - 1) preloadImage(validIndex + 1)
      }
    },
    [images.length, preloadImage, preloadImages]
  )

  const goToNextImage = useCallback(() => {
    if (images.length === 0) return

    if (isLastImage) {
      if (loop) {
        goToImage(0)
      }
    } else {
      goToImage(currentImageIndex + 1)
    }
  }, [currentImageIndex, isLastImage, loop, goToImage, images.length])

  const goToPrevImage = useCallback(() => {
    if (images.length === 0) return

    if (isFirstImage) {
      if (loop) {
        goToImage(images.length - 1)
      }
    } else {
      goToImage(currentImageIndex - 1)
    }
  }, [currentImageIndex, isFirstImage, loop, goToImage, images.length])

  // ‚úÖ Handlers para eventos (con detecci√≥n por zonas)
  const handleMouseMove = useCallback(
    (event: React.MouseEvent<HTMLDivElement>) => {
      if (!mouseZoneDetection || !containerRef.current || !hasMultipleImages) { return }

      // Obtener posici√≥n relativa dentro del contenedor
      const rect = containerRef.current.getBoundingClientRect()
      const x = event.clientX - rect.left

      // Calcular zona actual
      const newZone = getZoneForPosition(x)

      // Solo actualizar si cambi√≥ la zona
      if (newZone !== currentZone) {
        setCurrentZone(newZone)
        goToImage(newZone) // ‚úÖ Cambiar imagen cuando cambie la zona
      }
    },
    [
      mouseZoneDetection,
      hasMultipleImages,
      currentZone,
      getZoneForPosition,
      goToImage
    ]
  )

  const handleMouseEnter = useCallback(
    (event?: React.MouseEvent<HTMLDivElement>) => {
      setIsHovering(true)

      // Si est√° activada la detecci√≥n por zonas, calcular zona inicial
      if (
        mouseZoneDetection &&
        event &&
        containerRef.current &&
        hasMultipleImages
      ) {
        const rect = containerRef.current.getBoundingClientRect()
        const x = event.clientX - rect.left
        const initialZone = getZoneForPosition(x)

        setCurrentZone(initialZone)
        goToImage(initialZone)
      }
    },
    [mouseZoneDetection, hasMultipleImages, getZoneForPosition, goToImage]
  )

  const handleMouseLeave = useCallback(() => {
    setIsHovering(false)

    // Opcionalmente resetear a la primera imagen al salir
    if (mouseZoneDetection) {
      setCurrentZone(0)
      goToImage(0)
    }
  }, [mouseZoneDetection, goToImage])

  // Utilidad para obtener imagen por √≠ndice
  const getImageAtIndex = useCallback(
    (index: number): BaseImage | null => {
      return images[index] || null
    },
    [images]
  )

  // Efecto para actualizar √≠ndice cuando cambian las im√°genes
  useEffect(() => {
    if (images.length === 0) {
      setCurrentImageIndex(0)
      return
    }

    // Si el √≠ndice actual es mayor que el n√∫mero de im√°genes, resetear
    if (currentImageIndex >= images.length) {
      setCurrentImageIndex(0)
    }

    // Precargar primera imagen
    if (preloadImages && images.length > 0) {
      preloadImage(0)
    }
  }, [images, currentImageIndex, preloadImage, preloadImages])

  // Efecto para manejar cambios en initialIndex
  useEffect(() => {
    if (
      initialIndex !== undefined &&
      initialIndex >= 0 &&
      initialIndex < images.length
    ) {
      goToImage(initialIndex)
    }
  }, [initialIndex, images.length, goToImage])

  return {
    // Estado actual
    currentImageIndex,
    currentImage,
    hasMultipleImages,

    // Navegaci√≥n
    goToNextImage,
    goToPrevImage,
    goToImage,

    // Handlers para eventos
    handleMouseEnter,
    handleMouseLeave,
    handleMouseMove,

    // Utilidades
    getImageAtIndex,
    isFirstImage,
    isLastImage,
    totalImages,

    // Propiedades para detecci√≥n por zonas
    containerRef,
    currentZone,
    isHovering
  }
}



üìÅ ARCHIVO: src/hooks/useStickyFilters.ts
------------------------------------------------------------------------------------
'use client'
import { useEffect, useState } from 'react'

interface UseStickyFiltersReturn {
  topPosition: string
  maxHeight: string
  minHeight: string
  bottomConstraint: string
}

export const useStickyFilters = (): UseStickyFiltersReturn => {
  const [topPosition, setTopPosition] = useState('82px') // header
  const [maxHeight, setMaxHeight] = useState('70vh')
  const [minHeight, setMinHeight] = useState('400px')
  const [bottomConstraint, setBottomConstraint] = useState('auto')

  useEffect(() => {
    const calculateDimensions = () => {
      // Obtener altura del header
      const header =
        document.querySelector('header') ||
        document.querySelector('[data-header]')
      const headerHeight = header ? header.offsetHeight : 128

      // Obtener posici√≥n del footer
      const footer =
        document.querySelector('footer') ||
        document.querySelector('[data-footer]')

      const calculatedTop = `${headerHeight + 16}px` // Posici√≥n inicial
      let calculatedMaxHeight = '70vh' // Altura por defecto
      const calculatedMinHeight = '400px' // Altura m√≠nima
      let calculatedBottomConstraint = 'auto'

      if (footer) {
        const footerRect = footer.getBoundingClientRect()
        const footerTop = footerRect.top + window.scrollY

        // Calcular la distancia desde el top del documento hasta el footer
        // menos un margen de seguridad
        const distanceToFooter = footerTop - 32 // 32px de margen
        calculatedBottomConstraint = `${distanceToFooter}px`

        // Ajustar altura m√°xima basada en el espacio disponible
        const availableSpace = distanceToFooter - (headerHeight + 16)
        if (availableSpace > 400) {
          calculatedMaxHeight = `${Math.min(availableSpace, window.innerHeight * 0.7)}px`
        } else {
          calculatedMaxHeight = '400px'
        }
      }

      setTopPosition(calculatedTop)
      setMaxHeight(calculatedMaxHeight)
      setMinHeight(calculatedMinHeight)
      setBottomConstraint(calculatedBottomConstraint)
    }

    // Calcular dimensiones al montar
    calculateDimensions()

    // Recalcular en scroll y resize
    const handleScroll = () => { calculateDimensions() }
    const handleResize = () => { calculateDimensions() }

    window.addEventListener('scroll', handleScroll)
    window.addEventListener('resize', handleResize)

    // Recalcular cuando el DOM est√© completamente cargado
    const timer = setTimeout(calculateDimensions, 100)

    return () => {
      window.removeEventListener('scroll', handleScroll)
      window.removeEventListener('resize', handleResize)
      clearTimeout(timer)
    }
  }, [])

  return {
    topPosition,
    maxHeight,
    minHeight,
    bottomConstraint
  }
}



üìÅ ARCHIVO: src/hooks/useCart.ts
------------------------------------------------------------------------------------
// hooks/useCart.ts - Con sincronizaci√≥n de localStorage
'use client'
import { type PromotionVariants } from '@/types/domain'
import { usePathname, useRouter } from 'next/navigation'
import { useCallback, useEffect, useRef, useState } from 'react'

export interface CartItem {
  id: number
  name: string
  price: number
  image: string
  quantity: number
  stock: number
  promotionVariants?: Array<PromotionVariants | null> | null
}

// Tipos para delete confirmation
interface DeleteConfirmation {
  isOpen: boolean
  productId: number | null
  message?: string
  onConfirm: (() => void) | null
}

// üëà CONFIGURACI√ìN DE RUTAS SIMPLIFICADA
const ALLOWED_MINICART_ROUTES = [
  '/products', // P√°gina de productos
  '/categories', // P√°gina de categor√≠as
  '/search', // P√°gina de b√∫squeda
  '/product', // P√°gina de producto individual
  '/category', // P√°gina de categor√≠a espec√≠fica
  '/productos', // Base de productos
  '/productos/variante' // PDP con variantes
]

// üëà RUTAS DONDE NO SE DEBE MOSTRAR EL MINICART (incluyendo home y cart)
const NO_MINICART_ROUTES = [
  // '/', // Homepage - NO abrir minicart
  '/cart', // P√°gina del carrito - NO abrir minicart
  '/checkout', // P√°gina de checkout
  '/login', // P√°gina de login
  '/register', // P√°gina de registro
  '/admin', // Panel admin
  '/profile', // Perfil de usuario
  '/orders' // √ìrdenes del usuario
]

// üëà FUNCI√ìN SIMPLIFICADA PARA VERIFICAR SI DEBE ABRIR MINICART
const shouldOpenMinicart = (currentPath: string): boolean => {
  // Verificar rutas donde NO se debe abrir minicart
  const shouldNotOpen = NO_MINICART_ROUTES.some((route) => {
    return currentPath === route || currentPath.startsWith(route + '/')
  })

  if (shouldNotOpen) {
    return false
  }

  // Verificar rutas permitidas para minicart
  const isAllowed = ALLOWED_MINICART_ROUTES.some((allowedRoute) => {
    return (
      currentPath === allowedRoute || currentPath.startsWith(allowedRoute + '/')
    )
  })

  return isAllowed
}

export function useCart() {
  const router = useRouter()
  const pathname = usePathname()
  const [items, setItems] = useState<CartItem[]>([])
  const [totalItems, setTotalItems] = useState(0)
  const [totalPrice, setTotalPrice] = useState(0)
  const [isCartOpen, setIsCartOpen] = useState(false)
  const [toastMessage, setToastMessage] = useState<string | null>(null)

  // FLAGS PARA CONTROLAR EL FLUJO
  const [isInitialized, setIsInitialized] = useState(false)
  const hasLoadedRef = useRef(false)
  const isMountedRef = useRef(true)

  // üÜï ESTADO PARA DELETE CONFIRMATION
  const [deleteConfirmation, setDeleteConfirmation] =
    useState<DeleteConfirmation>({
      isOpen: false,
      productId: null,
      message: '',
      onConfirm: null
    })

  // üëà FUNCI√ìN PARA VERIFICAR SI LA RUTA PERMITE MINICART (para otros componentes)
  const isMinicartAllowedOnRoute = (currentPath: string): boolean => {
    return shouldOpenMinicart(currentPath)
  }

  // üÜï FUNCI√ìN PARA SINCRONIZAR CON LOCALSTORAGE
  const syncWithLocalStorage = useCallback(() => {
    try {
      const savedCart = localStorage.getItem('cart')
      if (savedCart) {
        const parsedCart = JSON.parse(savedCart)
        console.log('üîÑ Syncing cart with localStorage:', parsedCart)
        setItems(parsedCart)
      }
    } catch (error) {
      console.error('‚ùå Error syncing with localStorage:', error)
    }
  }, [])

  // üÜï LISTENER PARA EVENTOS DE ACTUALIZACI√ìN DEL CARRITO
  useEffect(() => {
    const handleCartUpdate = () => {
      console.log('üì° Received cart update event')
      syncWithLocalStorage()
    }

    // Escuchar evento personalizado
    window.addEventListener('cartUpdated', handleCartUpdate)

    // Tambi√©n escuchar cambios en localStorage (para tabs m√∫ltiples)
    window.addEventListener('storage', (e) => {
      if (e.key === 'cart') {
        console.log('üì° localStorage cart changed in another tab')
        syncWithLocalStorage()
      }
    })

    return () => {
      window.removeEventListener('cartUpdated', handleCartUpdate)
      window.removeEventListener('storage', handleCartUpdate)
    }
  }, [syncWithLocalStorage])

  // üëà CERRAR MINICART AL CAMBIAR A RUTA BLOQUEADA
  useEffect(() => {
    console.log('üîÑ Route changed to:', pathname)

    if (!isMinicartAllowedOnRoute(pathname)) {
      console.log('üîí Closing minicart due to route restriction')
      setIsCartOpen(false)
    }
  }, [pathname])

  // EFECTO 1: CARGAR desde localStorage
  useEffect(() => {
    console.log('üîÑ Initializing cart from localStorage...')

    if (hasLoadedRef.current) {
      console.log('‚è≠Ô∏è Already loaded, skipping...')
      return
    }

    const loadCart = async () => {
      try {
        const savedCart = localStorage.getItem('cart')
        console.log('üì¶ Raw localStorage data:', savedCart)

        if (savedCart && savedCart !== '[]' && savedCart !== 'null') {
          const parsedCart = JSON.parse(savedCart)
          console.log('‚úÖ Parsed cart data:', parsedCart)

          if (isMountedRef.current) {
            setItems(parsedCart)
          }
        } else {
          console.log('üì≠ No cart data found, keeping empty array')
        }
      } catch (error) {
        console.error('‚ùå Error parsing cart from localStorage:', error)
      } finally {
        if (isMountedRef.current) {
          hasLoadedRef.current = true
          setIsInitialized(true)
          console.log('‚úÖ Cart initialization complete')
        }
      }
    }

    loadCart()

    return () => {
      isMountedRef.current = false
    }
  }, [])

  // EFECTO 2: GUARDAR en localStorage
  useEffect(() => {
    if (!isInitialized) {
      console.log('‚è≠Ô∏è Skipping save - not initialized yet')
      return
    }

    console.log('üíæ Saving to localStorage:', items)

    try {
      localStorage.setItem('cart', JSON.stringify(items))

      const itemCount = items.reduce((total, item) => total + item.quantity, 0)
      const priceTotal = items.reduce(
        (total, item) => total + item.price * item.quantity,
        0
      )

      setTotalItems(itemCount)
      setTotalPrice(priceTotal)

      console.log(
        '‚úÖ Cart saved successfully. Items:',
        itemCount,
        'Total:',
        priceTotal
      )
    } catch (error) {
      console.error('‚ùå Error saving to localStorage:', error)
    }
  }, [items, isInitialized])

  // EFECTO 3: Toast timer
  useEffect(() => {
    if (toastMessage) {
      const timer = setTimeout(() => {
        setToastMessage(null)
      }, 3000)
      return () => { clearTimeout(timer) }
    }
  }, [toastMessage])

  const addItem = (
    item: Omit<CartItem, 'quantity'>,
    initialQuantity: number = 1
  ) => {
    console.log('‚ûï Adding item:', item.name, 'Qty:', initialQuantity)

    // Agregar el item al estado SIEMPRE
    setItems((prevItems) => {
      const existingItemIndex = prevItems.findIndex((i) => i.id === item.id)
      if (existingItemIndex >= 0) {
        const updatedItems = [...prevItems]
        updatedItems[existingItemIndex].quantity += initialQuantity
        console.log(
          'üìù Updated existing item quantity:',
          updatedItems[existingItemIndex].quantity
        )
        return updatedItems
      } else {
        const newItems = [...prevItems, { ...item, quantity: initialQuantity }]
        console.log('üÜï Added new item. Total items:', newItems.length)
        return newItems
      }
    })

    // Mostrar toast SIEMPRE
    setToastMessage('A√±adido a la cesta!')

    // Abrir minicart solo si la ruta lo permite
    if (shouldOpenMinicart(pathname)) {
      console.log('‚ú® Opening minicart after adding item on route:', pathname)
      setIsCartOpen(true)
    } else {
      console.log('üö´ Not opening minicart on route:', pathname)
    }
  }

  const removeItem = (id: number) => {
    console.log('üóëÔ∏è Removing item ID:', id)
    const itemToRemove = items.find((item) => item.id === id)

    setItems((prevItems) => {
      const newItems = prevItems.filter((item) => item.id !== id)
      console.log('üìù Items after removal:', newItems.length)
      return newItems
    })

    if (itemToRemove) {
      setToastMessage('Correctamente')
    }
  }

  const updateQuantity = (id: number, quantity: number) => {
    console.log('üîÑ Updating quantity - ID:', id, 'New qty:', quantity)

    if (quantity <= 0) {
      removeItem(id)
      return
    }

    // ‚úÖ NUEVA L√ìGICA: Leer desde localStorage para preservar stock actualizado
    setItems((prevItems) => {
      // üîç Obtener datos actuales de localStorage
      const currentCartData = localStorage.getItem('cart')
      let localStorageItems: CartItem[] = []

      if (currentCartData) {
        try {
          localStorageItems = JSON.parse(currentCartData)
          console.log('üì¶ Current localStorage cart:', localStorageItems)
        } catch (error) {
          console.error('‚ùå Error parsing localStorage cart:', error)
          // Fallback al estado actual si falla el parsing
          localStorageItems = prevItems
        }
      } else {
        // Fallback al estado actual si no hay localStorage
        localStorageItems = prevItems
      }

      // üîÑ Actualizar solo la cantidad, preservando otros datos de localStorage
      const updatedItems = localStorageItems.map((item) => {
        if (item.id === id) {
          const itemFromLocalStorage = localStorageItems.find(
            (lsItem) => lsItem.id === id
          )
          console.log('üìù Updating item:', {
            name: item.name,
            oldQuantity: item.quantity,
            newQuantity: quantity,
            stockFromLS: itemFromLocalStorage?.stock || item.stock,
            stockFromState: item.stock
          })

          // ‚úÖ Preservar todos los datos de localStorage, solo cambiar quantity
          return {
            ...item, // Usar datos de localStorage (incluye stock actualizado)
            quantity // Solo actualizar la cantidad
          }
        }
        return item
      })

      console.log(
        '‚úÖ Updated items with preserved localStorage data:',
        updatedItems
      )
      return updatedItems
    })

    // Mostrar toast SIEMPRE
    setToastMessage('Cantidad actualizada')

    // Abrir minicart solo si la ruta lo permite
    if (shouldOpenMinicart(pathname)) {
      console.log(
        '‚ú® Opening minicart after updating quantity on route:',
        pathname
      )
      setIsCartOpen(true)
    } else {
      console.log('üö´ Not opening minicart on route:', pathname)
    }
  }

  const incrementQuantity = (id: number) => {
    console.log('‚¨ÜÔ∏è Incrementing quantity for ID:', id)
    setItems((prevItems) =>
      prevItems.map((item) =>
        item.id === id ? { ...item, quantity: item.quantity + 1 } : item
      )
    )
  }

  const decrementQuantity = (id: number) => {
    console.log('‚¨áÔ∏è Decrementing quantity for ID:', id)
    setItems((prevItems) => {
      return prevItems
        .map((item) => {
          if (item.id === id) {
            const newQuantity = item.quantity - 1
            if (newQuantity <= 0) {
              console.log('üóëÔ∏è Quantity reached 0, will remove item')
              return null
            }
            return { ...item, quantity: newQuantity }
          }
          return item
        })
        .filter(Boolean) as CartItem[]
    })
  }

  const clearCart = () => {
    console.log('üßπ Clearing entire cart')
    setItems([])
    setToastMessage('Carrito vaciado')
  }

  // üëà FUNCI√ìN PRINCIPAL: ABRIR CARRITO CON VALIDACI√ìN DE RUTA
  const openCart = () => {
    const currentPath = pathname
    console.log('üëÜ Attempting to open cart on route:', currentPath)

    if (!isMinicartAllowedOnRoute(currentPath)) {
      console.log('üö´ Minicart not allowed on this route, redirecting to /cart')
      // router.push('/cart')
      return
    }

    console.log('‚úÖ Opening minicart')
    setIsCartOpen(true)
  }

  const closeCart = () => {
    console.log('üëá Closing cart')
    setIsCartOpen(false)
  }

  const toggleCart = () => {
    if (isCartOpen) {
      closeCart()
    } else {
      openCart()
    }
  }

  // üëà FUNCI√ìN HELPER PARA COMPONENTES
  const canShowMinicart = (): boolean => {
    return isMinicartAllowedOnRoute(pathname)
  }

  // üëà FUNCI√ìN PARA IR AL CARRITO COMPLETO
  const goToCartPage = () => {
    console.log('üõí Navigating to full cart page')
    setIsCartOpen(false)
    router.push('/cart')
  }

  // üÜï FUNCIONES DE DELETE CONFIRMATION
  const openDeleteConfirmation = useCallback(
    (id: number, message?: string, onConfirm?: () => void) => {
      console.log('üóëÔ∏è Opening delete confirmation:', { id })
      setDeleteConfirmation({
        isOpen: true,
        message,
        productId: id,
        onConfirm: onConfirm || (() => { removeItem(id) })
      })
    },
    []
  )

  const closeDeleteConfirmation = useCallback(() => {
    console.log('‚ùå Closing delete confirmation')
    setDeleteConfirmation({
      isOpen: false,
      productId: null,
      message: '',
      onConfirm: null
    })
  }, [])

  const confirmDelete = useCallback(() => {
    console.log('‚úÖ Confirming delete')
    if (deleteConfirmation.onConfirm) {
      deleteConfirmation.onConfirm()
    }
    closeDeleteConfirmation()
  }, [deleteConfirmation.onConfirm, closeDeleteConfirmation])

  // DEBUG INFO
  useEffect(() => {
    console.log('üìä Cart State Summary:', {
      itemsCount: items.length,
      totalItems,
      totalPrice: totalPrice.toFixed(2),
      isInitialized,
      hasLoaded: hasLoadedRef.current,
      currentRoute: pathname,
      canShowMinicart: canShowMinicart()
    })
  }, [items, totalItems, totalPrice, isInitialized, pathname])

  return {
    // Funcionalidad principal del carrito
    items,
    addItem,
    removeItem,
    updateQuantity,
    incrementQuantity,
    decrementQuantity,
    clearCart,
    totalItems,
    totalPrice,
    isCartOpen,
    openCart,
    closeCart,
    toggleCart,
    goToCartPage,
    canShowMinicart,
    toastMessage,
    setToastMessage,
    isInitialized,

    // Funcionalidad de delete confirmation
    deleteConfirmation,
    openDeleteConfirmation,
    closeDeleteConfirmation,
    confirmDelete
  }
}

// üëà CONFIGURACI√ìN EXPORTADA
export const CART_ROUTE_CONFIG = {
  ALLOWED_ROUTES: ALLOWED_MINICART_ROUTES,
  BLOCKED_ROUTES: NO_MINICART_ROUTES
}

export default useCart



üìÅ ARCHIVO: src/lib/utils.ts
------------------------------------------------------------------------------------
import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



üìÅ ARCHIVO: src/lib/db.ts
------------------------------------------------------------------------------------
import mysql from 'serverless-mysql'

const db = mysql({
  config: {
    host: process.env.MYSQL_HOST,
    port: parseInt(process.env.MYSQL_PORT || '3306'),
    database: process.env.MYSQL_DATABASE,
    user: process.env.MYSQL_USER,
    password: process.env.MYSQL_PASSWORD
  }
})

export async function executeQuery<T>({
  query,
  values
}: {
  query: string
  values?: any[]
}): Promise<T> {
  try {
    const results = await db.query<T>(query, values)
    await db.end()
    return results
  } catch (error) {
    throw error
  }
}



üìÅ ARCHIVO: src/lib/auth.ts
------------------------------------------------------------------------------------
import CustomerService from '@/services/customer'
import NextAuth, { type NextAuthOptions } from 'next-auth'
import CredentialsProvider from 'next-auth/providers/credentials'

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: 'Credenciales',
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Contrase√±a', type: 'password' }
      },
      async authorize(credentials) {
        if (credentials?.email == null || credentials?.password == null) {
          return null
        }

        try {
          // Usar el servicio de cliente para autenticar
          const customer = await CustomerService.login(credentials)

          if (customer != null) {
            return {
              id: customer.id.toString(), // Asegurar que sea string
              email: customer.email,
              name: customer.name
            }
          }
        } catch (error) {
          console.error('Error en authorize:', error)
        }

        // Credenciales inv√°lidas
        return null
      }
    })
  ],
  pages: {
    signIn: '/' // No redirigimos a una p√°gina espec√≠fica, usamos un modal
  },
  callbacks: {
    async jwt({ token, user }) {
      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
      if (user) {
        token.id = user.id
        token.name = user.name
      }
      return token
    },
    async session({ session, token }) {
      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
      if (session.user) {
        session.user.id = token.id as string
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        session.user.name = token.name!
      }
      return session
    }
  },
  session: {
    strategy: 'jwt' as const
  }
}

export default NextAuth(authOptions)



üìÅ ARCHIVO: src/helpers/productVariant.helpers.ts
------------------------------------------------------------------------------------
import { type ProductVariantData } from '@/services/product/productVariant'
import { type ProductVariants } from '@/types/domain'
import { type Metadata } from 'next'

export const generateProductVariantMetadata = (
  data: ProductVariantData | null,
  variantId: number
): Metadata => {
  if (!data?.product) {
    return {
      title: 'Producto no encontrado',
      description: 'El producto que buscas no existe o ha sido eliminado.'
    }
  }

  const { product } = data

  const variant = product.productVariants?.find((pv) => pv?.id === variantId)
  let title = product.name
  if (variant) {
    title = getVariantTitle(product.name, variant)
  }

  return {
    title,
    description: product.description || `${title} - Compra online en TechStore`,
    openGraph: {
      title,
      description:
        product.description || `${title} - Compra online en TechStore`
    }
  }
}

export const generateErrorMetadata = (error: string): Metadata => {
  return {
    title: 'Error',
    description: error
  }
}

export const getVariantTitle = (
  name: string,
  variant?: ProductVariants
): string => {
  const baseTitle = name

  if (!variant) return baseTitle

  // Obtener los atributos de la variante
  const variantAttributes = variant.variantAttributeOptions
    ?.map((variantAttr) => {
      // Verificar que variantAttr no sea null
      if (!variantAttr) return null
      // Obtener el valor del atributo desde attributeOptions
      const attributeOption = variantAttr.attributeOption
      return attributeOption?.value
    })
    .filter(Boolean) // Filtrar valores undefined/null
    .join(' - ')

  // Si hay atributos, agregarlos al t√≠tulo
  if (variantAttributes && variantAttributes.length > 0) {
    return `${baseTitle} - ${variantAttributes}`
  }

  return baseTitle
}



üìÅ ARCHIVO: src/helpers/image.helpers.ts
------------------------------------------------------------------------------------
import { type ProductVariantComplete } from '@/backend/product-variant'
import { type ItemImage } from '@/shared'
import { type AttributeOptionImages, type ProductVariants } from '@/types/domain'

// Funci√≥n helper para normalizar las im√°genes a ItemImage
const normalizeToItemImage = (img: any): ItemImage => ({
  id: img.id || 0,
  imageType: img.imageType || 'front',
  imageUrlNormal: img.imageUrlNormal || '/no-image.webp',
  imageUrlThumb: img.imageUrlThumb || '/no-image.webp',
  imageUrlZoom: img.imageUrlZoom || '/no-image.webp',
  displayOrder: Number(img.displayOrder || 0),
  altText: img.altText
})

// Funci√≥n helper para ordenar im√°genes
const sortImages = (images: ItemImage[]): ItemImage[] => {
  return images.sort((a, b) => {
    // Front primero
    if (a.imageType === 'front' && b.imageType !== 'front') return -1
    if (b.imageType === 'front' && a.imageType !== 'front') return 1
    // Luego por displayOrder
    return (a.displayOrder || 0) - (b.displayOrder || 0)
  })
}

// Funci√≥n principal que maneja ambos tipos
export const getVariantImages = (
  variant: ProductVariants | ProductVariantComplete
): ItemImage[] => {
  // Verificar si es ProductVariantComplete (tiene variantImages directamente)
  const isComplete =
    'variantImages' in variant &&
    !(
      'variantImages' in variant &&
      variant.variantImages?.[0]?.hasOwnProperty('variantImage')
    )

  if (isComplete) {
    // Es ProductVariantComplete - usar la funci√≥n existente
    return getVariantImagesOrAttributeOptionImages(
      variant as ProductVariantComplete
    )
  }

  // Es ProductVariants - manejar estructura GraphQL
  const variantImages = variant.variantImages?.filter(Boolean) || []

  // Si tiene variantImages, usarlas
  if (variantImages.length > 0) {
    const normalizedImages = variantImages.map(normalizeToItemImage)
    return sortImages(normalizedImages)
  }

  // Si no hay variantImages, buscar en attributeOptionImages
  if (
    variant.variantAttributeOptions &&
    variant.variantAttributeOptions.length > 0
  ) {
    const attributeImages: ItemImage[] = []

    // Iterar sobre las opciones de atributos de la variante
    for (const variantAttrOption of variant.variantAttributeOptions) {
      if (variantAttrOption?.attributeOption?.attributeOptionImages) {
        const images = variantAttrOption.attributeOption.attributeOptionImages
          .filter(Boolean)
          .map(normalizeToItemImage)

        attributeImages.push(...images)
      }
    }

    if (attributeImages.length > 0) {
      // Eliminar duplicados por ID
      const uniqueImages = attributeImages.filter(
        (img, index, arr) => arr.findIndex((i) => i.id === img.id) === index
      )

      return sortImages(uniqueImages)
    }
  }

  // Fallback: imagen por defecto
  return [
    {
      imageType: 'front',
      id: 0,
      imageUrlNormal: '/no-image.webp',
      imageUrlThumb: '/no-image.webp',
      imageUrlZoom: '/no-image.webp',
      displayOrder: 0
    }
  ]
}

// Funci√≥n espec√≠fica para ProductVariantComplete (mantener compatibilidad)
export const getVariantImagesOrAttributeOptionImages = (
  variant: ProductVariantComplete
): ItemImage[] => {
  if (variant.variantImages && variant.variantImages.length > 0) {
    const sortedImages = variant.variantImages
      .sort((a, b) => {
        if (a.imageType === 'front' && b.imageType !== 'front') return -1
        if (b.imageType === 'front' && a.imageType !== 'front') return 1
        return (a.displayOrder || 0) - (b.displayOrder || 0)
      })
      .map((img) => ({ ...img, displayOrder: Number(img.displayOrder) }))
    return sortedImages
  }

  // Si no hay variantImages, filtrar attributeImages seg√∫n los atributos de la variante
  if (
    variant.attributeImages &&
    variant.attributeImages.length > 0 &&
    variant.variantAttributeOptions &&
    variant.variantAttributeOptions.length > 0
  ) {
    // Obtener los attributeOptionIds de la variante
    const variantAttributeOptionIds = variant.variantAttributeOptions.map(
      (attr) => attr.attributeOptionId
    )

    // Filtrar solo las im√°genes que corresponden a los atributos de esta variante
    const filteredImages = variant.attributeImages.filter(
      (img: AttributeOptionImages) =>
        variantAttributeOptionIds.includes(img.attributeOptionId)
    )

    if (filteredImages.length > 0) {
      // Ordenar: front primero, luego por displayOrder
      const sortedImages = filteredImages
        .sort((a: AttributeOptionImages, b: AttributeOptionImages) => {
          if (a.imageType === 'front' && b.imageType !== 'front') return -1
          if (b.imageType === 'front' && a.imageType !== 'front') return 1
          return (a.displayOrder || 0) - (b.displayOrder || 0)
        })
        .map((img) => ({ ...img, displayOrder: Number(img.displayOrder) }))

      return sortedImages
    }
  }

  return [
    {
      imageType: 'front',
      id: 0,
      imageUrlNormal: '/no-image.webp',
      imageUrlThumb: '/no-image.webp',
      imageUrlZoom: '/no-image.webp',
      displayOrder: 0
    }
  ]
}



üìÅ ARCHIVO: src/helpers/utils.ts
------------------------------------------------------------------------------------
import { type PromotionVariants } from '@/types/domain'

/**
 * Formatea un precio en formato de moneda
 * @param price - El precio a formatear
 * @param currency - La moneda (por defecto PEN)
 * @returns El precio formateado
 */
export function formatPrice(price: number, currency: string = 'PEN'): string {
  const formatter = new Intl.NumberFormat('es-PE', {
    style: 'currency',
    currency,
    minimumFractionDigits: 2, // ‚úÖ M√≠nimo 2 decimales
    maximumFractionDigits: 2
  }) // ‚úÖ M√°ximo 2 decimales  })

  return formatter.format(price)
}

/**
 * Calcula el porcentaje de descuento entre dos precios
 * @param originalPrice - El precio original
 * @param discountedPrice - El precio con descuento
 * @returns El porcentaje de descuento
 */
export function calculateDiscount(
  originalPrice: number,
  discountedPrice: number
): number {
  if (originalPrice <= 0 || discountedPrice <= 0) return 0
  if (discountedPrice >= originalPrice) return 0

  const discount = ((originalPrice - discountedPrice) / originalPrice) * 100
  return Math.round(discount)
}

/**
 * Trunca un texto a una longitud m√°xima
 * @param text - El texto a truncar
 * @param maxLength - La longitud m√°xima
 * @returns El texto truncado
 */
export function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text
  return text.slice(0, maxLength) + '...'
}

/**
 * Genera un slug a partir de un texto
 * @param text - El texto a convertir en slug
 * @returns El slug generado
 */
export function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^\w ]+/g, '')
    .replace(/ +/g, '-')
}

/**
 * Obtiene una URL de imagen con dimensiones espec√≠ficas
 * @param url - La URL de la imagen
 * @param width - El ancho deseado
 * @param height - La altura deseada
 * @returns La URL de la imagen con las dimensiones especificadas
 */
export function getImageUrl(
  url: string,
  width: number,
  height: number
): string {
  // Si la URL ya contiene par√°metros de dimensiones, los reemplazamos
  if (url.includes('?w=') || url.includes('&w=')) {
    return url.replace(/([?&])(w=\d+)(&h=\d+)?/g, `$1w=${width}&h=${height}`)
  }

  // Si la URL ya tiene par√°metros, agregamos las dimensiones
  if (url.includes('?')) {
    return `${url}&w=${width}&h=${height}`
  }

  // Si la URL no tiene par√°metros, agregamos las dimensiones
  return `${url}?w=${width}&h=${height}`
}

export const getPromotions = (
  _pvs?: Array<PromotionVariants | null> | null
): PromotionVariants[] | undefined => {
  if (!_pvs) return []
  const pvsNotEmpty: PromotionVariants[] = _pvs.filter((pv) => !!pv)
  return pvsNotEmpty
}



üìÅ ARCHIVO: src/helpers/search.helpers.ts
------------------------------------------------------------------------------------
import { type ProductSearchFilters } from '@/backend/search'
import {
  SEARCH_INITIAL_PAGE,
  SEARCH_PRODUCTS_PER_PAGE
} from '@/constants/search.constants'
import { type FILTER_SORT, SEARCH_SORT, type SearchParams } from '@/shared'

export const formatParams = (params: SearchParams): ProductSearchFilters => {
  const filters = {
    query: params.q,
    categoryId: params.category ? parseInt(params.category) : undefined,
    brandId: params.brand ? parseInt(params.brand) : undefined,
    minPrice: params.minPrice ? parseFloat(params.minPrice) : undefined,
    maxPrice: params.maxPrice ? parseFloat(params.maxPrice) : undefined,
    page: params.page ? parseInt(params.page) : SEARCH_INITIAL_PAGE,
    limit: SEARCH_PRODUCTS_PER_PAGE,
    sort: (params.sort as FILTER_SORT) || SEARCH_SORT.NEWEST
  }
  return filters
}

export const getFilters = (params: SearchParams): ProductSearchFilters => {
  // Convertir par√°metros de b√∫squeda a filtros
  const filters = formatParams(params)

  // Procesar atributos desde searchParams
  // Formato esperado: attr_1=2,3&attr_2=5
  const attributeFilters: Record<number, number[]> = {}

  Object.keys(params).forEach((key) => {
    if (key.startsWith('attr_')) {
      const attributeId = parseInt(key.replace('attr_', ''))
      const optionIds = (params[key] as string)
        .split(',')
        .map((id) => parseInt(id))
      attributeFilters[attributeId] = optionIds
    }
  })

  if (Object.keys(attributeFilters).length > 0) {
    filters.attributes = attributeFilters
  }

  return filters
}



üìÅ ARCHIVO: src/services/footer/mock.ts
------------------------------------------------------------------------------------
export const dataMock = {
  sections: [
    {
      title: 'Compa√±√≠a',
      links: [
        { name: 'Sobre Nosotros', href: '/sobre-nosotros' },
        { name: 'Informaci√≥n de Delivery', href: '/delivery' },
        { name: 'Pol√≠tica de Privacidad', href: '/privacidad' },
        { name: 'T√©rminos y Condiciones', href: '/terminos' },
        { name: 'Cont√°ctanos', href: '/contacto' },
        { name: 'Centro de Soporte', href: '/soporte' }
      ]
    },
    {
      title: 'Mi Cuenta',
      links: [
        { name: 'Iniciar Sesi√≥n', href: '/login' },
        { name: 'Ver Carrito', href: '/carrito' },
        { name: 'Mi Lista de Deseos', href: '/wishlist' },
        { name: 'Rastrear mi Pedido', href: '/tracking' },
        { name: 'Ayuda', href: '/ayuda' },
        { name: 'Mis Pedidos', href: '/pedidos' }
      ]
    }
  ],
  socialLinks: [
    {
      name: 'Facebook',
      icon: '<svg class="h-5 w-5" fill="currentColor" viewBox="0 0 24 24"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z" /></svg>',
      href: 'https://facebook.com'
    },
    {
      name: 'Twitter',
      icon: '<svg class="h-5 w-5" fill="currentColor" viewBox="0 0 24 24"><path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z" /></svg>',
      href: 'https://twitter.com'
    },
    {
      name: 'Instagram',
      icon: '<svg class="h-5 w-5" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0C8.74 0 8.333.015 7.053.072 5.775.132 4.905.333 4.14.63c-.789.306-1.459.717-2.126 1.384S.935 3.35.63 4.14C.333 4.905.131 5.775.072 7.053.012 8.333 0 8.74 0 12s.015 3.667.072 4.947c.06 1.277.261 2.148.558 2.913.306.788.717 1.459 1.384 2.126.667.666 1.336 1.079 2.126 1.384.766.296 1.636.499 2.913.558C8.333 23.988 8.74 24 12 24s3.667-.015 4.947-.072c1.277-.06 2.148-.262 2.913-.558.788-.306 1.459-.718 2.126-1.384.666-.667 1.079-1.335 1.384-2.126.296-.765.499-1.636.558-2.913.06-1.28.072-1.687.072-4.947s-.015-3.667-.072-4.947c-.06-1.277-.262-2.149-.558-2.913-.306-.789-.718-1.459-1.384-2.126C21.319 1.347 20.651.935 19.86.63c-.765-.297-1.636-.499-2.913-.558C15.667.012 15.26 0 12 0zm0 2.16c3.203 0 3.585.016 4.85.071 1.17.055 1.805.249 2.227.415.562.217.96.477 1.382.896.419.42.679.819.896 1.381.164.422.36 1.057.413 2.227.057 1.266.07 1.646.07 4.85s-.015 3.585-.074 4.85c-.061 1.17-.256 1.805-.421 2.227-.224.562-.479.96-.899 1.382-.419.419-.824.679-1.38.896-.42.164-1.065.36-2.235.413-1.274.057-1.649.07-4.859.07-3.211 0-3.586-.015-4.859-.074-1.171-.061-1.816-.256-2.236-.421-.569-.224-.96-.479-1.379-.899-.421-.419-.69-.824-.9-1.38-.165-.42-.359-1.065-.42-2.235-.045-1.26-.061-1.649-.061-4.844 0-3.196.016-3.586.061-4.861.061-1.17.255-1.814.42-2.234.21-.57.479-.96.9-1.381.419-.419.81-.689 1.379-.898.42-.166 1.051-.361 2.221-.421 1.275-.045 1.65-.06 4.859-.06l.045.03zm0 3.678c-3.405 0-6.162 2.76-6.162 6.162 0 3.405 2.76 6.162 6.162 6.162 3.405 0 6.162-2.76 6.162-6.162 0-3.405-2.76-6.162-6.162-6.162zM12 16c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4zm7.846-10.405c0 .795-.646 1.44-1.44 1.44-.795 0-1.44-.646-1.44-1.44 0-.794.646-1.439 1.44-1.439.793-.001 1.44.645 1.44 1.439z" /></svg>',
      href: 'https://instagram.com'
    }
  ]
}



üìÅ ARCHIVO: src/services/footer/footer.ts
------------------------------------------------------------------------------------
import { type FooterModel } from './'
import { dataMock } from './mock'

export const getFooter = async (): Promise<FooterModel> => {
  try {
    return new Promise((resolve) => {
      resolve({
        sections: dataMock.sections,
        socialLinks: dataMock.socialLinks
      })
    })
  } catch (error) {
    throw new Error(
      `Error al obtener getHeader ${error instanceof Error ? error.message : 'Unknow error'}`
    )
  }
}



üìÅ ARCHIVO: src/services/footer/types.ts
------------------------------------------------------------------------------------
export interface FooterModel {
  sections: Array<{
    title: string
    links: Array<{ name: string, href: string }>
  }>
  socialLinks: Array<{
    name: string
    icon: string
    href: string
  }>
}



üìÅ ARCHIVO: src/services/footer/index.ts
------------------------------------------------------------------------------------
export * from './footer'
export * from './types'



üìÅ ARCHIVO: src/services/featuredCategories/featuredCategories.ts
------------------------------------------------------------------------------------
import categoryModel from '@/backend/category'
import { hydrateFeaturedCategories } from './hydrators'
import { type FeaturedCategory } from './types'

export const getFeaturedCategories = async (): Promise<FeaturedCategory[]> => {
  try {
    // // Obtener todas las categor√≠as
    const categoriesData = await categoryModel.getCategories()

    // // Filtrar categor√≠as principales para la secci√≥n de categor√≠as
    const mainCategories = categoriesData
      ? categoriesData.filter((cat) => !cat.parentId).slice(0, 8)
      : []

    const featuredCategories = mainCategories.slice(0, 3).map((category) => ({
      title: `Ofertas en ${category.name}`,
      subtitle: 'Descuentos especiales',
      image: category.imageUrl ?? null,
      link: 'url-category-mock' + category.name
    }))

    return hydrateFeaturedCategories(featuredCategories)
  } catch (error) {
    throw new Error(
      `Error al obtener getFeaturedCategories ${error instanceof Error ? error.message : 'Unknow error'}`
    )
  }
}



üìÅ ARCHIVO: src/services/featuredCategories/types.ts
------------------------------------------------------------------------------------
import { type Categories } from '@/types/domain'

export interface FeaturedCategory {
  title: string
  subtitle: string
  image: Categories['imageUrl']
  link?: string
}



üìÅ ARCHIVO: src/services/featuredCategories/index.ts
------------------------------------------------------------------------------------
export * from './featuredCategories'
export * from './types'



üìÅ ARCHIVO: src/services/featuredCategories/hydrators.ts
------------------------------------------------------------------------------------
import { type FeaturedCategory } from './types'

export const hydrateFeaturedCategories = (
  data: FeaturedCategory[]
): FeaturedCategory[] => {
  return data.map((item) => ({
    ...item
  }))
}



üìÅ ARCHIVO: src/services/mainCategories/types.ts
------------------------------------------------------------------------------------
export interface MainCategory {
  name: string
  image: string | null
}



üìÅ ARCHIVO: src/services/mainCategories/mainCategories.ts
------------------------------------------------------------------------------------
import categoryModel from '@/backend/category'
import { hydrateMainCategories } from './hydrators'
import { type MainCategory } from './types'

export const getMainCategories = async (): Promise<MainCategory[]> => {
  try {
    // Obtener todas las categor√≠as
    const categoriesData = await categoryModel.getCategories()

    // Filtrar categor√≠as principales para la secci√≥n de categor√≠as
    const mainCategories = categoriesData
      ? categoriesData.filter((cat) => !cat.parentId).slice(0, 8)
      : []

    return hydrateMainCategories(mainCategories)
  } catch (error) {
    throw new Error(
      `Error al obtener getMainCategories ${error instanceof Error ? error.message : 'Unknow error'}`
    )
  }
}



üìÅ ARCHIVO: src/services/mainCategories/index.ts
------------------------------------------------------------------------------------
export * from './mainCategories'
export * from './types'



üìÅ ARCHIVO: src/services/mainCategories/hydrators.ts
------------------------------------------------------------------------------------
import { type Categories as Category } from '@/types/domain'
import { type MainCategory } from './types'

export const hydrateMainCategories = (data: Category[]): MainCategory[] => {
  return data.map((item) => ({
    image: item.imageUrl ?? null,
    name: item.name
  }))
}



üìÅ ARCHIVO: src/services/features/mock.ts
------------------------------------------------------------------------------------
export const dataMock = [
  {
    icon: 'shipping',
    title: 'Env√≠o Gratis',
    description: 'Pedidos sobre S/99'
  },
  {
    icon: 'discount',
    title: 'Mejores Ofertas',
    description: 'Precios incre√≠bles'
  },
  {
    icon: 'delivery',
    title: 'Delivery R√°pido',
    description: 'En 24 horas'
  },
  {
    icon: 'secure',
    title: 'Pago Seguro',
    description: '100% protegido'
  }
]



üìÅ ARCHIVO: src/services/features/types.ts
------------------------------------------------------------------------------------
export interface Feature {
  title: string
  description: string
  icon: string
}



üìÅ ARCHIVO: src/services/features/features.ts
------------------------------------------------------------------------------------
import { dataMock } from './mock'
import { type Feature } from './types'

export const getFeatures = async (): Promise<Feature[]> => {
  return await new Promise((resolve) => {
    resolve(dataMock)
  })
}



üìÅ ARCHIVO: src/services/features/index.ts
------------------------------------------------------------------------------------
export * from './features'
export * from './types'



üìÅ ARCHIVO: src/services/customerService.ts
------------------------------------------------------------------------------------
/**
 * Autenticar un cliente con email y contrase√±a
 */
// export async function loginCustomer(
//   email: string,
//   plainPassword: string
// ): Promise<Customer | null> {
//   try {
//     // Obtener el cliente por email
//     const customer = await customerModel.getCustomerByEmail(email)

//     // Si no existe el cliente, retornar null
//     if (!customer) return null

//     // Verificar la contrase√±a con bcrypt
//     const isPasswordValid = await bcrypt.compare(
//       plainPassword,
//       customer.password
//     )
//     if (!isPasswordValid) return null

//     // Obtener el cliente completo con sus roles
//     const validCustomer = await customerModel.getCustomer(customer.id)
//     if (!validCustomer) return null

//     // No devolver la contrase√±a
//     // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     const { password, ...customerWithoutPassword } = validCustomer

//     return customerWithoutPassword as Customer
//   } catch (error) {
//     console.error('Error en login:', error)
//     return null
//   }
// }

/**
 * Registrar un nuevo cliente
 */
// export async function registerCustomer(customerData: {
//   username: string
//   email: string
//   password: string
//   name: string
//   lastname: string
//   address_id?: number
// }): Promise<Customer | null> {
//   try {
//     // Verificar si ya existe un cliente con ese email
//     const existingCustomer = await customerModel.getCustomerByEmail(
//       customerData.email
//     )
//     if (existingCustomer) {
//       throw new Error('El correo electr√≥nico ya est√° registrado')
//     }

//     // Encriptar la contrase√±a
//     const hashedPassword = await bcrypt.hash(customerData.password, 10)

//     // Crear el cliente con el rol por defecto si no se especifica
//     const newCustomer = await customerModel.createCustomer({
//       ...customerData,
//       password: hashedPassword
//     })

//     if (newCustomer === undefined) {
//       throw new Error('No se pudo crear a Cliente')
//     }

//     // No devolver la contrase√±a
//     // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     const { password, ...customerWithoutPassword } = newCustomer

//     return customerWithoutPassword as Customer
//   } catch (error) {
//     console.error('Error en register:', error)
//     throw error
//   }
// }

// /**
//  * Obtener un cliente por su ID
//  */
// export async function getCustomerById(id: number): Promise<Customer | null> {
//   try {
//     const customer = await customerModel.getCustomer(id)

//     if (!customer) return null

//     // No devolver la contrase√±a
//     // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     const { password, ...customerWithoutPassword } = customer

//     return customerWithoutPassword as Customer
//   } catch (error) {
//     console.error('Error en getCustomerById:', error)
//     return null
//   }
// }

// /**
//  * Obtener un cliente por su email
//  */
// export async function getCustomerByEmail(
//   email: string
// ): Promise<Customer | null> {
//   try {
//     const customer = await customerModel.getCustomerByEmail(email)

//     if (!customer) return null

//     // No devolver la contrase√±a
//     // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     const { password, ...customerWithoutPassword } = customer

//     return customerWithoutPassword as Customer
//   } catch (error) {
//     console.error('Error en getCustomerByEmail:', error)
//     return null
//   }
// }



üìÅ ARCHIVO: src/services/product/productVariant.ts
------------------------------------------------------------------------------------
import productModel from '@/backend/product'
import productVariantModel, {
  type ProductVariantWithAttributeOptions
} from '@/backend/product-variant'
import { type Products as Product } from '@/types/domain'

export interface ProductVariantData {
  product: Product
}

export const getProductVariant = async (
  variantId: number
): Promise<ProductVariantData | null> => {
  try {
    // Obtener la variante espec√≠fica
    const variant = await productVariantModel.getProductVariantById(variantId)

    if (!variant) {
      return null
    }

    // Obtener el producto completo
    const product = await productModel.getProductById(variant.productId)

    if (!product) {
      return null
    }

    return {
      // variant,
      product
    }
  } catch (error) {
    throw new Error(
      `Error al obtener getProductVariant ${error instanceof Error ? error.message : 'Unknown error'}`
    )
  }
}

export const getProductVariantsByProductId = async (
  productId: number
): Promise<ProductVariantWithAttributeOptions[] | null> => {
  try {
    // Obtener todas las variantes del producto con atributos
    const variants =
      await productVariantModel.getProductVariantsByProductIdWithAttributeOptions(
        productId
      )

    if (!variants) {
      return null
    }

    return variants
  } catch (error) {
    throw new Error(
      `Error al obtener getProductVariantsByProductId ${error instanceof Error ? error.message : 'Unknown error'}`
    )
  }
}



üìÅ ARCHIVO: src/services/product/index.ts
------------------------------------------------------------------------------------
import {
  getProductVariant,
  getProductVariantsByProductId
} from './productVariant'

const productService = {
  getProductVariant,
  getProductVariantsByProductId
}

export default productService



üìÅ ARCHIVO: src/services/search/index.ts
------------------------------------------------------------------------------------
import { getSearchParams } from './searchParams'

const searchService = {
  getSearchParams
}

export default searchService



üìÅ ARCHIVO: src/services/search/searchSuggestions.ts
------------------------------------------------------------------------------------
export interface SearchSuggestionsService {
  getSuggestions: (query: string, limit?: number) => Promise<string[]>
}

export class SearchSuggestionsServiceImpl implements SearchSuggestionsService {
  async getSuggestions(query: string, limit: number = 10): Promise<string[]> {
    try {
      if (!query || query.trim().length < 2) {
        return []
      }

      const response = await fetch(
        `/api/search/suggestions?q=${encodeURIComponent(query)}&limit=${limit}`
      )

      if (!response.ok) {
        throw new Error('Error al obtener sugerencias')
      }

      const suggestions: string[] = await response.json()
      return suggestions
    } catch (error) {
      console.error('Error en SearchSuggestionsService:', error)
      return []
    }
  }
}

export const searchSuggestionsService = new SearchSuggestionsServiceImpl()



üìÅ ARCHIVO: src/services/search/searchParams.ts
------------------------------------------------------------------------------------
import searchModel, {
  type ProductSearchFilters,
  type ProductSearchResult
} from '@/backend/search'

export const getSearchParams = async (
  filters: ProductSearchFilters
): Promise<ProductSearchResult> => {
  try {
    const searchResults = await searchModel.searchProducts(filters)
    return searchResults
  } catch (error) {
    throw new Error(
      `Error al obtener getSearchParams ${error instanceof Error ? error.message : 'Unknow error'}`
    )
  }
}



üìÅ ARCHIVO: src/services/popularProducts/index.ts
------------------------------------------------------------------------------------
export * from './popularProducts'



üìÅ ARCHIVO: src/services/popularProducts/hydrators.ts
------------------------------------------------------------------------------------
import { type ProductComplete } from '@/backend/product'
import { type ProductSearchItem } from '@/backend/search'

export const hydratePopularProducts = (
  data: ProductSearchItem[]
): ProductComplete[] => {
  return data.map((item) => ({
    name: item.name,
    variantId: item.variantId,
    variantPrice: item.variantPrice,
    variants: item.variants
  }))
}



üìÅ ARCHIVO: src/services/popularProducts/popularProducts.ts
------------------------------------------------------------------------------------
import { type ProductComplete } from '@/backend/product'
import searchModel from '@/backend/search'
import { hydratePopularProducts } from './hydrators'

export const getPopularProducts = async (): Promise<ProductComplete[]> => {
  try {
    const popularSearchResult = await searchModel.searchProducts({
      page: 1,
      limit: 6,
      sort: 'newest'
    })

    return hydratePopularProducts(popularSearchResult.products)
  } catch (error) {
    throw new Error(
      `Error al obtener popularSearchResult ${error instanceof Error ? error.message : 'Unknow error'}`
    )
  }
}



üìÅ ARCHIVO: src/services/hero/mock.ts
------------------------------------------------------------------------------------
export const dataMock = [
  {
    title: 'No te pierdas las ofertas incre√≠bles',
    subtitle: 'Hasta 50% OFF en toda la tienda',
    description: 'Aprovecha nuestras ofertas especiales en tecnolog√≠a',
    image:
      'https://images.unsplash.com/photo-1607082348824-0a96f2a4b9da?w=1920&h=600&fit=crop',
    cta: 'Comprar Ahora',
    ctaLink: '/search'
  },
  {
    title: 'Descuentos en Tecnolog√≠a',
    subtitle: 'Ahorra hasta S/1,200',
    description: 'Los mejores smartphones y laptops con precios especiales',
    image:
      'https://images.unsplash.com/photo-1593642632823-8f785ba67e45?w=1920&h=600&fit=crop',
    cta: 'Ver Ofertas',
    ctaLink: '/search?category=tecnologia'
  }
]



üìÅ ARCHIVO: src/services/hero/hero.ts
------------------------------------------------------------------------------------
import { dataMock } from './mock'
import { type Hero } from './types'

export const getHero = async (): Promise<Hero[]> => {
  return await new Promise((resolve) => {
    resolve(dataMock)
  })
}



üìÅ ARCHIVO: src/services/hero/types.ts
------------------------------------------------------------------------------------
export interface Hero {
  title: string
  subtitle: string
  description: string
  image: string
  cta: string
  ctaLink: string
}



üìÅ ARCHIVO: src/services/hero/index.ts
------------------------------------------------------------------------------------
export * from './hero'
export * from './types'



üìÅ ARCHIVO: src/services/dealsProducts/dealsProducts.ts
------------------------------------------------------------------------------------
import searchModel, { type ProductSearchItem } from '@/backend/search'
import { hydrateDealsProducts } from './hydrators'

export const getDealsProducts = async (): Promise<ProductSearchItem[]> => {
  try {
    const dealsSearchResult = await searchModel.searchProducts({
      page: 1,
      limit: 5,
      sort: 'price_desc'
    })
    return hydrateDealsProducts(dealsSearchResult.products)
  } catch (error) {
    throw new Error(
      `Error al obtener getDealsProducts ${error instanceof Error ? error.message : 'Unknow error'}`
    )
  }
}



üìÅ ARCHIVO: src/services/dealsProducts/types.ts
------------------------------------------------------------------------------------
export interface MainCategory {
  name: string
  image: string | null
}



üìÅ ARCHIVO: src/services/dealsProducts/index.ts
------------------------------------------------------------------------------------
export * from './dealsProducts'
export * from './types'



üìÅ ARCHIVO: src/services/dealsProducts/hydrators.ts
------------------------------------------------------------------------------------
import { type ProductSearchItem } from '@/backend/search'

export const hydrateDealsProducts = (
  data: ProductSearchItem[]
): ProductSearchItem[] => {
  return data.map((item) => ({
    ...item
  }))
}



üìÅ ARCHIVO: src/services/header/index.ts
------------------------------------------------------------------------------------
export * from './header'



üìÅ ARCHIVO: src/services/header/header.ts
------------------------------------------------------------------------------------
import categoryModel from '@/backend/category'
import { type Categories } from '@/types/domain'
import { hydrateHeader } from './hydrators'

export const getHeader = async (): Promise<Categories[] | undefined> => {
  try {
    const categories = await categoryModel.getCategories()
    return hydrateHeader(categories)
  } catch (error) {
    throw new Error(
      `Error al obtener getHeader ${error instanceof Error ? error.message : 'Unknow error'}`
    )
  }
}



üìÅ ARCHIVO: src/services/header/hydrators.ts
------------------------------------------------------------------------------------
import { type Categories } from '@/types/domain'

export const hydrateHeader = (
  data: Categories[] | undefined
): Categories[] | undefined => {
  return data?.map((item) => ({
    ...item
  }))
}



üìÅ ARCHIVO: src/services/banner/mock.ts
------------------------------------------------------------------------------------
export const dataMock = [
  {
    title: 'Smartphones',
    subtitle: 'Oferta Especial',
    image:
      'https://images.unsplash.com/photo-1511707171634-5f897ff02aa9?w=400&h=200&fit=crop',
    link: '/search?category=smartphones'
  },
  {
    title: 'Laptops',
    subtitle: 'Solo esta semana',
    image:
      'https://images.unsplash.com/photo-1517336714731-489689fd1ca8?w=400&h=200&fit=crop',
    link: '/search?category=laptops'
  }
]



üìÅ ARCHIVO: src/services/banner/banner.ts
------------------------------------------------------------------------------------
import { dataMock } from './mock'
import { type Banner } from './types'

export const getBanner = async (): Promise<Banner[]> => {
  return await new Promise((resolve) => {
    resolve(dataMock)
  })
}



üìÅ ARCHIVO: src/services/banner/types.ts
------------------------------------------------------------------------------------
export interface Banner {
  title: string
  subtitle: string
  image: string
  link: string
}



üìÅ ARCHIVO: src/services/banner/index.ts
------------------------------------------------------------------------------------
export * from './banner'
export * from './types'



üìÅ ARCHIVO: src/services/customer/login.ts
------------------------------------------------------------------------------------
import customerModel from '@/backend/customer'
import { type Customers as Customer } from '@/types/domain'
import bcrypt from 'bcryptjs'

/**
 * Autenticar un cliente con email y contrase√±a
 */

interface loginProps {
  email: string
  password: string
}

export const login = async ({
  email,
  password: plainPassword
}: loginProps): Promise<Customer | null> => {
  try {
    // Obtener el cliente por email
    const customer = await customerModel.getCustomerByEmail(email)

    // Si no existe el cliente, retornar null
    if (customer === undefined) return null

    // Verificar la contrase√±a con bcrypt
    const isPasswordValid = await bcrypt.compare(
      plainPassword,
      customer.password
    )
    if (!isPasswordValid) return null

    // Obtener el cliente completo con sus roles
    const validCustomer = await customerModel.getCustomer(customer.id)
    if (validCustomer === undefined) return null

    // No devolver la contrase√±a
    const { password, ...customerWithoutPassword } = validCustomer

    return customerWithoutPassword as Customer
  } catch (error) {
    console.error('Error en login:', error)
    return null
  }
}



üìÅ ARCHIVO: src/services/customer/types.ts
------------------------------------------------------------------------------------
export interface CustomerData {
  name: string
  email: string
  password: string
  lastname: string
}



üìÅ ARCHIVO: src/services/customer/index.ts
------------------------------------------------------------------------------------
import { login } from './login'
import { register } from './register'

const CustomerService = {
  login,
  register
}

export default CustomerService



üìÅ ARCHIVO: src/services/customer/register.ts
------------------------------------------------------------------------------------
import customerModel from '@/backend/customer'
import { type Customers as Customer } from '@/types/domain'
import bcrypt from 'bcryptjs'
import { type CustomerData } from './types'

/**
 * Registrar un nuevo cliente
 */

export const register = async (
  customerData: CustomerData
): Promise<Customer | null> => {
  try {
    // Verificar si ya existe un cliente con ese email
    const existingCustomer = await customerModel.getCustomerByEmail(
      customerData.email
    )

    if (existingCustomer?.email != null) {
      throw new Error('El correo electr√≥nico ya est√° registrado')
    }

    // Encriptar la contrase√±a
    const hashedPassword = await bcrypt.hash(customerData.password, 10)

    // Crear el cliente con el rol por defecto si no se especifica
    const newCustomer = await customerModel.createCustomer({
      ...customerData,
      password: hashedPassword
    })

    if (newCustomer === undefined) {
      throw new Error('No se pudo crear a Cliente')
    }

    // No devolver la contrase√±a
    const { password, ...customerWithoutPassword } = newCustomer

    return customerWithoutPassword as Customer
  } catch (error) {
    console.error('Error en register:', error)
    throw error
  }
}



